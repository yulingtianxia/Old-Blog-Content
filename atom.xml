<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-10-19T10:00:19+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Xcode6将你的项目本地化]]></title>
    <link href="http://yulingtianxia.com/blog/2014/10/02/localizing-with-xcode-6/"/>
    <updated>2014-10-02T12:54:41+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/10/02/localizing-with-xcode-6</id>
    <content type="html"><![CDATA[<p>iOS和OSX支持40种语言的本地化，Xcode无疑为这一过程提供了强有力的支持。苹果将这一多语言适配过程细分为Internationalization（国际化）和Localization（本地化）两个阶段。</p>

<!--more-->


<h2>国际化&mdash;准备你的APP</h2>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-9%402x.png" alt="" /></p>

<p>在将你的APP适配各种语言本地化之前，你得先让你的APP富有国际范儿，也就是说国际化是一条通往本地化的必经之路。在国际化阶段，你需要让你的APP与语言和区域独立。</p>

<p>苹果的框架已经帮我们把不同语言的数据分离开，这更有助于我们管理这些资源，包括图片、声音、视频、文档、用户界面文字（甚至代码中编写的用户界面文字），它们会被建立在同一个bundle中。</p>

<h3>NSLocalizedString</h3>

<p>我们来使用<code>NSLocalizedString</code>来让用户界面的文字国际化，不过这些文字不是在IB上输入的，而是在代码中产生并赋值的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="nx">NSLocalizedString</span><span class="p">(</span><span class="nx">key</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">tableName</span><span class="o">:</span> <span class="nb">String</span><span class="o">?</span> <span class="o">=</span> <span class="k">default</span><span class="p">,</span> <span class="nx">bundle</span><span class="o">:</span> <span class="nx">NSBundle</span> <span class="o">=</span> <span class="k">default</span><span class="p">,</span> <span class="nx">value</span><span class="o">:</span> <span class="nb">String</span> <span class="o">=</span> <span class="k">default</span><span class="p">,</span> <span class="err">#</span><span class="nx">comment</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">String</span>
</span></code></pre></td></tr></table></div></figure>


<p>
上面这个Swift语言声明的函数可以直接返回一个经过本地化处理过的字符串，这就使得你在代码中给一些控件文本赋值时更有“国际化视野”：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">self</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="nx">NSLocalizedString</span><span class="p">(</span><span class="s2">&quot;SHARE&quot;</span><span class="p">,</span> <span class="nx">comment</span><span class="o">:</span> <span class="s2">&quot;share score&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
因为不用的语言会有不同的专业名词，所以最后的comment参数很重要，它可以暗示翻译人员这段文字要表达的含义。而第一个参数key的内容为基础语种的内容，将它作为“键”来映射其他语言对应翻译后的“值”。如果我们需要在字符串中插入其他内容，这时需要改进下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">text</span> <span class="o">=</span> <span class="nb">String</span><span class="p">.</span><span class="nx">localizedStringWithFormat</span><span class="p">(</span><span class="nx">NSLocalizedString</span><span class="p">(</span><span class="s2">&quot;I got %d points in Spiral. Come on with me! https://itunes.apple.com/us/app/square-spiral/id920811081&quot;</span><span class="p">,</span> <span class="nx">comment</span><span class="o">:</span> <span class="s2">&quot;share content&quot;</span><span class="p">),</span> <span class="nx">Data</span><span class="p">.</span><span class="nx">score</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
<code>localizedStringWithFormat:</code>方法保证了插入字符串中的内容也被转化成本地格式，比如时间格式、数字的格式等。而此时在Swift字符串中插入其他数据就不能使用<code>\()</code>了，只能用百分号占位的形式。</p>

<p>对应的在Localizable.strings中可以这样写：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="cm">/*share score*/</span>
</span><span class='line'><span class="s2">&quot;SHARE&quot;</span><span class="o">=</span><span class="s2">&quot;分享战绩&quot;</span><span class="p">;</span>
</span><span class='line'><span class="cm">/*share content*/</span>
</span><span class='line'><span class="s2">&quot;I got %d points in Spiral. Come on with me! https://itunes.apple.com/us/app/square-spiral/id920811081&quot;</span><span class="o">=</span><span class="s2">&quot;我在Spiral游戏中得了%1$d分，快来超越我吧！https://itunes.apple.com/cn/app/square-spiral/id920811081&quot;</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这样就将英文与中文键值对应起来了，注意那个“1$”表示是在键内容（即英文原文）中第一个插入的数据，因为不用语言表达同一个意思时，插入字符串中的数据顺序可能会有变化，这个&#8221;数字+$&ldquo;的标记记录了它们原本的顺序。</p>

<h3>NSFormatter</h3>

<p>NSFormatter算是老朋友了，它把数据转化成人们易读的字符串，而且还会根据不同语言和区域进行格式上的优化。它默认使用当地的语言习惯，我们不需要配置任何参数。比如显示时间日期，数字，金融，字节计数等格式上的本地化。现在iOS8和OSX Yosemite加入了健康相关的功能，NSFormatter也加入了很多新的量词，比如能量、长度高度、重量等方面。</p>

<h3>NSBundle</h3>

<p>你的APP构建于很多文件夹中，而不是一个单独的文件。这些文件夹被叫做bundle。它们不仅仅包含了你的APP，还有你APP的扩展(extensions)，你的构架(frameworks)等。而NSBundle提供了获取这些bundle中资源的标准API。当你使用这些API的时候，它们会自动使用符合当前地区语言的最恰当的资源。建立bundle是Xcode的活儿，所以我们不需要手动去管理这些资源文件放在bundle的具体位置，而是告诉Xcode哪些资源可以被本地化，设置好资源文件对应的语言，然后就交给Xcode去管理这些资源文件在bundle中的位置吧。</p>

<p>所以我们在加载一些资源文件的时候依然向以前那样从bundle获取url就行啦，Xcode已经帮我们替换成了本地化的资源，前提是你已经在Xcode中设置好了当前语言版本的对应资源。</p>

<h3>Xcode</h3>

<p>在Xcode5中支持了使用base国际化并用自动布局优化国际化后的界面，现在其他资源文件也可以这么干了，甚至可以在Xcode中预览界面布局效果。</p>

<p>点选一个xib或storyboard文件后，在File Inspector中的Localization中可以设置支持的语言。Xcode会自动从界面元素中提取出文字到strings文件中，翻译人员可以根据注释来在对应语言的strings文件中进行翻译。当然也可以直观化的转换成界面形式的文件来直观化翻译工作：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-2%402x.png" alt="" /></p>

<p>其他诸如图片、声音、影片等资源文件也可以通过类似的方法本地化：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-3%402x.png" alt="" /></p>

<p>在Xcode6中我们可以在Debug时预览不同语言和地区APP的界面效果，这样我们就不用在debug阶段不断的切换模拟器或真机的系统语言了！首先要在scheme中更改下运行APP的语言和地区：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-4%402x.png" alt="" /></p>

<p>注意到后面还有两项：双倍长度的模拟语言和从右到左的模拟语言，这两种是模拟极端状况下来考验我们UI效果的。比如在表达相同语义时英语的长度要比汉语长很多，而德语又比英语长一些，这很可能让APP的界面造成混乱；而还有语言是从右到作的（古汉语的写法？），这也都是一些APP需要考虑的地方。</p>

<p>在Xcode6的Assistent Editor中我们可以无须在模拟器或真机上运行APP就可以在设计界面时预览界面的本地化效果，并在右下角的语言选项中切换语言：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-5%402x.png" alt="" /></p>

<p>PS：语言和地区这两个选项是有差别的，比如当我们将地区设置成瑞典，虽然我们没有提供对应的瑞典版本的界面文字翻译，但是时间日期的显示方式等还是会遵从瑞典的习惯来显示。所以地区这一项可供选择的选项包含了所有地区，而语言这一选项只包含了我们在国际化工作中所支持的语言，因为只有国际化中支持的语言（比如上图，我只加入了英语和汉语）才有相应的资源文件；而NSFormatter地区格式优化是内建的，无需我们提供格式。</p>

<h2>本地化&mdash;翻译你的APP</h2>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-8%402x.png" alt="" /></p>

<p>之前国际化的工作就是将工程变得有国际范儿，建立起了支持多语种的架构，那么接下来就是苦逼的翻译工作和本地资源准备工作，说好听点儿就叫本地化。</p>

<p>首先要把表面上的工作做了，也就是翻译用户界面上所有的文字。当然这不是程序员该干的活儿，更不能直接交给谷歌翻译，而程序员与专业翻译人员沟通时还是需要成本的：首先把需要翻译的内容从工程里整理出来，然后交给负责翻译的妹子，等妹子翻译好后再把结果导入工程中，嗯目测工作量亚历山大。PS：为什么翻译是妹子？</p>

<p>就算妹子再萌，也不能因为这占用了程序猿们宝贵的工作时间！Xcode6简化了导入导出这些资源的流程，它会检查IB资源和源文件并提取“source strings”，并生成XLIFF文件。翻译好的XLIFF文件也可以通过Xcode导入到工程中来生成和更新资源。嗯，可以把省下来的时间干一些其他的事情咯。</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-6%402x.png" alt="" /></p>

<p>PS：XLIFF是由软件开发商、本地化服务提供商、本地化工具提供商等团体共同倡议和设计，由OASIS标准组织发布的用于本地化数据交换的格式标准。它基于XML技术制定软件资源文件格式的转换规格，其目的在于提高软件的本地化作业效率。</p>

<p>导出和导出XLIFF就是如此简单，选中项目，在Editor菜单中可以就找到：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-7%402x.png" alt="" /></p>

<p>也可以通过命令行的方式进行导入导出XLIFF文件操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">xcodebuide</span> <span class="o">-</span><span class="nx">exportLocalizations</span> <span class="o">-</span><span class="nx">project</span> <span class="o">&lt;</span><span class="nx">project</span><span class="o">&gt;</span> <span class="o">-</span><span class="nx">localizationPath</span> <span class="o">&lt;</span><span class="nx">path</span><span class="o">&gt;</span>
</span><span class='line'><span class="nx">xcodebuide</span> <span class="o">-</span><span class="nx">importLocalizations</span> <span class="o">-</span><span class="nx">project</span> <span class="o">&lt;</span><span class="nx">project</span><span class="o">&gt;</span> <span class="o">-</span><span class="nx">localizationPath</span> <span class="o">&lt;</span><span class="nx">path</span><span class="o">&gt;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>迭代开发&mdash;更新你的APP</h2>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-10%402x.png" alt="" /></p>

<p>无需把翻译工作推到最后去做，因为导入和导出XLIFF文件是可以持续集成的，一边写代码，一边把现有内容导出XLIFF给他人翻译，这样能提高效率。每当有新的翻译修改时也可以及时更新，Xcode会把XLIFF文件内容与当前翻译进度合并；在导出XLIFF时可以选择导出当前开发使用的语言还是已经翻译中的语言，这些强大的服务无疑是Xcode6所赐予我们的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[UIAlertController in iOS8]]></title>
    <link href="http://yulingtianxia.com/blog/2014/09/29/uialertcontroller-in-ios8/"/>
    <updated>2014-09-29T20:29:28+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/09/29/uialertcontroller-in-ios8</id>
    <content type="html"><![CDATA[<p>iOS8新推出的UIAlertController究竟是为了什么？已有的<code>UIActionSheet</code>和<code>UIAlertView</code>就这样被打酱油了么？其实不然。。。</p>

<!--more-->


<h2>UIAlertController是什么</h2>

<p><code>UIAlertController</code>是iOS8中新加入的一个ViewController，其主要功能是提醒（Alert），并取代 <code>UIActionSheet</code>和<code>UIAlertView</code>向用户展示提醒消息。因为它是一个ViewController，所以可以用<code>presentViewController:animated:completion:</code>方法来弹出它。</p>

<h2>为什么不直接使用<code>UIActionSheet</code>和<code>UIAlertView</code></h2>

<ol>
<li><code>UIAlertController</code>采用block异步回调的形式来代理按钮的动作和文本框的配置，这样显得更加代码紧凑，可读性高。这样就不用通过协议代理给其他类，使得同一个逻辑下本应在一起的代码分离开。</li>
<li><code>UIActionSheet</code>和<code>UIAlertView</code>执行的都是提醒功能，只是展现的位置略有不同，合并相似功能并上升到Controller的级别，这是一种进步。</li>
<li><code>UIAlertController</code>在添加按钮和文本框时更加灵活，而<code>UIAlertView</code>只提供了四种Style，局限性太大。</li>
<li><code>UIAlertController</code>在增加拓展性的基础上也限定了一些风格来进行约束，不过新增加的风格比<code>UIAlertView</code>更贴合实际应用。</li>
</ol>


<p>PS：其实最直接的原因就是博主想弹出个Alert，有俩文本框的（不要密码输入框），可惜<code>UIAlertView</code>做不到啊！！！</p>

<h2>创建一个<code>UIAlertController</code></h2>

<p>创建很简单有木有：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>convenience init(title title: String?,
</span><span class='line'>         message message: String?,
</span><span class='line'>  preferredStyle preferredStyle: UIAlertControllerStyle)</span></code></pre></td></tr></table></div></figure>


<p>举个栗子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">title</span> <span class="o">=</span> <span class="s2">&quot;Enter Choices of the Trouble&quot;</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">message</span> <span class="o">=</span> <span class="nx">detailItem</span><span class="o">?</span><span class="p">.</span><span class="nx">content</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">alert</span> <span class="o">=</span> <span class="nx">UIAlertController</span><span class="p">(</span><span class="nx">title</span><span class="o">:</span> <span class="nx">title</span><span class="p">,</span> <span class="nx">message</span><span class="o">:</span> <span class="nx">message</span><span class="p">,</span> <span class="nx">preferredStyle</span><span class="o">:</span> <span class="nx">UIAlertControllerStyle</span><span class="p">.</span><span class="nx">Alert</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
<code>title</code>和<code>message</code>自然不用说了吧，需要注意的是<code>preferredStyle</code>一旦设定好以后就不能改了哦，因为它就是区分<code>UIAlertController</code>到底是对应着<code>UIActionSheet</code>还是<code>UIAlertView</code>，一共就这两种Style：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">enum</span> <span class="nx">UIAlertControllerStyle</span> <span class="o">:</span> <span class="nx">Int</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="nx">ActionSheet</span>
</span><span class='line'>    <span class="k">case</span> <span class="nx">Alert</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>添加动作</h2>

<p>以前的做法是给个按钮标题数组然后在实现协议的代理方法中判断下按钮序列，然后对应给出不同的处理流程。分散的逻辑和代码无疑增加了开发者的工作量，还要求对应的类实现代理协议，真是out了。</p>

<p>这里介绍一个新的类：UIAlertAction，<code>UIAlertController</code>弱化了以前添加Button的概念，而是添加UIAlertAction。其实说白了就是将按钮和处理方法捏到一起成为一个“动作”：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">convenience</span> <span class="nx">init</span><span class="p">(</span><span class="nx">title</span> <span class="nx">title</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span>
</span><span class='line'>           <span class="nx">style</span> <span class="nx">style</span><span class="o">:</span> <span class="nx">UIAlertActionStyle</span><span class="p">,</span>
</span><span class='line'>         <span class="nx">handler</span> <span class="nx">handler</span><span class="o">:</span> <span class="p">((</span><span class="nx">UIAlertAction</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Void</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
<code>title</code>就是按钮的文本内容；<code>style</code>是按钮的风格，一共有三种风格：Default，Cancel和Destructive，其中Destructive会使按钮文字变成红色；<code>handler</code>是处理按钮按下后的一个block，这段代码块与添加的按钮紧密结合成“动作”，最后通过<code>addAction:</code>方法将UIAlertAction添加到<code>UIAlertController</code>中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">cancelbtn</span> <span class="o">=</span> <span class="s2">&quot;Cancel&quot;</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">cancelAction</span> <span class="o">=</span> <span class="nx">UIAlertAction</span><span class="p">(</span><span class="nx">title</span><span class="o">:</span> <span class="nx">cancelbtn</span><span class="p">,</span> <span class="nx">style</span><span class="o">:</span> <span class="p">.</span><span class="nx">Cancel</span><span class="p">)</span> <span class="p">{</span> <span class="p">(</span><span class="nx">action</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Void</span> <span class="k">in</span>
</span><span class='line'><span class="c1">//add some code...            </span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">alert</span><span class="p">.</span><span class="nx">addAction</span><span class="p">(</span><span class="nx">cancelAction</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>添加文本框</h2>

<p>这也是最令博主激动的地方，最然不能自定义Alert中的内容，但起码添加UITextField不受限制了。添加文本框的方法实在是简洁：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="nx">addTextFieldWithConfigurationHandler</span><span class="p">(</span><span class="nx">_</span> <span class="nx">configurationHandler</span><span class="o">:</span> <span class="p">((</span><span class="nx">UITextField</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Void</span><span class="p">)</span><span class="o">!</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
一个block就解决了！你只需要在block中配置下文本框的字体、键盘、代理等即可，举个栗子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">alert</span><span class="p">.</span><span class="nx">addTextFieldWithConfigurationHandler</span> <span class="p">{</span> <span class="p">(</span><span class="nx">choiceNameTF</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Void</span> <span class="k">in</span>
</span><span class='line'>    <span class="nx">choiceNameTF</span><span class="p">.</span><span class="nx">borderStyle</span> <span class="o">=</span> <span class="p">.</span><span class="nx">None</span>
</span><span class='line'>    <span class="nx">choiceNameTF</span><span class="p">.</span><span class="nx">placeholder</span> <span class="o">=</span> <span class="s2">&quot;An answer of your trouble&quot;</span>
</span><span class='line'>    <span class="nx">choiceNameTF</span><span class="p">.</span><span class="nx">delegate</span> <span class="o">=</span> <span class="nx">self</span>
</span><span class='line'>    <span class="nx">choiceNameTF</span><span class="p">.</span><span class="nx">becomeFirstResponder</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>美中不足的是文本框的代理还需要在另外一个地方写代码来实现协议，这种历史遗留问题终将被block统统解决！</p>

<h2>总结</h2>

<p><code>UIAlertController</code>的确是方便多了，无论是代码的简洁性还是可读性，都有了较大的提升。不过也有缺点，就是动用Controller的层级略显麻烦，尤其是使用<code>presentViewController:animated:completion:</code>方法来弹出Alert界面与之前的一个潇洒的<code>show</code>相比真是有些“霸气”。看个人喜好了，只要满足需求，咋方便咋用。</p>

<p>最后，贴上一张效果图：</p>

<p><img src="http://yulingtianxia.qiniudn.com/IMG_0906.PNG" alt="" /></p>

<p>图片截取自<a href="https://itunes.apple.com/cn/app/hardchoice/id923977271?mt=8">HardChoice</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Swift中构建assert(), 第一部分: Lazy Evaluation]]></title>
    <link href="http://yulingtianxia.com/blog/2014/09/26/building-assert-in-swift-1/"/>
    <updated>2014-09-26T20:37:52+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/09/26/building-assert-in-swift-1</id>
    <content type="html"><![CDATA[<p>本文翻译自<a href="https://developer.apple.com/swift/blog/?id=4">Building assert() in Swift, Part 1: Lazy Evaluation</a></p>

<!--more-->


<p>我们在设计Swift的时候觉得废除C预处理，排除bug并让我们的代码更加通俗易懂。这是开发者的大捷，也意味着Swift需要用新的方式实现旧的特性。大多数的特性（模块引入，条件编译）都了无新意，但或许最有趣的就是如何让Swift支持像<code>assert()</code>这样的宏。</p>

<p>当构建C语言的release版本时，<code>assert()</code>宏指令并没有运行时特性，因为它不对任何参数做计算。C语言中最流行的实现方法如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="cp">#ifdef NDEBUG</span>
</span><span class='line'><span class="cp">#define assert(e)  ((void)0)</span>
</span><span class='line'><span class="cp">#else</span>
</span><span class='line'><span class="cp">#define assert(e)  \</span>
</span><span class='line'><span class="cp"> ((void) ((e) ? ((void)0) : __assert (#e, __FILE__, __LINE__)))</span>
</span><span class='line'><span class="cp">#define __assert(e, file, line) \</span>
</span><span class='line'><span class="cp"> ((void)printf (&quot;%s:%u: failed assertion `%s&#39;\n&quot;, file, line, e), abort())</span>
</span><span class='line'><span class="cp">#endif</span>
</span></code></pre></td></tr></table></div></figure>


<p>
Swift模拟的断言(assert)提供C语言中断言几乎所有功能，不使用预处理，以更干净的方式实现。让我们深入学习Swift一些有趣的特性吧。</p>

<h2>参数的惰性计算（Lazy Evaluation）</h2>

<p>当实现Swift的<code>assert()</code>时，我们遇到的第一个挑战是没有明确的方式让一个函数接收一个表达式而不评判它。比如，我们想使用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">assert</span><span class="p">(</span><span class="n">x</span> <span class="o">:</span> <span class="n">Bool</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="err">#</span><span class="k">if</span> <span class="o">!</span><span class="n">NDEBUG</span>
</span><span class='line'>
</span><span class='line'>      <span class="cm">/*noop*/</span>
</span><span class='line'>  <span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
甚至当断言失效，应用程序将会在计算表达式时损失性能：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">someExpensiveComputation</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">42</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
修复这种情况的一种方法是在定义断言的时候让它接收一个闭包(closure)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">assert</span><span class="p">(</span><span class="n">predicate</span> <span class="o">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="err">#</span><span class="k">if</span> <span class="o">!</span><span class="n">NDEBUG</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">!</span><span class="n">predicate</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">abort</span><span class="p">()</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
正如我们想要的，只有在断言有效时才计算表达式，但它也给我们留下了一个不幸的调用语法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">assert</span><span class="p">({</span> <span class="n">someExpensiveComputation</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">42</span> <span class="p">})</span>
</span></code></pre></td></tr></table></div></figure>


<p>
我们可以用Swift的<code>@autoclosure</code>属性来修复它。这个自动闭包属性可以用在函数的参数上来表明一个未经花括号修饰的表达式可以被隐式的打包成闭包并作为参数传递给函数。比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">assert</span><span class="p">(</span><span class="n">predicate</span> <span class="o">:</span> <span class="err">@</span><span class="n">autoclosure</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="err">#</span><span class="k">if</span> <span class="o">!</span><span class="n">NDEBUG</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">!</span><span class="n">predicate</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">abort</span><span class="p">()</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
这让你更自然的调用断言：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">assert</span><span class="p">(</span><span class="n">someExpensiveComputation</span><span class="p">()</span> <span class="o">!=</span> <span class="mi">42</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
自动闭包是一个强大的特性，因为你可以有条件地计算表达式，多次计算并像使用闭包那样来使用打包的表达式。自动闭包也可以在Swift的其他地方使用。比如，实现简化逻辑运算符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="o">&amp;&amp;</span><span class="p">(</span><span class="nl">lhs:</span> <span class="n">BooleanType</span><span class="p">,</span> <span class="nl">rhs:</span> <span class="err">@</span><span class="n">autoclosure</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">BooleanType</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Bool</span> <span class="p">{</span>
</span><span class='line'>  <span class="k">return</span> <span class="n">lhs</span><span class="p">.</span><span class="n">boolValue</span> <span class="o">?</span> <span class="n">rhs</span><span class="p">().</span><span class="n">boolValue</span> <span class="o">:</span> <span class="n">false</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
通过将右边表达式以闭包形式接收，Swift提供合适的子表达式的惰性计算。</p>

<h2>自动闭包</h2>

<p>作为C语言的宏，自动闭包要谨慎使用。因为从调用函数的一方看不出来参数的计算受到了影响。自动闭包有意地限制我们不传递参数，所以你不能在类似条件控制流的情形中使用它。在符合人们期望的实用语义情况（可能是“features”API）下使用它，而不是单单为了省略闭包的花括号。</p>

<p>本文涵盖了实现Swift断言的一个特别的部分，但接下来还会有更多带给大家。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Swift中构建assert(), 第二部分: __FILE__ 和 __LINE__]]></title>
    <link href="http://yulingtianxia.com/blog/2014/09/26/building-assert-in-swift-2/"/>
    <updated>2014-09-26T16:23:21+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/09/26/building-assert-in-swift-2</id>
    <content type="html"><![CDATA[<p>本文翻译自<a href="https://developer.apple.com/swift/blog/?id=15">Building assert() in Swift, Part 2: __FILE__ and __LINE__</a></p>

<!--more-->


<p><code>__FILE__</code> 和 <code>__LINE__</code>这两个神奇的宏定义是C语言中偶尔有用的特性。他们被构建在预处理程序中，并在C语言语法分析程序运行前被展开。尽管Swift没有预处理程序，它却提供了名称相似的类似功能，但隐藏着极其不同的实现方式。</p>

<h2>内建标识符</h2>

<p>就像在<a href="https://developer.apple.com/library/ios/documentation/swift/conceptual/swift_programming_language/LexicalStructure.html">the Swift programming guide</a>中描述的那样，Swift有很多内建标识符，包括<code>__FILE__</code>, <code>__LINE__</code>, <code>__COLUMN__</code>, 和 <code>__FUNCTION__</code>。这些表达式可以在任何地方使用，并被语法分析器在源码对应的当前位置展开成字符串或整数字面量。这对手动日志非常管用，比如在退出前打印出当前位置。</p>

<p>然而这并不能帮助我们探索实现<code>assert()</code>。如果我们这样实现断言(assert)：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">assert</span><span class="p">(</span><span class="n">predicate</span> <span class="o">:</span> <span class="err">@</span><span class="n">autoclosure</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="err">#</span><span class="k">if</span> <span class="n">DEBUG</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">!</span><span class="n">predicate</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>          <span class="n">println</span><span class="p">(</span><span class="s">&quot;assertion failed at \(__FILE__):\(__LINE__)&quot;</span><span class="p">)</span>
</span><span class='line'>          <span class="n">abort</span><span class="p">()</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>  <span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
上面的代码将会输出实现<code>assert()</code>方法所在文件的文件/行数(file/line)位置，而不是调用者的位置信息。这并不管用。</p>

<h2>获取调用者位置</h2>

<p>Swift从D语言借鉴了一个非常聪明的特性：当标识符在默认参数列表中被赋值时，它们会在调用者的位置被展开。为了实现这个行为，<code>assert()</code>被如下这样定义：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">assert</span><span class="p">(</span><span class="nl">condition:</span> <span class="err">@</span><span class="n">autoclosure</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span><span class="p">,</span> <span class="n">_</span> <span class="nl">message:</span> <span class="n">String</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nl">file:</span> <span class="n">String</span> <span class="o">=</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="nl">line:</span> <span class="n">Int</span> <span class="o">=</span> <span class="n">__LINE__</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="err">#</span><span class="k">if</span> <span class="n">DEBUG</span>
</span><span class='line'>          <span class="k">if</span> <span class="o">!</span><span class="n">condition</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>              <span class="n">println</span><span class="p">(</span><span class="s">&quot;assertion failed at \(file):\(line): \(message)&quot;</span><span class="p">)</span>
</span><span class='line'>              <span class="n">abort</span><span class="p">()</span>
</span><span class='line'>          <span class="p">}</span>
</span><span class='line'>      <span class="err">#</span><span class="n">endif</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
Swift的<code>assert()</code>函数第二个参数是一个供你指明的可选字符串，而第三、四个参数默认为调用者上下文的位置。这就让<code>assert()</code>能默认获得调用者的原始位置。如果你想在断言顶层构建你自己的抽象层，你可以将调用者的位置传递下去。作为一个简易的例子，你可以定义一个日志和断言方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">func</span> <span class="nf">logAndAssert</span><span class="p">(</span><span class="nl">condition:</span> <span class="err">@</span><span class="n">autoclosure</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="n">Bool</span><span class="p">,</span> <span class="n">_</span> <span class="nl">message:</span> <span class="n">StaticString</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">,</span>
</span><span class='line'>  <span class="nl">file:</span> <span class="n">StaticString</span> <span class="o">=</span> <span class="n">__FILE__</span><span class="p">,</span> <span class="nl">line:</span> <span class="n">UWord</span> <span class="o">=</span> <span class="n">__LINE__</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>  <span class="n">logMessage</span><span class="p">(</span><span class="n">message</span><span class="p">)</span>
</span><span class='line'>  <span class="n">assert</span><span class="p">(</span><span class="n">condition</span><span class="p">,</span> <span class="n">message</span><span class="p">,</span> <span class="nl">file:</span> <span class="n">file</span><span class="p">,</span> <span class="nl">line:</span> <span class="n">line</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
这正确的将<code>logAndAssert()</code>调用者的file/line位置传递给了<code>assert()</code>的实现。注意上面代码中的<code>StaticString</code>，它是一个类似于<code>String</code>的类型，用于存储像<code>__FILE__</code>这种不受内存管理约束的字符串字面量。</p>

<p>除此之外，这种实用设计也用于Swift中实现高级XCTest框架，也可以在你自己实现的函数库中发挥作用。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在Mac上用WiFi共享校园网]]></title>
    <link href="http://yulingtianxia.com/blog/2014/09/07/zai-macshang-yong-wifigong-xiang-xiao-yuan-wang/"/>
    <updated>2014-09-07T18:00:14+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/09/07/zai-macshang-yong-wifigong-xiang-xiao-yuan-wang</id>
    <content type="html"><![CDATA[<p>开学了，好多稚嫩的学弟学妹踏入了憧憬许久的校园，住上了宽敞明亮的寝室（某工除外），用上了速度超快的校园网。然而这里却有一个严峻的问题摆在了Mac用户面前：蛋疼的锐捷！这篇文章将会详细的教学弟学妹们如何科学地通过WiFi共享校园网。</p>

<!--more-->


<p>记得在我刚上大学那年，锐捷的Mac客户端简直是不忍直视，非程序员无法hold住，即使现在Mac版本的锐捷客户端也是经常连接不上，界面不够友好，检测网卡速度慢等一系列反人类问题。网上也有一些第三方的校园网客户端，我认为最好的就是<a href="https://code.google.com/p/mentohust/downloads/detail?name=CocoaMento.dmg&amp;">CocoaMento</a>。下载后最好在程序图标处右击，选择显示包内容，用Windows版锐捷客户端的内容替换<code>/Contents/Resources/data/</code>目录下的对应文件:</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20140907-1%402x.png" alt="" /></p>

<p>你可以将你们学校提供的定制版锐捷客户端32位安装包（标注x86的exe文件）解压（exe文件和dmg等一样，都是类似于rar之类的压缩文件），然后在解压后的文件中找到需要替换的那三个文件：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20140907-2%402x.png" alt="" /></p>

<p>PS：因为CocoaMento是用Qt写的，且为32位，千万不要把64位安装包中对应的文件替换到上述目录中，否则会认证失败无法上网。</p>

<p>其实不用替换这三个文件也能上网，但是替换下更好，因为随着锐捷版本的更新，认证机制也会变化。这三个文件可以让我们的Mac伪装成Windows，骗过锐捷认证。</p>

<p>打开CocoaMento，它并不在Dock上占有一席之地，而是跑到了顶端的菜单栏，图标是一个蓝色的地球，如果认证失败它会变成红色。点击这个地球，在偏好设置中的账号设置中填写好你的账户密码，最后点击开始验证：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20140907-3%402x.png" alt="" /></p>

<p>在上图中，使用网卡那项的选择需要查看以太网卡的BSD名称(左上角->关于本机->更多信息->系统报告->硬件->以太网卡)，直到认证成功后勾选再上自动登录。</p>

<p>在Mac上将以太网通过WiFi共享给其他设备很简单，只需要打开 <strong>系统偏好设置->共享</strong>，点击“互联网共享”，在“共享以下来源的连接”那栏选择“XXX以太网”（有可能是Thunderbolt以太网或USB以太网），在“用以下端口共享给电脑” 复选框中勾选“WiFi”，并点击“WiFi选项”，设置好WiFi名称和密码，最后别忘勾选上左侧的“互联网共享”。此时如果WiFi没有打开，会提示先打开WiFi，然后会提示是否开启共享，选择开启即可：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20140907-4%402x.png" alt="" /></p>

<p>然而锐捷最蛋疼之处还是其通过802.1x协议限制了我们共享无线网络：一旦WiFi开启，官方的锐捷客户端就会警告存在其他网卡balabala然后给你断网。。。我在MacOSX 10.9中即使用CocoaMento依然无法将校园网通过WiFi共享（有的时候重启下还是可以的，但那只是因为bug导致的巧合）</p>

<p>如果我们开启了VPN，则可以在共享WiFi的时候在“共享以下来源的连接”那栏选择你的VPN连接，这样不仅可以越过锐捷的网卡限制，还能让共享的WiFi通过VPN连接到互联网，探索神秘的西方极乐世界。</p>

<p>然而一直使用VPN共享WiFi会在速度上大打折扣，而且也不经济划算，为了逃过802.1x协议的限制，我发现在 <strong>系统偏好设置->网络->高级->802.1x</strong> 选项卡中如果将“启用自动连接”取消勾选，就可以逃过802.1x验证：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20140907-5%402x.png" alt="" /></p>

<p>经过亲测屡试不爽啊，成功的看到了那个扇形箭头标志：<img src="http://yulingtianxia.qiniudn.com/QQ20140907-6%402x.png" alt="" />，这证明了WiFi共享成功。</p>

<p>为了能快速的连接上校园网并用WiFi分享，请始终勾选“互联网共享”，因为即使WiFi分享不成功，也不会耽误我们使用WiFi来连接到其他网络。然后在 <strong>系统偏好设置->用户与群组->(你的账户)&ndash;>登陆项</strong> 选项卡下将CocoaMento添加进去，这样开机的时候就会自动启动CocoaMento连接上校园网，并将其通过WiFi分享，一气呵成 : )</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20140907-7%402x.png" alt="" /></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[创建SpriteKit游戏的最佳范例]]></title>
    <link href="http://yulingtianxia.com/blog/2014/08/19/best-practices-for-building-spritekit-games/"/>
    <updated>2014-08-19T22:16:13+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/08/19/best-practices-for-building-spritekit-games</id>
    <content type="html"><![CDATA[<p>本文会从拓展性、游戏构造和性能三个方面分别讲述建立SpriteKit游戏时的一些实践经验和范例。建议先阅读<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>有助于理解本文内容。</p>

<!--more-->


<h2>拓展性最佳范例</h2>

<h3>硬编码问题</h3>

<p>在以前，程序员在场景中做了所有的事情，在代码中引用美工，游戏第一关采用硬编码，第二关第三关就是一顿复制粘贴修修补补。修改美工图片也意味着要改代码，每次预览修改后的效果都要Build和Run，而设计游戏的人甚至要会编程，因为修改设计（比如一些游戏参数）也要改代码。如果项目接着编写下去，这导致重复性的构建代码，将数据硬编码到代码中也是种低效率做法，编码与美工和设计人员之间合作困难。</p>

<p>解决方案：</p>

<ul>
<li>将游戏内容与游戏逻辑分离</li>
<li>将场景构造与素材分离</li>
<li>将数据与代码分离</li>
<li>在Xcode中所见即所得</li>
</ul>


<p>具体实现：</p>

<ul>
<li>游戏逻辑写在MyScene.m文件中（使用SpriteKit的模板）</li>
<li>游戏场景结构创建在MyScene.sks文件中</li>
<li>场景用到的素材使用单独的sks文件分开管理</li>
<li>数据要存储在plist文件中（XML格式）</li>
</ul>


<p>Xcode6为我们提供的工具：</p>

<ul>
<li>SpriteKit模版，支持OC和Swift</li>
<li>SpriteKit编辑器：可视化编辑sks文件，即时预览效果，实时物理模拟</li>
<li>plist数据编辑器：XML语言被可视化成字典来编辑，简单高效</li>
</ul>


<p>在MyScene.m文件中使用下面的模板来加载MyScene.sks中设计好的场景结构，然后你就可以接着写游戏的逻辑了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">NSBundle</span><span class="p">.</span><span class="nx">mainBundle</span><span class="p">().</span><span class="nx">pathForResource</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="nx">ofType</span><span class="o">:</span> <span class="s2">&quot;sks&quot;</span><span class="p">)</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">sceneData</span> <span class="o">=</span> <span class="nx">NSData</span><span class="p">.</span><span class="nx">dataWithContentsOfFile</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">options</span><span class="o">:</span> <span class="p">.</span><span class="nx">DataReadingMappedIfSafe</span><span class="p">,</span> <span class="nx">error</span><span class="o">:</span> <span class="nx">nil</span><span class="p">)</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">archiver</span> <span class="o">=</span> <span class="nx">NSKeyedUnarchiver</span><span class="p">(</span><span class="nx">forReadingWithData</span><span class="o">:</span> <span class="nx">sceneData</span><span class="p">)</span>
</span><span class='line'><span class="nx">archiver</span><span class="p">.</span><span class="nx">setClass</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">classForKeyedUnarchiver</span><span class="p">(),</span> <span class="nx">forClassName</span><span class="o">:</span> <span class="s2">&quot;SKScene&quot;</span><span class="p">)</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">scene</span> <span class="o">=</span> <span class="nx">archiver</span><span class="p">.</span><span class="nx">decodeObjectForKey</span><span class="p">(</span><span class="nx">NSKeyedArchiveRootObjectKey</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">GameScene</span>
</span><span class='line'><span class="nx">archiver</span><span class="p">.</span><span class="nx">finishDecoding</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>游戏构造最佳范例</h2>

<p>程序员总是想让游戏尽可能早地跑起来。为了完成这个目标，我们要懂得与美工和设计合作，毕竟程序员不能独自完成所有事情，下面列举下快速达成目标的步骤：</p>

<ol>
<li>先把一般性的工作做完，这只是逻辑布局上的编程，不必等美工提供素材。标记好英雄、敌人等人物出现的位置，设计好背景、平台等。</li>
<li>用只有颜色没有贴图的<code>SKSpriteNode</code>来充当英雄和敌人，只要能区分开就好。现在可以设定父子层级关系，比如设定粒子发射位置，连接组件和关节（胳膊腿儿啥的）</li>
<li>设定物理层面的相互作用，比如各种物理体的类别，碰撞掩码，是否受物理世界的影响等。在Xcode中模拟物理场景，保证你做的这些从一开始就万无一失。</li>
<li>初始化场景逻辑和游戏逻辑，把之前在场景上布置好的物体与代码中的游戏中的物体用之前设定好的名字（英雄or敌人）联系起来。使用SpriteKit模板加载好游戏场景后，<code>SKScene</code>的<code>initWithCoder</code>会被调用，我们可以在这里加载声音和AI数据等不会变化的数据。当<code>SKView.presentScene:</code>被调用时，<code>SKScene</code>的<code>didMoveToView:</code>会被调用，在这里你要缓存可见的元素，比如敌人，你可以通过名字将它们从场景的子节点中遍历出来。</li>
<li>完成游戏：将美工给你的素材替代以前的纯色，增加关卡和效果（Shader，滤镜等），迭代测试。</li>
</ol>


<p>PS：两种搜索节点元素的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="err">–</span> <span class="nx">childNodeWithName</span><span class="o">:</span>
</span><span class='line'><span class="err">–</span> <span class="nx">enumerateChildNodesWithName</span><span class="o">:</span><span class="nx">usingBlock</span><span class="o">:</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<blockquote><p>关于搜索文本的语法补充：<br/>
通过name查找：</p>

<ul>
<li>“hero”是查找叫做“hero”的子节点，不迭代</li>
<li>“//hero”是查找场景图中所有叫做“hero”的子节点，迭代</li>
</ul>


<p>通过class查找：</p>

<ul>
<li>“//SKEmitterNode”会在场景图中迭代查找所有粒子节点</li>
</ul>


<p>通过通配符查找：</p>

<ul>
<li>“//he*”查找所有以“he”开头的子节点</li>
</ul>
</blockquote>

<h2>性能最佳范例</h2>

<p>我们要尽可能维持游戏每秒60帧频率的刷新，就需要从性能上优化。</p>

<h3>Drawing performance</h3>

<p>影响绘图性能的两个主要因素：</p>

<ul>
<li>绘制顺序：默认的绘制顺序是按照代码中构造节点树的顺序绘制的，先绘制父节点，然后依次绘制子节点，并向下迭代。你可以将<code>SKView</code>的<code>ignoresSiblingOrder</code>属性设为YES，然后利用Z轴的层级深浅关系来定制绘制次序。</li>
<li>共享：使用纹理图集（texture atlases），共享法线贴图，从文件加载Shader而不是字符串，将混合模式放在Z轴同一层级。</li>
</ul>


<p>下面的工具能帮你评估图形性能：</p>

<p><code>SKView</code>上的HUD flags：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">showsFPS</span>
</span><span class='line'><span class="nx">showsDrawCount</span>
</span><span class='line'><span class="nx">showsNodeCount</span>
</span><span class='line'><span class="nx">showsQuadCount</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>profile：检测硬件使用情况。</p>

<h3>Actions and constraints</h3>

<p>使用<code>SKAction</code>类实现SpriteKit中的动画是很高效的。用一行代码就能实现诸如平移、旋转、缩放、渐入渐出等动画效果。你可以将多个动画组成一个序列（sequence）来依次执行，也可组成一个group来同时执行，sequence和group之间也可以互相嵌套。<code>SKAction</code>有很多方法，可以查看它的API文档。</p>

<p>如果你给Action使用Key命名的话，你还可以通过Key来动态删除和重写这个Action。</p>

<p><code>SKConstraints</code>类能在节点与节点或固定点之间建立约束。详见我的另一篇文章<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>中New Physics->Constraints小节。</p>

<h3>Physics</h3>

<p>模拟物理世界需要很多的硬件计算，当务之急就是减少能耗。</p>

<p>静态物体耗能较小，即使他们外形复杂。所以尽可能的将物理体的<code>dynamic</code>属性设为NO</p>

<p>物理体的外形复杂程度也决定着能耗。圆形是最简单的，耗能最少，再往上依次是矩形、多边形、复合图形、alpha像素图形：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140844930564.png" alt="" /></p>

<p>所以你需要权衡利弊来设计你游戏中物理体的外形。上图的后两种外形是iOS8新加入的，你可以在<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>中的New Physics->Per-Pixel Physics和Improvements->Physics Updates这两个小节中学到有关它们的更多知识。</p>

<p>在设置碰撞掩码（mask）时，尽量将相同类别的物体归为一类，用尽可能少得类别来划分你游戏中的物体。这样能减少很多能耗。</p>

<p>尽可能使用iOS8新加入的<code>SKFieldNode</code>来模拟一些物理场景，而不是通过传统代码方式（自己向各种物体施加各种力）。有关<code>SKFieldNode</code>的知识可以查看<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>中New Physics->Physics Fields那节。</p>

<p>将<code>SKView</code>的<code>showsFields</code>属性设为YES可以将<code>SKFieldNode</code>的debug信息显示出来：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140845151467.png" alt="" />
<img src="http://yulingtianxia.qiniudn.com/140845150994.png" alt="" /></p>

<p>上面两个场景是我的一个SpriteKit游戏<a href="http://coloratom.yulingtianxia.com">ColorAtom</a>中的秘密模式和黑洞模式截图，欢迎Star和Follow。</p>

<h3>Shapes</h3>

<p><code>SKShapeNode</code>的耗能层级图如下：</p>

<p><img src="http://yulingtianxia.qiniudn.com/14084531435.png" alt="" /></p>

<p>上图中的分界线区分了低功耗和高功耗的Shape。绘制分段的linear strok所需的功耗也很少。</p>

<h3>Effects</h3>

<p><code>SKEffectNode</code>可以将它的子节点渲染的更加出彩，比如用CoreImage滤镜等合成出复杂的特效。但这也会对性能有很大影响，请谨慎使用。</p>

<p>Shader是一个不错的选择，它不需要离屏渲染，想用就用，节能环保。有关<code>SKShader</code>的知识可以查看<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>中Shader那节。</p>

<p><code>shouldRasterize</code>属性暗示是否缓存以备将来之需。如果你的画面会停留一段时间，可以考虑设置为YES。</p>

<p>我们还可以从<code>SKNode</code>中获取纹理（这不费吹灰之力），还可以对纹理进行滤镜加工：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">SKTexture</span> <span class="o">*</span><span class="nx">texture</span> <span class="o">=</span> <span class="p">[</span><span class="nx">myView</span> <span class="nx">textureFromNode</span><span class="o">:</span><span class="nx">node</span> <span class="nx">size</span><span class="o">:</span><span class="nx">size</span><span class="p">];</span>
</span><span class='line'><span class="nx">SKTexture</span> <span class="o">*</span><span class="nx">texture</span> <span class="o">=</span> <span class="p">[</span><span class="nx">myTexture</span> <span class="nx">textureByApplyingCIFiler</span><span class="o">:</span><span class="nx">filer</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>Lighting</h3>

<p>光照的功耗是跟像素数量成比例的，每个<code>SKSpriteNode</code>最多能被八个光源照射，你可以利用光照掩码来优化性能。</p>

<p>环境光照（ambient light）所需功耗是免费的，而法线贴图（Normal Maps）功耗很低。</p>

<p>阴影的功耗跟光源数量成正比，所以尽可能减少光源数量。</p>

<p>有关Lighting的更多知识可以查看<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>中Lighting and Shadows那节。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS8自动调整UITableView和UICollectionView布局]]></title>
    <link href="http://yulingtianxia.com/blog/2014/08/17/New-in-Table-and-Collection-Views/"/>
    <updated>2014-08-17T16:57:42+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/08/17/New-in-Table-and-Collection-Views</id>
    <content type="html"><![CDATA[<p>本文讲述了<code>UITableView</code>、<code>UICollectionView</code>实现self-sizing cell布局的知识，以及如何用InvalidationContext优化<code>UICollectionView</code>布局的更新。</p>

<!--more-->


<h2>背景</h2>

<p>iOS越来越人性化了，用户可以在设置-通用-辅助功能中动态调整字体大小了。你会发现所有iOS自带的APP的字体大小都变了，可惜我们开发的第三方APP依然是以前的字体。在iOS7之后我们可以用<code>UIFont</code>的<code>preferredFontForTextStyle:</code>类方法来指定一个样式，并让字体大小符合用户设定的字体大小。目前可供选择的有六种样式：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">UIFontTextStyleHeadline</span>
</span><span class='line'><span class="nx">UIFontTextStyleBody</span>
</span><span class='line'><span class="nx">UIFontTextStyleSubheadline</span>
</span><span class='line'><span class="nx">UIFontTextStyleFootnote</span>
</span><span class='line'><span class="nx">UIFontTextStyleCaption1</span>
</span><span class='line'><span class="nx">UIFontTextStyleCaption2</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>iOS会根据样式的用途来合理调整字体。</p>

<p>问题来了，诸如字体大小这种“动态类型”，我们需要对其进行动态的UI调整，否则总是觉得我们的界面怪怪的：</p>

<p><img src="http://yulingtianxia.qiniudn.com/image-DCBF_53F0DDDB.jpg" alt="" /></p>

<p>我们想要让Cell的高度随着字体大小而作出调整：</p>

<p><img src="http://yulingtianxia.qiniudn.com/image-0D8C_53F0DDDB.jpg" alt="" /></p>

<p>总之，还会有其他动态因素导致我们需要修改布局。</p>

<h2>解决方案</h2>

<h3>UITableView</h3>

<p>有三种策略可以调节Cell（或者是Header和Footer）的高度：</p>

<ul>
<li>调节Height属性</li>
<li>通过委托方法<code>tableView: heightForRowAtIndexPath:</code></li>
<li>Cell的“自排列”（self-sizing）</li>
</ul>


<p>前两种策略都是我们所熟悉的，后面将介绍第三种策略。<code>UITableViewCell</code>和<code>UICollectionViewCell</code>都支持self-sizing</p>

<p>在iOS7中，<code>UITableViewDelegate</code>新增了三个方法来满足用户设定Cell、Header和Footer预计高度的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="o">-</span> <span class="nx">tableView</span><span class="o">:</span><span class="nx">estimatedHeightForRowAtIndexPath</span><span class="o">:</span>
</span><span class='line'><span class="o">-</span> <span class="nx">tableView</span><span class="o">:</span><span class="nx">estimatedHeightForHeaderInSection</span><span class="o">:</span>
</span><span class='line'><span class="o">-</span> <span class="nx">tableView</span><span class="o">:</span><span class="nx">estimatedHeightForFooterInSection</span><span class="o">:</span>
</span></code></pre></td></tr></table></div></figure>


<p>
当然对应这三个方法<code>UITableView</code>也<code>estimatedRowHeight</code>、<code>estimatedSectionHeaderHeight</code>和<code>estimatedSectionFooterHeight</code>三个属性，局限性在于只能统一定义所有行和节的高度。</p>

<p>以Cell为例，iOS会根据给出的预计高度来创建一个Cell，但等到真正要显示它的时候，iOS8会在self-sizing计算得出新的Size并调整table的<code>contentSize</code>后，将Cell绘制显示出来。关键在于如何得出Cell新的Size，iOS提供了两种方法：</p>

<ul>
<li>自动布局
  这个两年前推出的神器虽然在一开始表现不佳，但随着Xcode的越来越给力，在iOS7中自动布局俨然成了默认勾选的选项，通过设定一系列约束来使得我们的UI能够适应各种尺寸的屏幕。如果你有使用约束的经验，想必已经有了解决思路：向Cell的<code>contentView</code>添加约束。iOS会先调用<code>UIView</code>的<code>systemLayoutSizeFittingSize:</code>方法来根据约束计算新的Size，如果你没实现约束，<code>systemLayoutSizeFittingSize:</code>会接着调用<code>sizeThatFits:</code>方法。</li>
<li>人工代码
  我们可以重写<code>sizeThatFits:</code>方法来自己定义新的Size，这样我们就不必学习约束相关的知识了。</li>
</ul>


<p>下面我给出了一个用Swift语言写的Demo-<a href="http://hardchoice.yulingtianxia.com">HardChoice</a>，使用自动布局来调整<code>UITableViewCell</code>的高度。我通过实现一个<code>UITableViewCell</code>的子类<code>DynamicCell</code>来实现自动布局，你可以再GitHub上下载<a href="https://github.com/yulingtianxia/HardChoice">源码</a>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">import</span> <span class="nx">UIKit</span>
</span><span class='line'>
</span><span class='line'><span class="kr">class</span> <span class="nx">DynamicCell</span><span class="o">:</span> <span class="nx">UITableViewCell</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">required</span> <span class="nx">init</span><span class="p">(</span><span class="nx">coder</span><span class="o">:</span> <span class="nx">NSCoder</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kr">super</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">coder</span><span class="o">:</span> <span class="nx">coder</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">textLabel</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">textLabel</span><span class="p">.</span><span class="nx">font</span> <span class="o">=</span> <span class="nx">UIFont</span><span class="p">.</span><span class="nx">preferredFontForTextStyle</span><span class="p">(</span><span class="nx">UIFontTextStyleHeadline</span><span class="p">)</span>
</span><span class='line'>            <span class="nx">textLabel</span><span class="p">.</span><span class="nx">numberOfLines</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">detailTextLabel</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">detailTextLabel</span><span class="p">.</span><span class="nx">font</span> <span class="o">=</span> <span class="nx">UIFont</span><span class="p">.</span><span class="nx">preferredFontForTextStyle</span><span class="p">(</span><span class="nx">UIFontTextStyleBody</span><span class="p">)</span>
</span><span class='line'>            <span class="nx">detailTextLabel</span><span class="p">.</span><span class="nx">numberOfLines</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">override</span> <span class="nx">func</span> <span class="nx">constraints</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nx">AnyObject</span><span class="p">]</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="nx">AnyObject</span><span class="p">]()</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">textLabel</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">constraints</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">constraintsForView</span><span class="p">(</span><span class="nx">textLabel</span><span class="p">))</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">detailTextLabel</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">constraints</span><span class="p">.</span><span class="nx">extend</span><span class="p">(</span><span class="nx">constraintsForView</span><span class="p">(</span><span class="nx">detailTextLabel</span><span class="p">))</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="nx">constraints</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">NSLayoutConstraint</span><span class="p">(</span><span class="nx">item</span><span class="o">:</span> <span class="nx">contentView</span><span class="p">,</span> <span class="nx">attribute</span><span class="o">:</span> <span class="nx">NSLayoutAttribute</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="nx">relatedBy</span><span class="o">:</span> <span class="nx">NSLayoutRelation</span><span class="p">.</span><span class="nx">GreaterThanOrEqual</span><span class="p">,</span> <span class="nx">toItem</span><span class="o">:</span> <span class="nx">contentView</span><span class="p">,</span> <span class="nx">attribute</span><span class="o">:</span> <span class="nx">NSLayoutAttribute</span><span class="p">.</span><span class="nx">Height</span><span class="p">,</span> <span class="nx">multiplier</span><span class="o">:</span> <span class="mi">0</span><span class="p">,</span> <span class="nx">constant</span><span class="o">:</span> <span class="mi">44</span><span class="p">))</span>
</span><span class='line'>        <span class="nx">contentView</span><span class="p">.</span><span class="nx">addConstraints</span><span class="p">(</span><span class="nx">constraints</span><span class="p">)</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">constraints</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">constraintsForView</span><span class="p">(</span><span class="nx">view</span><span class="o">:</span><span class="nx">UIView</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="p">[</span><span class="nx">AnyObject</span><span class="p">]{</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">constraints</span> <span class="o">=</span> <span class="p">[</span><span class="nx">NSLayoutConstraint</span><span class="p">]()</span>
</span><span class='line'>        <span class="nx">constraints</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">NSLayoutConstraint</span><span class="p">(</span><span class="nx">item</span><span class="o">:</span> <span class="nx">view</span><span class="p">,</span> <span class="nx">attribute</span><span class="o">:</span> <span class="nx">NSLayoutAttribute</span><span class="p">.</span><span class="nx">FirstBaseline</span><span class="p">,</span> <span class="nx">relatedBy</span><span class="o">:</span> <span class="nx">NSLayoutRelation</span><span class="p">.</span><span class="nx">Equal</span><span class="p">,</span> <span class="nx">toItem</span><span class="o">:</span> <span class="nx">contentView</span><span class="p">,</span> <span class="nx">attribute</span><span class="o">:</span> <span class="nx">NSLayoutAttribute</span><span class="p">.</span><span class="nx">Top</span><span class="p">,</span> <span class="nx">multiplier</span><span class="o">:</span> <span class="mf">1.8</span><span class="p">,</span> <span class="nx">constant</span><span class="o">:</span> <span class="mf">30.0</span><span class="p">))</span>
</span><span class='line'>        <span class="nx">constraints</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">NSLayoutConstraint</span><span class="p">(</span><span class="nx">item</span><span class="o">:</span> <span class="nx">contentView</span><span class="p">,</span> <span class="nx">attribute</span><span class="o">:</span> <span class="nx">NSLayoutAttribute</span><span class="p">.</span><span class="nx">Bottom</span><span class="p">,</span> <span class="nx">relatedBy</span><span class="o">:</span> <span class="nx">NSLayoutRelation</span><span class="p">.</span><span class="nx">GreaterThanOrEqual</span><span class="p">,</span> <span class="nx">toItem</span><span class="o">:</span> <span class="nx">view</span><span class="p">,</span> <span class="nx">attribute</span><span class="o">:</span> <span class="nx">NSLayoutAttribute</span><span class="p">.</span><span class="nx">Baseline</span><span class="p">,</span> <span class="nx">multiplier</span><span class="o">:</span> <span class="mf">1.3</span><span class="p">,</span> <span class="nx">constant</span><span class="o">:</span> <span class="mi">8</span><span class="p">))</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">constraints</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>上面的代码需要注意的是，Objective-C中的类在Swift中都可以被当做<code>AnyObject</code>，这在类型兼容问题上很管用。</p>

<p>别忘了在相应的UITableViewController中的viewDidLoad方法中加上：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">self</span><span class="p">.</span><span class="nx">tableView</span><span class="p">.</span><span class="nx">estimatedRowHeight</span> <span class="o">=</span> <span class="mi">44</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>自适应效果如下：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140833033058.gif" alt="" /></p>

<h3>UICollectionView</h3>

<p><code>UITableView</code> 和 <code>UICollectionView</code> 都是 data-source 和 delegate 驱动的。<code>UICollectionView</code>在此之上进行了进一步抽象。它将其子视图的位置，大小和外观的控制权委托给一个单独的布局对象。通过提供一个自定义布局对象，你几乎可以实现任何你能想象到的布局。布局继承自 <code>UICollectionViewLayout</code> 抽象基类。iOS6 中以 <code>UICollectionViewFlowLayout</code> 类的形式提出了一个具体的布局实现。在<code>UICollectionViewFlowLayout</code>中，self-sizing同样适用：</p>

<p><img src="http://yulingtianxia.qiniudn.com/image-05D4_53F0E00F.jpg" alt="" /></p>

<p>采用self-sizing后：</p>

<p><img src="http://yulingtianxia.qiniudn.com/image-B1E8_53F0DDDB.jpg" alt="" /></p>

<p><code>UICollectionView</code>实现self-sizing不仅可以通过在Cell的<code>contentView</code>上加约束和重写<code>sizeThatFits:</code>方法，也能在Cell层面（以前都是在<code>contentSize</code>上进行self-sizing）上做文章：重写<code>UICollectionReusableView</code>的<code>preferredLayoutAttributesFittingAttributes:</code>方法来在self-sizing计算出Size之后再修改，这样就达到了对Cell布局属性（<code>UICollectionViewLayoutAttributes</code>）的全面控制。</p>

<p>PS：<code>preferredLayoutAttributesFittingAttributes:</code>方法默认调整Size属性来适应self-sizing Cell，所以重写的时候需要先调用父类方法，再在返回的<code>UICollectionViewLayoutAttributes</code>对象上做你想要做的修改。</p>

<p>由此我们从最经典的<code>UICollectionViewLayout</code>强制计算属性（还记得<code>UICollectionViewLayoutAttributes</code>的一系列工厂方法么？）到使用self-sizing来根据我们需求调整属性中的Size，再到重写<code>UICollectionReusableView</code>（<code>UICollectionViewCell</code>也是继承于它）的<code>preferredLayoutAttributesFittingAttributes:</code>方法来从Cell层面对所有属性进行修改：</p>

<p><img src="http://yulingtianxia.qiniudn.com/image-95BA_53F0DDDB.jpg" alt="" /></p>

<p>下面来说说如何在<code>UICollectionViewFlowLayout</code>实现self-sizing：</p>

<p>首先，<code>UICollectionViewFlowLayout</code>增加了<code>estimatedItemSize</code>属性，这与<code>UITableView</code>中的&#8221;<code>estimated...Height</code>&ldquo;很像（注意我用省略号囊括那三种属性），但毕竟<code>UICollectionView</code>中的Item都需要约束Height和Width的，所以它是个<code>CGSIze</code>，除了这点它与<code>UITableView</code>中的&rdquo;<code>estimated...Height</code>&ldquo;用法没区别。</p>

<p>其次。。。没有其次，在<code>UICollectionView</code>中实现self-sizing，只需给<code>estimatedItemSize</code>属性赋值（不能是<code>CGSizeZero</code>），一行代码足矣。</p>

<h3>InvalidationContext</h3>

<p>假如设备屏幕旋转，或者需要展示一些其妙的效果（比如CoverFlow），我们需要将当前的布局失效，并重新计算布局。当然每次计算都有一定的开销，所以我们应该谨慎的仅在我们需要的时候调用<code>invalidateLayout</code>方法来让布局失效。</p>

<p>在iOS6时代，有的人会“聪明地”这样做：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="o">-</span> <span class="p">(</span><span class="nx">BOOL</span><span class="p">)</span><span class="nx">shouldInvalidateLayoutForBoundsChange</span><span class="o">:</span><span class="p">(</span><span class="nx">CGRect</span><span class="p">)</span><span class="nx">newBounds</span>
</span><span class='line'><span class="p">{</span>
</span><span class='line'>    <span class="nx">CGRect</span> <span class="nx">oldBounds</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">collectionView</span><span class="p">.</span><span class="nx">bounds</span><span class="p">;</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="nx">CGRectGetWidth</span><span class="p">(</span><span class="nx">newBounds</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">CGRectGetWidth</span><span class="p">(</span><span class="nx">oldBounds</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">NO</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>而iOS7新加入的<code>UICollectionViewLayoutInvalidationContext</code>类声明了在布局失效时布局的哪些部分需要被更新。当数据源变更时，<code>invalidateEverything</code>和<code>invalidateDataSourceCounts</code>这两个只读Bool属性标记了<code>UICollectionView</code>数据源“全部过期失效”和“Section和Item数量失效”，<code>UICollectionView</code>会将它们自动设定并提供给你。</p>

<p>你可以调用<code>invalidateLayoutWithContext:</code>方法并传入一个<code>UICollectionViewLayoutInvalidationContext</code>对象，这能优化布局的更新效率。</p>

<p>当你自定义一个<code>UICollectionViewLayout</code>子类时，你可以调用<code>invalidationContextClass</code>方法来返回一个你定义的<code>UICollectionViewLayoutInvalidationContext</code>的子类，这样你的Layout子类在失效时会使用你自定义的InvalidationContext子类来优化更新布局。</p>

<p>你还可以重写<code>invalidationContextForBoundsChange:</code>方法，在实现自定义Layout时通过重写这个方法返回一个InvalidationContext对象。</p>

<p>综上所述都是iOS7中新加入的内容，并且还可以应用在<code>UICollectionViewFlowLayout</code>中。在iOS8中，<code>UICollectionViewLayoutInvalidationContext</code>也被用在self-sizing cell上。</p>

<p>iOS8中<code>UICollectionViewLayoutInvalidationContext</code>新加入了三个方法使得我们可以更加细致精密地使某一行某一节Item（Cell）、Supplementary View或Decoration View失效：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">invalidateItemsAtIndexPaths</span><span class="o">:</span>
</span><span class='line'><span class="nx">invalidateSupplementaryElementsOfKind</span><span class="o">:</span><span class="nx">atIndexPaths</span><span class="o">:</span>
</span><span class='line'><span class="nx">invalidateDecorationElementsOfKind</span><span class="o">:</span><span class="nx">atIndexPaths</span><span class="o">:</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>对应着添加了三个只读数组属性来标记上面那三种组件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">invalidatedItemIndexPaths</span>
</span><span class='line'><span class="nx">invalidatedSupplementaryIndexPaths</span>
</span><span class='line'><span class="nx">invalidatedDecorationIndexPaths</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>iOS自带的照片应用会将每一节照片的信息（时间、地点）停留显示在最顶部，实现这种将Header粘在顶端的功能其实就是将那个Index的Supplementary View失效，就这么简单。</p>

<p><code>UICollectionViewLayoutInvalidationContext</code>新加入的<code>contentOffsetAdjustment</code>和<code>contentSizeAdjustment</code>属性可以让我们更新CollectionView的content的位移和尺寸。</p>

<p>此外<code>UICollectionViewLayout</code>还加入了一对儿方法来帮助我们使用self-sizing：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">shouldInvalidateLayoutForPreferredLayoutAttributes</span><span class="o">:</span><span class="nx">withOriginalAttributes</span><span class="o">:</span>
</span><span class='line'><span class="nx">invalidationContextForPreferredLayoutAttributes</span><span class="o">:</span><span class="nx">withOriginalAttributes</span><span class="o">:</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当一个self-sizing Cell发生属性发生变化时，第一个方法会被调用，它询问是否应该更新布局（即原布局失效），默认为NO；而第二个方法更细化的指明了哪些属性应该更新，需要调用父类的方法获得一个InvalidationContext对象，然后对其做一些你想要的修改，最后返回。</p>

<p>试想，如果在你自定义的布局中，一个Cell的Size因为某种原因发生了变化（比如由于字体大小变化），其他的Cell会由于self-sizing而位置发生变化，你需要实现上面两个方法来让指定的Cell更新布局中的部分属性；别忘了整个CollectionView的<code>contentSize</code>和<code>contentOffset</code>因此也会发生变化，你需要给<code>contentOffsetAdjustment</code>和<code>contentSizeAdjustment</code>属性赋值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpriteKit在iOS8和OSX10.10中的新特性]]></title>
    <link href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/"/>
    <updated>2014-08-08T19:11:14+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing</id>
    <content type="html"><![CDATA[<p>在iOS8和OSX10.10中SpriteKit迎来了重大升级。在物理表现方面增加了着色器，光照和阴影；在物理模拟方面增加了像素物理体、力场和宇宙动力学和约束等；在Xcode中集成了场景编辑器，你不需要写代码就能完成一些复杂的工作；此外它还集成了SceneKit以及其他的改进。</p>

<!--more-->


<h2>Shader</h2>

<p>有时候为了表现一些形变和模糊效果，比如透过热气和火焰看一些物体，或者是飞船被攻击而产生弯曲。SpriteKit新加入了<code>SKShader</code>类来帮助我们更简单的实现这个效果。它通过使用自定义的OpenGL ES碎片着色来完成绘制一些<code>SKNode</code>的自定义行为。现在支持以下几种类型的绘制：</p>

<ul>
<li><code>SKSpriteNode</code></li>
<li><code>SKShapeNode</code></li>
<li><code>SKEmitterNode</code></li>
<li><code>SKEffectNode</code></li>
<li><code>SKScene</code></li>
</ul>


<p>放一张官方演示的效果图：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140738700571.png" alt="" /></p>

<p><code>SKShader</code>内建了一些<code>uniforms</code>，用<code>SKUniform</code>来描述，当你创建一个<code>SKShader</code>时，需要通过一个<code>fsh</code>文件或者一个字符串代码来创建，也可选择性的传入<code>uniforms</code>来定义游戏中一些额外的参数。下面是创建Shader方法的集合：</p>

<p>（下面的只是伪代码，不是OC也不是Swift语法，只是为了更简洁的标记方法名，后面类似情形都会标记为“伪代码”）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ shaderWithFileNamed:
</span><span class='line'>+ shaderWithSource:uniforms:
</span><span class='line'>+ shaderWithSource:
</span><span class='line'>+ shader
</span><span class='line'>- initWithSource:uniforms:
</span><span class='line'>- initWithSource:</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这些方法很相似，都是传入<code>source</code>或<code>source</code>与<code>uniforms</code>来创建shader。官方建议我们用<code>fsh</code>文件作为<code>source</code>而不是字符串代码；并且避免更改<code>source</code>或添加删除<code>uniforms</code>（修改<code>uniforms</code>是可以的），因为这样会导致后台花时间重新编译shader；尽量在加载时初始化shader。这些注意事项都可以总结为尽量使用内建的<code>uniforms</code>和共享shader对象。</p>

<p>我们可以将创建好的<code>SKShader</code>对象赋值给支持Shader渲染对象的<code>shader</code>属性。</p>

<p>下面列举一下Shader中的预定义符号：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140738949518.png" alt="" /></p>

<h2>Lighting and Shadows</h2>

<p>灯光和阴影效果可以给游戏增加真实感，SpriteKit这次增加了<code>SKLightNode</code>来作为光源节点。我们可以定义光源的颜色，阴影和衰弱程度。</p>

<p><code>SKLightNode</code>继承于<code>SKNode</code>，也就是说你可以把它加在其他<code>SKNode</code>上，并能够动起来，它是一个会发光的<code>SKNode</code>，cool！NOTE：它的光照以及阴影效果只对<code>SKSpriteNode</code>起作用。</p>

<p>下面我们看看<code>SKLightNode</code>的一些属性：</p>

<ul>
<li><strong><code>enabled</code></strong> 光源的开关</li>
<li><strong><code>ambientColor</code></strong> 环境色，默认是黑色，也就是没有环境色。它无视自身的alpha以及<code>SKLightNode</code>的<code>falloff</code>属性和<code>SKSpriteNode</code>的<code>normalTexture</code>属性，分分钟照亮全场。</li>
<li><strong><code>lightColor</code></strong> 顾名思义就是光的颜色，默认是白色。</li>
<li><strong><code>shadowColor</code></strong> 被精灵物体遮挡产生的阴影颜色。</li>
<li><strong><code>falloff</code></strong> 光源强度的衰减比率</li>
<li><strong><code>categoryBitMask</code></strong> 光的种类，32位整型数。<code>SKSpriteNode</code>的<code>lightingBitMask</code>、<code>shadowedBitMask</code>和<code>shadowCastBitMask</code>存储着光的种类，分别意味着：被何种光照亮、被何种光产生的阴影覆盖和遮挡何种光线并产生阴影。</li>
</ul>


<p>为了在<code>SKSpriteNode</code>上实现更加逼真的光照效果（如阴影和反射光），<code>SKSpriteNode</code>新增了<code>normalTexture</code>属性来储存原帖图的法线贴图（Normal Map）：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140739494085.png" alt="" /></p>

<p>上图中左侧的是原贴图，加上中间的法线贴图就合成出最右侧带有质感的光照纹理。当然提供这样一张发现纹理图片会增加开发者的工作量，苹果还提供了另一种更加简单的方案-“automatic normal map”：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140739540301.png" alt="" /></p>

<p>SpriteKit能够根据给出的纹理图片，用一系列算法分析原贴图，然后生成一个最佳的法线贴图，又是苹果的黑魔法！</p>

<p>毕竟众口难调，所以SpriteKit让你也可以在生成法线贴图的时候给出平滑度(smoothness)和对比度(contrast)来调节你想要的效果：（伪代码）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- textureByGeneratingNormalMapWithSmoothness:contrast:</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>PS：法线贴图将具有高细节的模型通过映射烘焙出法线贴图，贴在低端模型的法线贴图通道上，使之拥有法线贴图的渲染效果。可以大大降低渲染时需要的面数和计算内容，从而达到优化动画渲染和游戏渲染的效果。</p>

<p>在一个场景中可以添加多个光源，程序会运行的很快；但是如果用两个或以上的光源照亮同一个精灵，在某些iOS设备上可能保证不了60帧的刷新频率。</p>

<h2>New Physics</h2>

<h3>Per-Pixel Physics</h3>

<p>在定义一些复杂轮廓的物理体时，我们经常用简单图形代替，否则就用<code>CGPath</code>一点点描绘多边形或者把多个物理体组合在一起（这也是新加入的API，后面会提到），比如下面这把斧头，大多数程序员直接用矩形当做它的物理体：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140740041011.png" alt="" /></p>

<p>而Per-Pixel Physics根据纹理图片的alpha通道遮罩来生成一个粗略的形状，然后再用粗略的形状生成精确的形状，它让以前复杂的<code>CGPath</code>创建工作转变成一行代码：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140740040721.png" alt="" /></p>

<p>毕竟众口难调，所以SpriteKit给出了一个可以自由调节alpha阈值的物理体生成方法，所有alpha值大于<code>alphaThreshold</code>的像素点都将被认为是不透明的，并纳入物理体范围内：（伪代码）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ bodyWithTexture:alphaThreshold:size:</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>因为SpriteKit是逐个像素计算才得出精确的物理体轮廓，所以我们应该尽量给出合适大小的图片，不要将分辨率过高的图片用在很小的<code>SKSpriteNode</code>上。</p>

<h3>Constrains</h3>

<p>试想如果你要做一款塔防游戏，你需要让你的大炮一直瞄准某个怪物，大炮会随着怪物的行走来转动炮台。我们需要不停地根据怪物和大炮的位置来计算需要旋转的角度，甚至当怪物跑的快的时候还要考虑怪物的速度来调整大炮旋转的速度，这是一个很麻烦的事情。现在SpriteKit帮你把这些都做好了，你只需要建立一个<code>SKConstrains</code>对象，并约束大炮的角度跟怪物一致就行。</p>

<p>约束的计算工作发生在模拟物理之后，SpriteKit提供了一个回调函数<code>didApplyConstraints</code>，我们可以在约束完成后在里面做一些善后工作：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140740456021.png" alt="" /></p>

<p>在SpriteKit中我们可以向SKNode添加三种约束：（工厂方法的伪代码）</p>

<ul>
<li>位置约束：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//约束节点的X坐标范围
</span><span class='line'>+ positionX:
</span><span class='line'>//约束节点的Y坐标范围
</span><span class='line'>+ positionY:
</span><span class='line'>//约束节点的X和Y坐标范围
</span><span class='line'>+ positionX:Y:</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>方向约束：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//约束节点基于另一个SKNode旋转
</span><span class='line'>+ orientToNode:offset:
</span><span class='line'>//约束节点基于一个固定点旋转
</span><span class='line'>+ orientToPoint:offset:
</span><span class='line'>//约束节点基于另一个SKNode坐标系中的一个固定点旋转
</span><span class='line'>+ orientToPoint:inNode:offset:
</span><span class='line'>//约束节点的方向范围
</span><span class='line'>+ zRotation:</span></code></pre></td></tr></table></div></figure>


<p></p>

<ul>
<li>距离约束：</li>
</ul>


<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>//约束节点与另一节点保持一定距离
</span><span class='line'>+ distance:toNode:
</span><span class='line'>//约束节点与一个固定点保持一定距离
</span><span class='line'>+ distance:toPoint:
</span><span class='line'>//约束节点与另一个SKNode坐标系中的一个固定点保持一定距离
</span><span class='line'>+ distance:toPoint:inNode:</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>向<code>SKNode</code>添加约束很简单，只需要将一个<code>SKConstrains</code>数组赋值给<code>SKNode.constraints</code>属性即可。约束执行的顺序取决于它们在数组中的顺序。</p>

<h3>Inverse Kinematics</h3>

<p>反向运动学，没有机械工程学位或没写过动画引擎的人干脆不知道这是个啥。它其实是解决连接体运动的，比如现在有一个机器人的手臂，我们想让它动起来去用手抓某个东西。我们会想到每个关节转多少度才能准确让机器手抓到物体，计算的时候还应该考虑连接体的层级关系：肩膀连接上臂，上臂连接小臂，小臂连接手。哦天啊这真蛋疼，不过SpriteKit的反向动力学解决了这一点，我们只需要指定每个<code>SKNode</code>的活动约束还有需要抓取物体的位置，那么这一切只需要几行代码就能搞定。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140741648388.gif" alt="" /></p>

<p>机器人手臂转动约束是靠<code>SKReachConstraints</code>类来定义的，它只有一个初始化方法：（伪代码）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>- initWithLowerAngleLimit:upperAngleLimit:</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这个方法给<code>lowerAngleLimit</code>和<code>upperAngleLimit</code>属性赋值，约束了reach事件使其发生旋转角度的下限和上限。</p>

<p>当一个<code>SKReachConstraints</code>创建好后，将其赋值给<code>SKNode</code>的<code>reachConstraints</code>属性，然后用<code>SKPhysicsJoint</code>将这些<code>SKNode</code>连接起来。使用<code>SKAction</code>的一套工厂方法创建来让连接体reach到活动目标或固定点的动作：（伪代码）</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>+ reachTo:rootNode:duration:
</span><span class='line'>+ reachTo:rootNode:velocity:
</span><span class='line'>+ reachToNode:rootNode:duration:
</span><span class='line'>+ reachToNode:rootNode:velocity:</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>让机器人的手部节点运行创建好的<code>SKAction</code>对象即可达到最初描述的动画效果。如果机器人的手触碰不到指定的位置或节点（gif中就是这样），<code>SKAction</code>会执行动画让其尽可能接近目的地。</p>

<p>PS：IK（Inverse Kinematics）也能在SceneKit上运行。</p>

<h3>Physics Fields</h3>

<p>在一个模拟宇宙空间的游戏中，星球对其他物体的引力是不可忽视的，这就涉及到物理场。SpriteKit为我们提供了一个专门描述物理场的类<code>SKFieldNode</code>，它继承于<code>SKNode</code>，也就是说它可以被添加到其他节点中。它能够描述多种场：电场、磁场、矢量重力场、辐射重力场、噪声场等十余种场。<code>SKFieldNode</code>的<code>strength</code>和<code>falloff</code>属性决定了场的强度和衰减比率。</p>

<p><code>SKFieldNode</code>还有一些属性决定了游戏中哪些物理体会被场影响：</p>

<ul>
<li><strong><code>region</code></strong> 描述了场的影响区域，类型是<code>SKRegion</code>。<code>SKRegion</code>可以是无限区域，矩形、圆形、<code>CGPath</code>多边形区域，还可以用两个<code>SKRegion</code>做逻辑运算得出新的<code>SKRegion</code>，比如交集，并集，差集，还可对一个<code>SKRegion</code>取反得到剩下的区域。</li>
<li><strong><code>minimumRadius</code></strong> 一些场对物体的影响程度跟距离有关，当物体与场的距离小于<code>minimumRadius</code>属性的值时，仍被当做<code>minimumRadius</code>的值进行处理计算。<code>minimumRadius</code>的默认值很小很小，但不是0</li>
<li><strong><code>categoryBitMask</code></strong> 场的类别。当一个节点进入了场的影响区域，会根据节点的物理体属性的<code>fieldBitMask</code>属性来判断此节点是否收到场的影响。此外<code>SKPhysicsBody</code>的<code>charge</code>属性还会标记物理体所带的电荷量，这在跟电磁有关的场中会影响到物理体的运动。默认为 0xFFFFFFFF</li>
<li><strong><code>enabled</code></strong> 场的“开关”</li>
<li><strong><code>exclusive</code></strong> 唯我独尊，这个场的地盘内，别的场的影响被无视。别让两个唯我独尊的场影响区域重叠，那样会出乱子的。默认为<code>NO</code>。</li>
</ul>


<p>我用SpriteKit的力场中的噪声场和辐射重力场做了一个小游戏<a href="http://coloratom.yulingtianxia.com">ColorAtom</a>，有兴趣的可以去看看。应用了很多粒子系统和碰撞检测知识，把SpriteKit之前的内容能加的都加进去了，欢迎指正。</p>

<h2>Integration with SceneKit</h2>

<p>在SpriteKit这样的2D游戏引擎中也可以引入3D的内容，可以将SceneKit中的3D物体当做SpriteKit中的<code>SKNode</code>来操作，为了达到这一目的SpriteKit这次增加了<code>SK3DNode</code>类作为3D物体到SpriteKit中的桥接。</p>

<p>通过<code>SK3DNode</code>的<code>scnScene</code>属性可以获取到<code>SCNScene</code>，因为<code>SK3DNode</code>把3D场景渲染成2D贴图，所以创建<code>SK3DNode</code>对象的时候需要传入一个渲染后贴图的尺寸<code>viewportSize</code>。<code>pointOfView</code>属性存储了游戏视角的位置，你可以尝试实现个上帝视角。</p>

<p>由于我也不太了解“新”出的SceneKit，所以这部分不过多介绍了。</p>

<h2>Tools</h2>

<p>Xcode6增加了SpriteKit编辑器，一行代码都不用写就能创建出个游戏场景。这样你就将游戏内容从游戏逻辑冲分离出来。我们只需要将控件拖拽到游戏场景你想要的位置上，而不必每次调整一个飞船的位置，编译运行看看结果，然后再改代码微调位置再次编译运行。。。</p>

<p>SpriteKit编辑器不仅有编辑功能，也可用来debug。你可以再运行过程中将当前状态存储在一个sks文件中。</p>

<p>SpriteKit编辑器强大到你可以直接拖拽出一个SKSpriteNode并定义它的物理体，甚至使用Per-Pixel Physics。还可以编辑光照和阴影，编辑Shader并调整Uniforms，建立一个Inverse Kinematics并预览其效果，强大极了。</p>

<p>其实说白了SpriteKit编辑器就像IB一样可以可视化编辑属性，并课即时预览效果，整个过程不需一行代码。</p>

<p>Xcode能编辑fsh文件，与SpriteKit场景编辑器对照编辑，并做语法检查和编译。</p>

<h2>Improvements</h2>

<h3>SKScene</h3>

<p>SpriteKit每一帧场景的执行过程：</p>

<p><img src="http://yulingtianxia.qiniudn.com/update_loop_2x.png" alt="" /></p>

<p>除了之前提到新加的Constrains，SpriteKit这次还加入了一个回调函数<code>didFinishUpdate</code>。这绝对是SpriteKit将每帧所有东西打包好交给GPU渲染之前调用的最后一个函数。</p>

<h3>SKTexture</h3>

<ul>
<li><code>SKMutableTexture</code>是<code>SKTexture</code>新加的子类，它的内容可以通过<code>
modifyPixelDataWithBlock:</code>方法动态地修改。</li>
<li><code>SKTexture</code>现在可以生成“noise textures”，参见<code>textureVectorNoiseWithSmoothness:size:</code>和<code>
textureNoiseWithSmoothness:size:grayscale:</code><br/>
<img src="http://yulingtianxia.qiniudn.com/14074923846.png" alt="" /></li>
</ul>


<h3>SKShapeNode</h3>

<ul>
<li>增加了一些常见图形便捷的构造方法，比如矩形，圆形，椭圆和曲线。</li>
<li>可以用贴图和Shader来美化形状的描边和填充</li>
</ul>


<h3>Physics Updates</h3>

<ul>
<li><code>SKPhysicsBody</code>新加了<code>pinned</code>属性来标志此物理体对应的节点是否被钉在它的父节点上。如果父节点也有物理体，那么这两个物理体被认为被一个pin连接。如果将<code>allowsRotation</code>设为NO并且<code>pinned</code>设为YES，那么它相当于被焊在父节点上了，因为它不能转动了。</li>
<li><code>SKPhysicsBody</code>允许用<code>bodyWithBodies:</code>把多个物理体组合在一起来创建一个新的物理体，还记得前面提到过的斧头么：<br/>
  <img src="http://yulingtianxia.qiniudn.com/140749497219.png" alt="" /></li>
</ul>


<h3>SKTexture Atlas</h3>

<ul>
<li>同时支持SpriteKit和SceneKit</li>
<li>同时支持Retina和非Retina</li>
<li>同时支持16位和32位格式</li>
<li>支持4k x 4k 分辨率</li>
<li>支持运行时纹理图集的生成。比如从网上下载资源，SpriteKit会自动将透明的像素裁剪下去</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[CoreData处理海量数据]]></title>
    <link href="http://yulingtianxia.com/blog/2014/08/05/coredatachu-li-hai-liang-shu-ju/"/>
    <updated>2014-08-05T18:15:03+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/08/05/coredatachu-li-hai-liang-shu-ju</id>
    <content type="html"><![CDATA[<p>随着iOS8和OSX10.10的发布，Core Data也迎来了更新。这次的更新可谓是重量级的，它使得程序员能够更加直接高效的操作数据库，在处理大量数据时速度明显提升（这在以前不知有多少程序员因为Core Data批量更新数据效率之低而不得不放弃使用它）。Batch Updates可用于批量快速更新数据，Asynchronous Fetching可用于异步抓取海量数据，并可以通过<code>NSProgress</code>实现进度跟踪和取消。</p>

<!--more-->


<h2>Batch Updates</h2>

<p>在CoreData中想要更新大量数据，我们往往要将大量修改后的<code>NSManagedObject</code>加载到<code>NSManagedObjectContext</code>中并保存，这会占用大量内存，试想想在iPhone这样的内存有限的移动设备上将是个灾难，数据有可能丢失。你可能会采取批处理的方式，即一小批一小批的更新<code>NSManagedObject</code>并保存到<code>NSManagedObjectContext</code>中，但这样会花费很多时间，用户体验较差。</p>

<p>为了解决这个问题，苹果在<code>NSManagedObjectContext</code>加入了一个新的方法：<code>executeRequest:error:</code>，它接受一个<code>NSPersistentStoreRequest</code>类型的参数，返回类型为<code>NSPersistentStoreResult</code>。</p>

<p>关于<code>NSPersistentStoreRequest</code>有些人可能比较熟悉，它是<code>NSFetchRequest</code>、<code>NSSaveChangesRequest</code>、<code>NSBatchUpdateRequest</code>和<code>NSAsynchronousFetchRequest</code>的基类。后两个类是这次iOS8新加的，也是这篇文章将要讨论的内容。</p>

<p><code>NSPersistentStoreResult</code>是一个新加入的类，它也是一个基类，而且是抽象类，这个类作为<code>executeRequest:error:</code>返回内容的父类，相当于一个接口，它目前有两个子类：<code>NSPersistentStoreAsynchronousResult</code>和<code>NSBatchUpdateResult</code>。</p>

<p>你大概猜到了，<code>NSBatchUpdateResult</code>对应着前面的<code>NSBatchUpdateRequest</code>，下面说说<code>NSBatchUpdateRequest</code>。它有点像<code>NSFetchRequest</code>：它允许你指定一个想要更新数据的实体；也可以指定一个<code>affectedStores</code>，它存储了一个接受更新请求的<code>NSPersistentStore</code>数组。（其实它是<code>NSPersistentStoreRequest</code>的属性）；它也有一个谓词属性来做更新的条件，它跟<code>NSFetchRequest</code>中的谓词一样强大和灵活，类似于SQL的where语句；它允许你指定想要更新的字段，通过<code>propertiesToUpdate</code>属性来描述字段更新，它是一个字段，key为<code>NSPropertyDescription</code>或属性名字符串，value为<code>NSExpression</code>或常量。</p>

<p>接着谈谈<code>NSBatchUpdateResult</code>，它有一个<code>result</code>属性和<code>resultType</code>属性，<code>result</code>中的内容跟<code>resultType</code>有关，可能是成功或者失败，有可能是每行被更新的ID，也可能是被更新的行数。</p>

<p>需要注意的是，由于<code>NSBatchUpdateRequest</code>并不会先将数据存入内存，而是直接操作数据库，所以并不会引起NSManagedObjectContext的同步更新，所以你不仅需要获取<code>NSBatchUpdateResult</code>然后刷新<code>NSManagedObjectContext</code>对应的数据和UI界面，还需要保证更新后的数据满足数据库模型上的<code>validation</code>，因为<code>NSManagedObjectContext</code>没有感知Batch Updates，一些数据验证工作就落在了程序员的身上（你需要写一段代码验证更新后的数据是合法的，用户可不希望在跑步APP上看到自己今天跑步里程是个负数）。一旦有非法数据录入数据库，下次加载并修改<code>NSManagedObject</code>的时候就会导致数据验证失败。除了上面提到的这些，还要注意Batch Updates对数据库的操作是乐观锁，也就是假定很少会发生同时存取同一块数据的情况，所以你需要制定一个合理的&#8221;merge&#8221;策略来应付因同时更新数据产生的冲突。</p>

<p>Batch Updates的优势在于其效率，在处理上万条数据的时候，它执行的时间跟SQL语句执行时间相当。</p>

<h2>Asynchronous Fetching</h2>

<p>Asynchronous Fetching的加入依然是为了解决CoreData读取海量数据所带来的问题。通过使用Asynchronous Fetching，我们可以在抓取数据的同时不阻塞占用<code>NSManagedObjectContext</code>，并可以随时取消抓取行为，随时跟踪抓取数据的进度。</p>

<p>设想我们平时用<code>NSFetchRequest</code>抓取数据的时候，我们会先用<code>NSManagedObjectContext</code>的<code>executeFetchRequest:error:</code>方法传入一个<code>NSFetchRequest</code>，然后请求会被发送到<code>NSPersistentStore</code>，然后执行一段时间后返回一个数组，在<code>NSManagedObjectContext</code>更新后，这个数组被当做<code>executeFetchRequest:error:</code>的返回值返回到我们这里。</p>

<p>而Asynchronous Fetching则不同，当我们将一个<code>NSAsynchronousFetchRequest</code>对象传入<code>executeRequest:error:</code>方法后会立即返回一个“未来的”<code>NSAsynchronousFetchResult</code>。<code>NSAsynchronousFetchRequest</code>初始化时需要传入两个参数赋值给属性：</p>

<ol>
<li><code>completionBlock</code>属性，允许我们在抓取完成后执行回调block；</li>
<li><code>fetchRequest</code>属性，类型是<code>NSFetchRequest</code>。也即是说虽然是异步抓取，其实我们用的还是以前的<code>NSFetchRequest</code>，当<code>NSFetchRequest</code>抓取结束后会更新<code>NSManagedObjectContext</code>，这也就意味着<code>NSManagedObjectContext</code>的并发类型只能是<code>NSPrivateQueueConcurrencyType</code>或<code>NSMainQueueConcurrencyType</code>。</li>
</ol>


<p>于是当我们用<code>NSAsynchronousFetchRequest</code>抓取数据时，我们会先用<code>NSManagedObjectContext</code>的<code>executeRequest:error:</code>方法传入一个<code>NSAsynchronousFetchRequest</code>，这个方法在<code>NSManagedObjectContext</code>上执行时，<code>NSManagedObjectContext</code>会立即制造并返回一个<code>NSAsynchronousFetchResult</code>，同时<code>NSAsynchronousFetchRequest</code>会被发送到<code>NSPersistentStore</code>。你现在可以继续编辑这个<code>NSManagedObjectContext</code>中的<code>NSManagedObject</code>，等到<code>NSPersistentStore</code>执行请求完毕时会将结果返回给<code>NSAsynchronousFetchResult</code>的<code>finalResult</code>属性，更新<code>NSManagedObjectContext</code>，执行<code>NSAsynchronousFetchRequest</code>的回调block。</p>

<p>举个栗子：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let request = NSFetchRequest(entityName: "MyEntity")
</span><span class='line'>        let async = NSAsynchronousFetchRequest(fetchRequest: request){
</span><span class='line'>            (id result) in
</span><span class='line'>            if result.finalResult {
</span><span class='line'>                //TODO..
</span><span class='line'>            }
</span><span class='line'>        }</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Swift代码很简洁，并用了尾随闭包语法，看不懂的朋友也不用着急，知道<code>NSAsynchronousFetchRequest</code>大概的用法就行。</p>

<p>之前提到过<code>NSAsynchronousFetchRequest</code>能在抓取数据的过程中跟踪进度，于是乎<code>NSProgress</code>登场了！一行代码顶十句话：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let request = NSFetchRequest(entityName: "MyEntity")
</span><span class='line'>var asyncResult:NSPersistentStoreResult!
</span><span class='line'>let async = NSAsynchronousFetchRequest(fetchRequest: request){
</span><span class='line'>            (id result) in
</span><span class='line'>            if result.finalResult {
</span><span class='line'>                //TODO..
</span><span class='line'>            }
</span><span class='line'>        }
</span><span class='line'>let progress = NSProgress(totalUnitCount: 1)
</span><span class='line'>progress.becomeCurrentWithPendingUnitCount(1)
</span><span class='line'>managedObjectContext?.performBlock{
</span><span class='line'>            [unowned self] in
</span><span class='line'>            let error = NSErrorPointer()
</span><span class='line'>            asyncResult = self.managedObjectContext?.executeRequest(async, error: error)
</span><span class='line'>        }
</span><span class='line'>progress.resignCurrent()</span></code></pre></td></tr></table></div></figure>


<p>
而取消获取数据只需要取消<code>NSProgress</code>就可以了！取消行为会沿着数的根节点蔓延到叶子。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>progress.cancel()</span></code></pre></td></tr></table></div></figure>


<p>
可以在<code>cancellationHandler</code>属性设置取消后执行的block，这里不再多说。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/29/reactivecocoa/"/>
    <updated>2014-07-29T14:15:57+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/29/reactivecocoa</id>
    <content type="html"><![CDATA[<p>几个月前看了一点RAC的介绍，感觉很强大但也很难入门，这次挖个坑，整理下RAC的资源。</p>

<!--more-->


<h2>官方介绍</h2>

<p>ReactiveCocoa 受<a href="http://blog.maybeapps.com/post/42894317939/input-and-output">函数响应式编程</a>激发。不同于使用可变的变量替换和就地修改，RAC提供Signals（被表示为<code>RACSignal</code>）来捕获当前值和将来值。</p>

<p>通过链接（chaining），组合（combining）和对Signals做出反应（reacting），我们不必频繁地观察并更新值，而是声明式编写软件。</p>

<p>比如，文本域可以绑定到最新的时间，当它变化时，不需用额外的代码来观察时间每秒钟更新文本域。它类似KVO，但是用blocks替代了重写 <code>-observeValueForKeyPath:ofObject:change:context:</code>。</p>

<p>Signals也可以表示异步操作，很像<a href="http://en.wikipedia.org/wiki/Futures_and_promises">futures and promises</a>。这极大地简化了异步编码，包括网络方面的代码。</p>

<p>RAC一个重要的优点就是它提供了单独的、统一的方法来处理异步行为，包括委托方法，回调blocks，target-action机制，通知和KVO。</p>

<p>这有一个简单的例子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// When self.username changes, logs the new name to the console.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// RACObserve(self, username) creates a new RACSignal that sends the current</span>
</span><span class='line'><span class="c1">// value of self.username, then the new value whenever it changes.</span>
</span><span class='line'><span class="c1">// -subscribeNext: will execute the block whenever the signal sends a value.</span>
</span><span class='line'><span class="p">[</span><span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span> <span class="nl">subscribeNext:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">newName</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">newName</span><span class="p">);</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>但是不同于KVO通知，signals可以链接在一起操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Only logs names that starts with &quot;j&quot;.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// -filter returns a new RACSignal that only sends a new value when its block</span>
</span><span class='line'><span class="c1">// returns YES.</span>
</span><span class='line'><span class="p">[[</span><span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">username</span><span class="p">)</span>
</span><span class='line'>  <span class="nl">filter:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">newName</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="n">newName</span> <span class="nl">hasPrefix:</span><span class="s">@&quot;j&quot;</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}]</span>
</span><span class='line'>  <span class="nl">subscribeNext:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">newName</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;%@&quot;</span><span class="p">,</span> <span class="n">newName</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>Signals也可以被用于导出状态。不必观察属性然后设置其他属性来响应这个属性新的值，RAC可以依照signals和操作来表达属性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Creates a one-way binding so that self.createEnabled will be</span>
</span><span class='line'><span class="c1">// true whenever self.password and self.passwordConfirmation</span>
</span><span class='line'><span class="c1">// are equal.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// RAC() is a macro that makes the binding look nicer.</span>
</span><span class='line'><span class="c1">// </span>
</span><span class='line'><span class="c1">// +combineLatest:reduce: takes an array of signals, executes the block with the</span>
</span><span class='line'><span class="c1">// latest value from each signal whenever any of them changes, and returns a new</span>
</span><span class='line'><span class="c1">// RACSignal that sends the return value of that block as values.</span>
</span><span class='line'><span class="n">RAC</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">createEnabled</span><span class="p">)</span> <span class="o">=</span> <span class="p">[</span><span class="n">RACSignal</span>
</span><span class='line'>  <span class="nl">combineLatest:</span><span class="err">@</span><span class="p">[</span> <span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">password</span><span class="p">),</span> <span class="n">RACObserve</span><span class="p">(</span><span class="n">self</span><span class="p">,</span> <span class="n">passwordConfirmation</span><span class="p">)</span> <span class="p">]</span>
</span><span class='line'>  <span class="nl">reduce:</span><span class="o">^</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">password</span><span class="p">,</span> <span class="n">NSString</span> <span class="o">*</span><span class="n">passwordConfirm</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="err">@</span><span class="p">([</span><span class="n">passwordConfirm</span> <span class="nl">isEqualToString:</span><span class="n">password</span><span class="p">]);</span>
</span><span class='line'>  <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>Signals可以建立在任意值随时间的流动上，不仅仅是KVO。比如，它们也能表示按钮被按下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Logs a message whenever the button is pressed.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// RACCommand creates signals to represent UI actions. Each signal can</span>
</span><span class='line'><span class="c1">// represent a button press, for example, and have additional work associated</span>
</span><span class='line'><span class="c1">// with it.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// -rac_command is an addition to NSButton. The button will send itself on that</span>
</span><span class='line'><span class="c1">// command whenever it&#39;s pressed.</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">button</span><span class="p">.</span><span class="n">rac_command</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RACCommand</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSignalBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">_</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;button was pressed!&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="n">RACSignal</span> <span class="n">empty</span><span class="p">];</span>
</span><span class='line'><span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>或者异步网络操作：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Hooks up a &quot;Log in&quot; button to log in over the network.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// This block will be run whenever the login command is executed, starting</span>
</span><span class='line'><span class="c1">// the login process.</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">loginCommand</span> <span class="o">=</span> <span class="p">[[</span><span class="n">RACCommand</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithSignalBlock:</span><span class="o">^</span><span class="p">(</span><span class="kt">id</span> <span class="n">sender</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// The hypothetical -logIn method returns a signal that sends a value when</span>
</span><span class='line'>  <span class="c1">// the network request finishes.</span>
</span><span class='line'>  <span class="k">return</span> <span class="p">[</span><span class="n">client</span> <span class="n">logIn</span><span class="p">];</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// -executionSignals returns a signal that includes the signals returned from</span>
</span><span class='line'><span class="c1">// the above block, one for each time the command is executed.</span>
</span><span class='line'><span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">loginCommand</span><span class="p">.</span><span class="n">executionSignals</span> <span class="nl">subscribeNext:</span><span class="o">^</span><span class="p">(</span><span class="n">RACSignal</span> <span class="o">*</span><span class="n">loginSignal</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>  <span class="c1">// Log a message whenever we log in successfully.</span>
</span><span class='line'>  <span class="p">[</span><span class="n">loginSignal</span> <span class="nl">subscribeCompleted:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Logged in successfully!&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}];</span>
</span><span class='line'><span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// Executes the login command when the button is pressed.</span>
</span><span class='line'><span class="n">self</span><span class="p">.</span><span class="n">loginButton</span><span class="p">.</span><span class="n">rac_command</span> <span class="o">=</span> <span class="n">self</span><span class="p">.</span><span class="n">loginCommand</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>Signals也能表示定时器，其他UI事件，或者任何其他随时间而改变的东西。</p>

<p>通过链接和转换这些Signals，可以为异步操作建立更加复杂的行为。在一组操作完成后，后续工作能容易地被触发：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Performs 2 network operations and logs a message to the console when they are</span>
</span><span class='line'><span class="c1">// both completed.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// +merge: takes an array of signals and returns a new RACSignal that passes</span>
</span><span class='line'><span class="c1">// through the values of all of the signals and completes when all of the</span>
</span><span class='line'><span class="c1">// signals complete.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// -subscribeCompleted: will execute the block when the signal completes.</span>
</span><span class='line'><span class="p">[[</span><span class="n">RACSignal</span>
</span><span class='line'>  <span class="nl">merge:</span><span class="err">@</span><span class="p">[</span> <span class="p">[</span><span class="n">client</span> <span class="n">fetchUserRepos</span><span class="p">],</span> <span class="p">[</span><span class="n">client</span> <span class="n">fetchOrgRepos</span><span class="p">]</span> <span class="p">]]</span>
</span><span class='line'>  <span class="nl">subscribeCompleted:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;They&#39;re both done!&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>Signals可以被链接起来按顺序地执行异步操作，而不用嵌套回调blocks。这类似<a href="http://en.wikipedia.org/wiki/Futures_and_promises">futures and promises</a>是如何经常使用的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Logs in the user, then loads any cached messages, then fetches the remaining</span>
</span><span class='line'><span class="c1">// messages from the server. After that&#39;s all done, logs a message to the</span>
</span><span class='line'><span class="c1">// console.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// The hypothetical -logInUser methods returns a signal that completes after</span>
</span><span class='line'><span class="c1">// logging in.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// -flattenMap: will execute its block whenever the signal sends a value, and</span>
</span><span class='line'><span class="c1">// returns a new RACSignal that merges all of the signals returned from the block</span>
</span><span class='line'><span class="c1">// into a single signal.</span>
</span><span class='line'><span class="p">[[[[</span><span class="n">client</span>
</span><span class='line'>  <span class="n">logInUser</span><span class="p">]</span>
</span><span class='line'>  <span class="nl">flattenMap:</span><span class="o">^</span><span class="p">(</span><span class="n">User</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Return a signal that loads cached messages for the user.</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="n">client</span> <span class="nl">loadCachedMessagesForUser:</span><span class="n">user</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}]</span>
</span><span class='line'>  <span class="nl">flattenMap:</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">messages</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Return a signal that fetches any remaining messages.</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="n">client</span> <span class="nl">fetchMessagesAfterMessage:</span><span class="n">messages</span><span class="p">.</span><span class="n">lastObject</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}]</span>
</span><span class='line'>  <span class="nl">subscribeNext:</span><span class="o">^</span><span class="p">(</span><span class="n">NSArray</span> <span class="o">*</span><span class="n">newMessages</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;New messages: %@&quot;</span><span class="p">,</span> <span class="n">newMessages</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}</span> <span class="nl">completed:</span><span class="o">^</span><span class="p">{</span>
</span><span class='line'>      <span class="n">NSLog</span><span class="p">(</span><span class="s">@&quot;Fetched all messages.&quot;</span><span class="p">);</span>
</span><span class='line'>  <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>RAC甚至使绑定到异步操作结果更加容易：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">// Creates a one-way binding so that self.imageView.image will be set the user&#39;s</span>
</span><span class='line'><span class="c1">// avatar as soon as it&#39;s downloaded.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// The hypothetical -fetchUserWithUsername: method returns a signal which sends</span>
</span><span class='line'><span class="c1">// the user.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// -deliverOn: creates new signals that will do their work on other queues. In</span>
</span><span class='line'><span class="c1">// this example, it&#39;s used to move work to a background queue and then back to the main thread.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">// -map: calls its block with each user that&#39;s fetched and returns a new</span>
</span><span class='line'><span class="c1">// RACSignal that sends values returned from the block.</span>
</span><span class='line'><span class="n">RAC</span><span class="p">(</span><span class="n">self</span><span class="p">.</span><span class="n">imageView</span><span class="p">,</span> <span class="n">image</span><span class="p">)</span> <span class="o">=</span> <span class="p">[[[[</span><span class="n">client</span>
</span><span class='line'>  <span class="nl">fetchUserWithUsername:</span><span class="s">@&quot;joshaber&quot;</span><span class="p">]</span>
</span><span class='line'>  <span class="nl">deliverOn:</span><span class="p">[</span><span class="n">RACScheduler</span> <span class="n">scheduler</span><span class="p">]]</span>
</span><span class='line'>  <span class="nl">map:</span><span class="o">^</span><span class="p">(</span><span class="n">User</span> <span class="o">*</span><span class="n">user</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="c1">// Download the avatar (this is done on a background queue).</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[[</span><span class="n">NSImage</span> <span class="n">alloc</span><span class="p">]</span> <span class="nl">initWithContentsOfURL:</span><span class="n">user</span><span class="p">.</span><span class="n">avatarURL</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}]</span>
</span><span class='line'>  <span class="c1">// Now the assignment will be done on the main thread.</span>
</span><span class='line'>  <span class="nl">deliverOn:</span><span class="n">RACScheduler</span><span class="p">.</span><span class="n">mainThreadScheduler</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面示范了RAC能做什么，但它没示范RAC为何这么强大。用README的篇幅的例子很难赞美RAC，但是它让编程有更加简化的状态，更少的饮用，更好的代码位置和更好的表达意图。</p>

<p>更多的例子，参见 <a href="https://github.com/AshFurrow/C-41">C-41</a> 或 <a href="https://github.com/jspahrsummers/GroceryList">GroceryList</a>, 都是用ReactiveCocoa写的真实的iOS应用
. 关于 RAC 更多的详细信息可以在<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/tree/master/Documentation">Documentation</a> 文件夹中找到.</p>

<h2>我的学习笔记（不断更新）</h2>

<h3>函数式编程</h3>

<p>参考维基百科上的<a href="http://zh.wikipedia.org/wiki/%E5%87%BD%E6%95%B8%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80">概念</a>，简单理解为可以将函数作为其他函数的参数，具有block或λ表达式。</p>

<h3>响应式编程</h3>

<p>参考维基百科上的<a href="http://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BC%96%E7%A8%8B">概念</a>，简单地理解为专注于数据流和变化的传播。</p>

<h3>RAC中的类和方法</h3>

<h4>RACSignal和RACStream</h4>

<p>RAC的核心是Signal，对应的类为RACSignal，它其实是一个事件源，Signal会给它的订阅者（subscribers）发送一连串的事件。有三种事件：next，error和completed。Signal可以在error或completed事件发出前发出任意多的next事件。</p>

<p>RACSignal有很多方法用于订阅事件，查看RACSignal (Subscription)类别可以看到所有的订阅事件的方法，每个方法都会将类型为(void (^)(id x))的block作为参数，当事件发生时block中的代码会执行，例如<code>subscribeNext:</code>方法会传入一个block作为参数，当Signal的next事件发出后，block会接收到事件并执行。</p>

<p>RAC为UIKit添加了很多类别来让我们可以订阅UI组件的事件，比如UITextField (RACSignalSupport)中的rac_textSignal会在文本域内容变化时发出next事件。</p>

<p>事件包含的内容可以是类型，只要是对象就行，如果是一些数字，布尔值等字面量，可以用<code>@()</code>语法装箱成NSNumber。</p>

<p>RACSignal是RACStream的子类，RACStream是一个抽象类，描述了值的流动，列举一下它比较常用的操作（Operations类别）：</p>

<p><code>filter:</code> 对RACStream中的事件内容进行过滤，返回一个过滤事件内容后的instancetype<br/>
<code>map:</code> 会将事件中的数据转换成你想要的数据，返回一个转换事件内容后的instancetype<br/>
<code>flattenMap:</code> 在map的基础上使其flatten，也就是当Signal嵌套（一个Signal的事件是另一个Signal）的时候，会将内部Signal的事件传递给外部Signal<br/>
<code>distinctUntilChanged</code> 比较数值流中当前值和上一个值，如果不同，就返回当前值，简单理解为“流”的值有变化时反馈变化的值，求异存同。</p>

<p>PS：instancetype是程序运行时对象的类型，有可能为RACStream，也可以为其子类RACSignal。正是因为这些操作事件的方法都会返回事件源对象相同的类型，事件可以被一连串的被这些方法修改，过滤等，这就形成了管道，管道中传递着事件，包含着value。<br/>
建议管道的语法格式是每个操作新起一行，并在垂直方向上对齐：<br/>
<img src="http://cdn4.raywenderlich.com/wp-content/uploads/2014/01/PipelineFormatting.png" alt="" /><br/>
可惜Xcode的自动缩进并不会按照这样的格式对齐，是时候与它斗智斗勇啦！</p>

<p>RACSignal还有一些方法是对Signal做操作的，在RACSignal (Operations)类别中有详细的描述，比较常用的如下：</p>

<p><code>combineLatest:reduce:</code> 将一组Signal发出的最新的事件合并成一个Signal，每当这组Signal发出新事件时，reduce的block会执行，将所有新事件的值合并成一个值，并当做合并后Signal的事件发出去。这个方法会返回合并后的Signal。<br/>
PS：关于reduce的block中参数，其实是与combineLatest中数组元素一一对应的，这里RAC用了一个黑魔法，参看<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/blob/master/ReactiveCocoaFramework/ReactiveCocoa/RACBlockTrampoline.m?source=c">RACBlockTrampoline</a></p>

<p><code>doNext:</code> 这个向Signal管道上添加添加副作用。它并不会改变事件，参数block也没有返回值，它返回一个执行了block的Signal，这样block中的副作用就被注入到了以前的Signal。</p>

<p><code>then:</code> 当一个订阅者被发送了completed事件后，<code>then:</code>方法才会执行，订阅者会订阅<code>then:</code>方法返回的Signal，这个Signal是在block中返回的。这样优雅的实现了从一个Signal到另一个Signal的订阅。</p>

<p><code>deliverOn:</code> 参数为RACScheduler类的对象scheduler，这个方法会返回一个Signal，它的所有事件都会传递给scheduler参数所表示的线程，而以前管道上的副作用还会在以前的线程上。这个方法主要是切换线程。</p>

<p><code>subscribeOn:</code> 功能跟<code>deliverOn:</code>相同，但是它也会将副作用也切换到制定线程中。</p>

<p><code>throttle:</code>  它接收一个时间间隔interval作为参数，如果Signal发出的next事件之后interval时间内不再发出next事件，那么它返回的Signal会将这个next事件发出。也就是说，这个方法会将发送比较频繁的next事件舍弃，只保留一段“静默”时间之前的那个next事件，这个方法常用于处理输入框等信号（用户打字很快），因为它只保留用户最后输入的文字并返回一个新的Signal，将最后的文字作为next事件参数发出。</p>

<p><code>and</code>、<code>or</code>、<code>not</code> NSNumber中Bool的与、或、非操作，将Signal发出的事件内容转化。</p>

<p>还可以根据方法（SEL类型）来创建Signal，每当该方法被调用时，Signal都会将此方法被传入的参数打包成<code>RACTuple</code>元组类型来发送next事件给它的接受者。<code>rac_signalForSelector:</code>和<code>rac_signalForSelector:fromProtocol:</code>这两个方法都能通过指定的方法来创建Signal。</p>

<h4>RACSubscriber</h4>

<p>RACSubscriber是一个协议，包含了向订阅者发送事件的方法。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="p">[</span><span class="n">RACSignal</span> <span class="nl">createSignal:</span><span class="o">^</span><span class="n">RACDisposable</span> <span class="o">*</span><span class="p">(</span><span class="kt">id</span><span class="o">&lt;</span><span class="n">RACSubscriber</span><span class="o">&gt;</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>             <span class="p">[</span><span class="n">subscriber</span> <span class="nl">sendNext:</span><span class="err">@</span><span class="p">(</span><span class="n">YES</span><span class="p">)];</span>
</span><span class='line'>             <span class="p">[</span><span class="n">subscriber</span> <span class="n">sendCompleted</span><span class="p">];</span>
</span><span class='line'>        <span class="k">return</span> <span class="nb">nil</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p>上面工厂方法用于创建一个Signal，当Signal被订阅时，<code>createSignal:</code>的参数block中的内容被执行。block的参数是一个实现RACSubscriber协议的对象，然后向这个订阅者发送了next事件（内容为NSNumber类型的@YES值）和completed事件。<br/>
PS：除此之外RACSubscriber还有<code>sendError:</code>和<code>didSubscribeWithDisposable:</code>两个方法。</p>

<h4>RACDisposable</h4>

<p>你会发现RACSignal (Subscription)类别中所有方法的返回值类型都是RACDisposable，它的<code>dispose</code>方法可以让我们手动移除订阅者。举个栗子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="n">RACSignal</span> <span class="o">*</span><span class="n">backgroundColorSignal</span> <span class="o">=</span>
</span><span class='line'>  <span class="p">[</span><span class="n">self</span><span class="p">.</span><span class="n">searchText</span><span class="p">.</span><span class="n">rac_textSignal</span>
</span><span class='line'>    <span class="nl">map:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">text</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nl">isValidSearchText:</span><span class="n">text</span><span class="p">]</span> <span class="o">?</span>
</span><span class='line'>        <span class="p">[</span><span class="n">UIColor</span> <span class="n">whiteColor</span><span class="p">]</span> <span class="o">:</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">yellowColor</span><span class="p">];</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="n">RACDisposable</span> <span class="o">*</span><span class="n">subscription</span> <span class="o">=</span>
</span><span class='line'>  <span class="p">[</span><span class="n">backgroundColorSignal</span>
</span><span class='line'>    <span class="nl">subscribeNext:</span><span class="o">^</span><span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="n">color</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>      <span class="n">self</span><span class="p">.</span><span class="n">searchText</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}];</span>
</span><span class='line'>
</span><span class='line'><span class="c1">// at some point in the future ...</span>
</span><span class='line'><span class="p">[</span><span class="n">subscription</span> <span class="n">dispose</span><span class="p">];</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当管道（好吧比较短）的订阅者全部被移除后，管道中的代码不会执行，包括三种事件参数block中的代码和诸如<code>doNext:</code>等副作用的block。可以简单理解为，当管道中的Signal没人订阅，它的事件就不会发出了。</p>

<h4>RACCommand</h4>

<p><code>RACCommand</code> 通常用来表示某个Action的执行，比如点击Button。</p>

<h4>RACScheduler</h4>

<p>类似于GCD中的序列，是管理线程的类，负责RAC中让信号发出的事件华丽丽的在线程中穿梭，尤其是想更新UI必须在主线程中的时候，可以让事件直接从其他线程跳到主线程。此外RACScheduler也有优先级、延时等GCD中的特性。</p>

<h3>解决引用循环</h3>

<p>使用RAC会写大量的block，这就会涉及到引用循环的问题，如果你细心的话会发现上一节的代码就存在这个问题，一种普遍的解决办法是声明一个weak变量，并将self赋值给它，然后再block中使用这个weak变量，但这样太繁琐了。</p>

<p>在这里又有一个语法糖：<code>@weakify()</code>和<code>@strongify</code>，想使用它，得先导入类头文件：<code>#import "RACEXTScope.h"</code>。其实这个语法糖来自于<a href="https://github.com/jspahrsummers/libextobjc">Extended Objective-C</a>，有关它的原理请见<a href="http://aceontech.com/objc/ios/2014/01/10/weakify-a-more-elegant-solution-to-weakself.html">&ldquo;@weakify(self): A more elegant solution to weakSelf in Objective-C&rdquo;</a></p>

<p>于是上一节的代码可以改成下面这样：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="err">@</span><span class="n">weakify</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
</span><span class='line'><span class="p">[[</span><span class="n">self</span><span class="p">.</span><span class="n">searchText</span><span class="p">.</span><span class="n">rac_textSignal</span>
</span><span class='line'>  <span class="nl">map:</span><span class="o">^</span><span class="kt">id</span><span class="p">(</span><span class="n">NSString</span> <span class="o">*</span><span class="n">text</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">[</span><span class="n">self</span> <span class="nl">isValidSearchText:</span><span class="n">text</span><span class="p">]</span> <span class="o">?</span>
</span><span class='line'>      <span class="p">[</span><span class="n">UIColor</span> <span class="n">whiteColor</span><span class="p">]</span> <span class="o">:</span> <span class="p">[</span><span class="n">UIColor</span> <span class="n">yellowColor</span><span class="p">];</span>
</span><span class='line'>  <span class="p">}]</span>
</span><span class='line'>  <span class="nl">subscribeNext:</span><span class="o">^</span><span class="p">(</span><span class="n">UIColor</span> <span class="o">*</span><span class="n">color</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="err">@</span><span class="n">strongify</span><span class="p">(</span><span class="n">self</span><span class="p">)</span>
</span><span class='line'>    <span class="n">self</span><span class="p">.</span><span class="n">searchText</span><span class="p">.</span><span class="n">backgroundColor</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
</span><span class='line'>  <span class="p">}];</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>常用宏定义</h3>

<p><code>RAC()</code> 可以将Signal发出事件的值赋值给某个对象的某个属性，其参数为对象名和属性名<br/>
<code>RACObserve()</code> 参数为对象名和属性名，新建一个Signal并对对象的属性的值进行观察，当值变化时Signal会发出事件</p>

<h2>优秀文章</h2>

<p><a href="http://nshipster.cn/reactivecocoa/">nshipster-Reactive​Cocoa</a><br/>
<a href="http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html">ReactiveCocoa与Functional Reactive Programming</a><br/>
<a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html">说说ReactiveCocoa 2</a><br/>
<a href="http://blog.csdn.net/xdrt81y/article/details/30624469">使用ReactiveCocoa实现iOS平台响应式编程</a><br/>
<a href="http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html">ReactiveCocoa2实战</a><br/>
<a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1">ReactiveCocoa Tutorial – The Definitive Introduction: Part &frac12;</a><br/>
<a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a><br/>
<a href="http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1">MVVM Tutorial with ReactiveCocoa: Part &frac12;</a><br/>
<a href="http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2">MVVM Tutorial with ReactiveCocoa: Part 2/2</a></p>

<h2>视频</h2>

<iframe height=498 width=510 src="http://player.youku.com/embed/XNzQ3OTAxNzYw" frameborder=0 allowfullscreen></iframe>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Swift和SpriteKit开发iOS游戏]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/17/a-ios-game-developed-by-swift-and-spritekit/"/>
    <updated>2014-07-17T12:54:13+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/17/a-ios-game-developed-by-swift-and-spritekit</id>
    <content type="html"><![CDATA[<p>之前用SpriteKit做过一个叫做<a href="http://coloratom.yulingtianxia.com">ColorAtom</a>的小游戏，用了访问者模式处理碰撞检测，还用了SpriteKit中的粒子系统、连接体、力场和动画等，可以说是一个学习SpriteKit比较不错的Demo，随着Swift的火热，我也用Swift和SpriteKit写了一个更为简单的小游戏<a href="http://spiral.yulingtianxia.com">Spiral</a></p>

<!--more-->


<p>附上Spiral的动图：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140557437844.gif" alt="" /></p>

<p>游戏规则是：玩家是五角星小球，小球自动沿着陀螺线向外运动，当玩家点击屏幕时五角星小球会跳跃到内层螺旋，当五角星小球碰到红色旋风或滚动到螺旋线终点时游戏结束。玩家吃掉绿色旋风来得2分，吃到紫色三角得一分并获得保护罩，保护罩用来抵挡一次红色旋风。随着分数的增加游戏会升级，速度加快。游戏结束后可以截屏分享到社交网络，也可以选择重玩。</p>

<p>以下是本文内容：</p>

<ol>
<li>准备工作</li>
<li>绘制基本界面</li>
<li>Swift中用访问者模式处理碰撞</li>
<li>界面数据显示</li>
<li>按钮的绘制和截图分享</li>
</ol>


<h2>准备工作</h2>

<p>SpriteKit是苹果iOS7新推出的2D游戏引擎，这里不再过多介绍。我们新建工程的时候选取iOS中的Game，然后选择SpriteKit作为游戏引擎，语言选择Swift，Xcode6会为我们自动创建一个游戏场景<code>GameScene</code>，它包含<code>GameScene.swift</code>和<code>GameScene.sks</code>两个文件，<code>sks</code>文件可以让我们可视化拖拽游戏控件到场景上，然后再代码中加载<code>sks</code>文件来完成场景的初始化：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">extension</span> <span class="nx">SKNode</span> <span class="p">{</span>
</span><span class='line'>    <span class="kr">class</span> <span class="nx">func</span> <span class="nx">unarchiveFromFile</span><span class="p">(</span><span class="nx">file</span> <span class="o">:</span> <span class="nx">NSString</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">SKNode</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">NSBundle</span><span class="p">.</span><span class="nx">mainBundle</span><span class="p">().</span><span class="nx">pathForResource</span><span class="p">(</span><span class="nx">file</span><span class="p">,</span> <span class="nx">ofType</span><span class="o">:</span> <span class="s2">&quot;sks&quot;</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">sceneData</span> <span class="o">=</span> <span class="nx">NSData</span><span class="p">.</span><span class="nx">dataWithContentsOfFile</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">options</span><span class="o">:</span> <span class="p">.</span><span class="nx">DataReadingMappedIfSafe</span><span class="p">,</span> <span class="nx">error</span><span class="o">:</span> <span class="nx">nil</span><span class="p">)</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">archiver</span> <span class="o">=</span> <span class="nx">NSKeyedUnarchiver</span><span class="p">(</span><span class="nx">forReadingWithData</span><span class="o">:</span> <span class="nx">sceneData</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="nx">archiver</span><span class="p">.</span><span class="nx">setClass</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">classForKeyedUnarchiver</span><span class="p">(),</span> <span class="nx">forClassName</span><span class="o">:</span> <span class="s2">&quot;SKScene&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">scene</span> <span class="o">=</span> <span class="nx">archiver</span><span class="p">.</span><span class="nx">decodeObjectForKey</span><span class="p">(</span><span class="nx">NSKeyedArchiveRootObjectKey</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">GameScene</span>
</span><span class='line'>        <span class="nx">archiver</span><span class="p">.</span><span class="nx">finishDecoding</span><span class="p">()</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">scene</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>但我比较喜欢纯写代码的方式来搭接面，因为<code>sks</code>文件作为游戏场景布局还不成熟，它是iOS8新加入的功能，以前在iOS7的时候<code>sks</code>文件只是作为粒子系统的可视化编辑文件。</p>

<p>所以我们修改<code>GameViewController.swift</code>文件的<code>viewDidLoad()</code>函数，像以前那样直接用代码加载游戏场景：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">override</span> <span class="nx">func</span> <span class="nx">viewDidLoad</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="kr">super</span><span class="p">.</span><span class="nx">viewDidLoad</span><span class="p">()</span>
</span><span class='line'>        <span class="c1">// Configure the view.</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">skView</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">view</span> <span class="nx">as</span> <span class="nx">SKView</span>
</span><span class='line'>        <span class="cm">/* Sprite Kit applies additional optimizations to improve rendering performance */</span>
</span><span class='line'>        <span class="nx">skView</span><span class="p">.</span><span class="nx">ignoresSiblingOrder</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">scene</span> <span class="o">=</span> <span class="nx">GameScene</span><span class="p">(</span><span class="nx">size</span><span class="o">:</span> <span class="nx">skView</span><span class="p">.</span><span class="nx">bounds</span><span class="p">.</span><span class="nx">size</span><span class="p">)</span>
</span><span class='line'>        <span class="cm">/* Set the scale mode to scale to fit the window */</span>
</span><span class='line'>        <span class="nx">scene</span><span class="p">.</span><span class="nx">scaleMode</span> <span class="o">=</span> <span class="p">.</span><span class="nx">AspectFill</span>
</span><span class='line'>        <span class="nx">skView</span><span class="p">.</span><span class="nx">presentScene</span><span class="p">(</span><span class="nx">scene</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>GameScene</code>虽然是Xcode自动生成的，但是只是个空架子，我们需要把它生成的没用的代码删掉，比如初始化函数里内容为“HelloWorld”的<code>SKLabelNode</code>，还有<code>touchesBegan(touches: NSSet, withEvent event: UIEvent)</code>方法中绘制飞船的代码。把这些删光后，我们还需要有图片素材来绘制这四类精灵节点：<code>Player</code>（五角星），<code>Killer</code>（红色旋风），<code>Score</code>（绿色旋风）和<code>Shield</code>（紫色三角）。我是用Sketch来绘制这些矢量图形的，文件名为<code>spiral.sketch</code>，随同工程文件一同放到GitHub上了。当然你不需要手动导出图片到工程，直接下载工程文件就好了：</p>

<p><a href="https://github.com/yulingtianxia/Spiral">https://github.com/yulingtianxia/Spiral</a></p>

<h2>绘制基本界面</h2>

<p>这部分的工作主要是绘制出螺旋线作为地图，并让四种精灵节点动起来。</p>

<h3>螺旋线的绘制</h3>

<p><code>SKNode</code>有一个子类<code>SKShapeNode</code>，专门用于绘制线条的，我们新建一个<code>Map</code>类，继承<code>SKShapeNode</code>。下面我们需要生成一个<code>CGPath</code>来赋值给<code>Map</code>的<code>path</code>属性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">import</span> <span class="nx">UIKit</span>
</span><span class='line'><span class="kr">import</span> <span class="nx">SpriteKit</span>
</span><span class='line'><span class="kr">class</span> <span class="nx">Map</span><span class="o">:</span> <span class="nx">SKShapeNode</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">spacing</span><span class="o">:</span><span class="nx">CGFloat</span> <span class="o">=</span> <span class="mi">35</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">points</span><span class="o">:</span><span class="p">[</span><span class="nx">CGPoint</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'>    <span class="nx">convenience</span> <span class="nx">init</span><span class="p">(</span><span class="nx">origin</span><span class="o">:</span><span class="nx">CGPoint</span><span class="p">,</span><span class="nx">layer</span><span class="o">:</span><span class="nx">CGFloat</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">x</span><span class="o">:</span><span class="nx">CGFloat</span> <span class="o">=</span> <span class="nx">origin</span><span class="p">.</span><span class="nx">x</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">y</span><span class="o">:</span><span class="nx">CGFloat</span> <span class="o">=</span> <span class="nx">origin</span><span class="p">.</span><span class="nx">y</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">path</span> <span class="o">=</span> <span class="nx">CGPathCreateMutable</span><span class="p">()</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">init</span><span class="p">()</span>
</span><span class='line'>        <span class="nx">CGPathMoveToPoint</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">points</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">CGPointMake</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
</span><span class='line'>        <span class="k">for</span> <span class="nx">index</span> <span class="k">in</span> <span class="mi">1</span><span class="p">..</span><span class="o">&lt;</span><span class="nx">layer</span><span class="p">{</span>
</span><span class='line'>            <span class="nx">y</span><span class="o">-=</span><span class="nx">spacing</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nx">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="nx">CGPathAddLineToPoint</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">nil</span> <span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
</span><span class='line'>            <span class="nx">points</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">CGPointMake</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
</span><span class='line'>            <span class="nx">x</span><span class="o">-=</span><span class="nx">spacing</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="nx">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>            <span class="nx">CGPathAddLineToPoint</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">nil</span> <span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
</span><span class='line'>            <span class="nx">points</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">CGPointMake</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
</span><span class='line'>            <span class="nx">y</span><span class="o">+=</span><span class="nx">spacing</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nx">index</span>
</span><span class='line'>            <span class="nx">CGPathAddLineToPoint</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">nil</span> <span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
</span><span class='line'>            <span class="nx">points</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">CGPointMake</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
</span><span class='line'>            <span class="nx">x</span><span class="o">+=</span><span class="nx">spacing</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="nx">index</span>
</span><span class='line'>            <span class="nx">CGPathAddLineToPoint</span><span class="p">(</span><span class="nx">path</span><span class="p">,</span> <span class="nx">nil</span> <span class="p">,</span> <span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">)</span>
</span><span class='line'>            <span class="nx">points</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">CGPointMake</span><span class="p">(</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="p">))</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">path</span> <span class="o">=</span> <span class="nx">path</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">glowWidth</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">antialiased</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'>        <span class="nx">CGPathGetCurrentPoint</span><span class="p">(</span><span class="nx">path</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>算法很简单，就是顺时针计算点坐标然后画线，这里把每一步的坐标都存入了<code>points</code>数组里，是为了以后计算其他数据时方便。因为这部分算法不难而且不是我们的重点，这里不过多介绍了。</p>

<h3>四种精灵的绘制</h3>

<p>因为四种精灵都是沿着<code>Map</code>类的路径来顺时针运动，它们的动画绘制是相似的，所以我建立了一个<code>Shape</code>类作为基类来绘制动画，它继承于<code>SKSpriteKit</code>类，并拥有半径（<code>radius</code>）、移动速度（<code>moveSpeed</code>）和线段计数（<code>lineNum</code>）这三个属性。其中<code>lineNum</code>是用于标记精灵在螺旋线第几条线段上的，这样比较方便计算动画的参数。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Shape</span><span class="o">:</span> <span class="nx">SKSpriteNode</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">radius</span><span class="o">:</span><span class="nx">CGFloat</span> <span class="o">=</span> <span class="mi">10</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">moveSpeed</span><span class="o">:</span><span class="nx">CGFloat</span> <span class="o">=</span> <span class="mi">50</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">lineNum</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="nb">String</span><span class="p">,</span><span class="nx">imageName</span><span class="o">:</span><span class="nb">String</span><span class="p">){</span>
</span><span class='line'>        <span class="kr">super</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">texture</span><span class="o">:</span> <span class="nx">SKTexture</span><span class="p">(</span><span class="nx">imageNamed</span><span class="o">:</span> <span class="nx">imageName</span><span class="p">),</span><span class="nx">color</span><span class="o">:</span><span class="nx">SKColor</span><span class="p">.</span><span class="nx">clearColor</span><span class="p">(),</span> <span class="nx">size</span><span class="o">:</span> <span class="nx">CGSizeMake</span><span class="p">(</span><span class="nx">radius</span><span class="o">*</span><span class="mi">2</span><span class="p">,</span> <span class="nx">radius</span><span class="o">*</span><span class="mi">2</span><span class="p">))</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">physicsBody</span> <span class="o">=</span> <span class="nx">SKPhysicsBody</span><span class="p">(</span><span class="nx">circleOfRadius</span><span class="o">:</span> <span class="nx">radius</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">physicsBody</span><span class="p">.</span><span class="nx">usesPreciseCollisionDetection</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">physicsBody</span><span class="p">.</span><span class="nx">collisionBitMask</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">physicsBody</span><span class="p">.</span><span class="nx">contactTestBitMask</span> <span class="o">=</span> <span class="nx">playerCategory</span><span class="o">|</span><span class="nx">killerCategory</span><span class="o">|</span><span class="nx">scoreCategory</span>
</span><span class='line'>        <span class="nx">moveSpeed</span> <span class="o">+=</span> <span class="nx">CGFloat</span><span class="p">(</span><span class="nx">Data</span><span class="p">.</span><span class="nx">speedScale</span><span class="p">)</span> <span class="o">*</span> <span class="nx">self</span><span class="p">.</span><span class="nx">moveSpeed</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">physicsBody</span><span class="p">.</span><span class="nx">angularDamping</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>构造函数中设定了<code>Shape</code>类的一些物理参数，比如物理体的形状大小，碰撞检测掩码等。这里设定<code>usesPreciseCollisionDetection</code>为<code>true</code>是为了增加碰撞检测的精度，常用于体积小速度快的物体。<code>collisionBitMask</code>属性标记了需要模拟物理碰撞的类别，<code>contactTestBitMask</code>属性标记了需要检测到碰撞的类别。这里说的“类别”指的是物体的类别：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">playerCategory</span><span class="o">:</span><span class="nx">UInt32</span>      <span class="o">=</span>  <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">killerCategory</span><span class="o">:</span><span class="nx">UInt32</span>      <span class="o">=</span>  <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">scoreCategory</span><span class="o">:</span><span class="nx">UInt32</span>       <span class="o">=</span>  <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">shieldCategory</span><span class="o">:</span><span class="nx">UInt32</span>      <span class="o">=</span>  <span class="mh">0x1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
这种用位运算来判断和存储物体类别的方式很常用，上面这段代码写在了<code>NodeCategories.swift</code>文件中。</p>

<p>为了描述<code>Shape</code>的速度随着游戏等级上升而增加，这里速度的计算公式含有<code>Data.speedScale</code>作为参数，关于<code>Data</code>“类”在后面会讲到。</p>

<p>为了让精灵动起来，需要知道动画的移动目的地是什么。虽然<code>SKAction</code>有<code>followPath(path: CGPath?, speed: CGFloat)</code>方法，但是在这里并不实用，因为<code>Player</code>会经常改变路线，所以我写了一个<code>runInMap(map:Map)</code>方法让精灵每次只移动到路径上的下一个节点（之前<code>Map</code>类存储的<code>points</code>属性用到了吧！嘿嘿）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="nx">runInMap</span><span class="p">(</span><span class="nx">map</span><span class="o">:</span><span class="nx">Map</span><span class="p">){</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">distance</span> <span class="o">=</span> <span class="nx">calDistanceInMap</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">duration</span> <span class="o">=</span> <span class="nx">distance</span><span class="o">/</span><span class="nx">moveSpeed</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">rotate</span> <span class="o">=</span> <span class="nx">SKAction</span><span class="p">.</span><span class="nx">rotateByAngle</span><span class="p">(</span><span class="nx">distance</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="nx">duration</span><span class="o">:</span> <span class="nx">duration</span><span class="p">)</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">move</span> <span class="o">=</span> <span class="nx">SKAction</span><span class="p">.</span><span class="nx">moveTo</span><span class="p">(</span><span class="nx">map</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="nx">lineNum</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nx">duration</span><span class="o">:</span> <span class="nx">duration</span><span class="p">)</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">group</span> <span class="o">=</span> <span class="nx">SKAction</span><span class="p">.</span><span class="nx">group</span><span class="p">([</span><span class="nx">rotate</span><span class="p">,</span><span class="nx">move</span><span class="p">])</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">runAction</span><span class="p">(</span><span class="nx">group</span><span class="p">,</span> <span class="nx">completion</span><span class="o">:</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">self</span><span class="p">.</span><span class="nx">lineNum</span><span class="o">++</span>
</span><span class='line'>            <span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">lineNum</span><span class="o">==</span><span class="nx">map</span><span class="p">.</span><span class="nx">points</span><span class="p">.</span><span class="nx">count</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
</span><span class='line'>                <span class="k">if</span> <span class="nx">self</span> <span class="nx">is</span> <span class="nx">Player</span><span class="p">{</span>
</span><span class='line'>                    <span class="nx">Data</span><span class="p">.</span><span class="nx">gameOver</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">if</span> <span class="nx">self</span> <span class="nx">is</span> <span class="nx">Killer</span><span class="p">{</span>
</span><span class='line'>                    <span class="nx">self</span><span class="p">.</span><span class="nx">removeFromParent</span><span class="p">()</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">if</span> <span class="nx">self</span> <span class="nx">is</span> <span class="nx">Score</span><span class="p">{</span>
</span><span class='line'>                    <span class="nx">self</span><span class="p">.</span><span class="nx">removeFromParent</span><span class="p">()</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>                <span class="k">if</span> <span class="nx">self</span> <span class="nx">is</span> <span class="nx">Shield</span><span class="p">{</span>
</span><span class='line'>                    <span class="nx">self</span><span class="p">.</span><span class="nx">removeFromParent</span><span class="p">()</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>                <span class="nx">self</span><span class="p">.</span><span class="nx">runInMap</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="p">})</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>上面的代码先是调用<code>calDistanceInMap(map:Map)-&gt;CGFloat</code>方法计算精灵距离下一个节点的距离（也就是需要移动的距离），然后计算精灵需要旋转动画时间和移动动画时间，最后将两个动画作为一个<code>group</code>来运行，在动画运行结束后判断精灵是否运行到了最后一个节点，也就是螺旋线的终点：如果到终点了则移除精灵，否则开始递归调用方法，来开始下一段动画（奔向下一个节点）。</p>

<p>计算距离的<code>calDistanceInMap(map:Map)-&gt;CGFloat</code>方法代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="nx">calDistanceInMap</span><span class="p">(</span><span class="nx">map</span><span class="o">:</span><span class="nx">Map</span><span class="p">)</span><span class="o">-&gt;</span><span class="nx">CGFloat</span><span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">lineNum</span><span class="o">==</span><span class="nx">map</span><span class="p">.</span><span class="nx">points</span><span class="p">.</span><span class="nx">count</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">switch</span> <span class="nx">lineNum</span><span class="o">%</span><span class="mi">4</span><span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">position</span><span class="p">.</span><span class="nx">y</span><span class="o">-</span><span class="nx">map</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="nx">lineNum</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">y</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">position</span><span class="p">.</span><span class="nx">x</span><span class="o">-</span><span class="nx">map</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="nx">lineNum</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">x</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">map</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="nx">lineNum</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">y</span><span class="o">-</span><span class="nx">position</span><span class="p">.</span><span class="nx">y</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">map</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="nx">lineNum</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="nx">x</span><span class="o">-</span><span class="nx">position</span><span class="p">.</span><span class="nx">x</span>
</span><span class='line'>        <span class="k">default</span><span class="o">:</span>
</span><span class='line'>            <span class="k">return</span> <span class="mi">0</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>到此为止<code>Shape</code>类完成了，<code>Killer</code>、<code>Score</code>和<code>Shield</code>类比较简单，继承<code>Shape</code>类并设置自身纹理和类别即可：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Killer</span><span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">convenience</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="s2">&quot;Killer&quot;</span><span class="p">,</span><span class="nx">imageName</span><span class="o">:</span><span class="s2">&quot;killer&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">physicsBody</span><span class="p">.</span><span class="nx">categoryBitMask</span> <span class="o">=</span> <span class="nx">killerCategory</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kr">class</span> <span class="nx">Score</span><span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">convenience</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="s2">&quot;Score&quot;</span><span class="p">,</span><span class="nx">imageName</span><span class="o">:</span><span class="s2">&quot;score&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">physicsBody</span><span class="p">.</span><span class="nx">categoryBitMask</span> <span class="o">=</span> <span class="nx">scoreCategory</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kr">class</span> <span class="nx">Shield</span><span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">convenience</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="s2">&quot;Shield&quot;</span><span class="p">,</span><span class="nx">imageName</span><span class="o">:</span><span class="s2">&quot;shield&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">physicsBody</span><span class="p">.</span><span class="nx">categoryBitMask</span> <span class="o">=</span> <span class="nx">shieldCategory</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>而<code>Player</code>因为有护盾状态并可以在螺旋线上跳跃到内层，所以稍微复杂些：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Player</span><span class="o">:</span> <span class="nx">Shape</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">jump</span> <span class="o">=</span> <span class="kc">false</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">shield</span><span class="o">:</span><span class="nx">Bool</span> <span class="o">=</span> <span class="kc">false</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">willSet</span><span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">newValue</span><span class="p">{</span>
</span><span class='line'>            <span class="nx">self</span><span class="p">.</span><span class="nx">texture</span> <span class="o">=</span> <span class="nx">SKTexture</span><span class="p">(</span><span class="nx">imageNamed</span><span class="o">:</span> <span class="s2">&quot;player0&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span><span class="p">{</span>
</span><span class='line'>            <span class="nx">self</span><span class="p">.</span><span class="nx">texture</span> <span class="o">=</span> <span class="nx">SKTexture</span><span class="p">(</span><span class="nx">imageNamed</span><span class="o">:</span> <span class="s2">&quot;player&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">convenience</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span><span class="s2">&quot;Player&quot;</span><span class="p">,</span><span class="nx">imageName</span><span class="o">:</span><span class="s2">&quot;player&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">physicsBody</span><span class="p">.</span><span class="nx">categoryBitMask</span> <span class="o">=</span> <span class="nx">playerCategory</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">moveSpeed</span> <span class="o">=</span> <span class="mi">70</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">lineNum</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">restart</span><span class="p">(</span><span class="nx">map</span><span class="o">:</span><span class="nx">Map</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">alpha</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">removeAllActions</span><span class="p">()</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">lineNum</span> <span class="o">=</span> <span class="mi">3</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">moveSpeed</span> <span class="o">=</span> <span class="mi">70</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">jump</span> <span class="o">=</span> <span class="kc">false</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">shield</span> <span class="o">=</span> <span class="kc">false</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">position</span> <span class="o">=</span> <span class="nx">map</span><span class="p">.</span><span class="nx">points</span><span class="p">[</span><span class="nx">self</span><span class="p">.</span><span class="nx">lineNum</span><span class="p">]</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">runInMap</span><span class="p">(</span><span class="nx">map</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>Player</code>类的初始位置是螺旋线第四个节点，而且移动速度要略快于其他三种精灵，所以在这里设置为70（<code>Shape</code>默认速度50）。<code>jump</code>和<code>shield</code>是用来标记<code>Player</code>当前状态的属性，其中<code>shield</code>属性还定义了属性监察器，这是Swift中存储属性具有的响应机制，类似于<code>KVO</code>。在<code>shield</code>状态改变时也同时改变<code>Player</code>的纹理。<strong>需要注意的是构造器中对属性的改变并不会调用属性检查器，在<code>willSet</code>和<code>didSet</code>中改变自身属性也不会调用属性检查器，因为那样会造成死循环。</strong></p>

<p><code>restart(map:Map)</code>方法用于在游戏重新开始时重置<code>Player</code>的相关数据。</p>

<h2>Swift中用访问者模式处理碰撞</h2>

<p>访问者模式是双分派（Double Dispatch）模式的一种实现，关于双分派模式的详细解释，参考我的另一篇文章：<a href="http://yulingtianxia.com/blog/2014/04/13/double-dispatchmo-shi-ji-qi-zai-ioskai-fa-zhong-shi-zhan/">Double Dispatch模式及其在iOS开发中实践</a>，里面包含了C++，Java和Obje-C的实现，这次我们用Swift实现访问者模式。</p>

<p>因为SpriteKit中物理碰撞检测到的都是<code>SKPhysicsBody</code>，所以我们的被访问者需要包含一个<code>SKPhysicsBody</code>对象：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">VisitablePhysicsBody</span><span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">body</span><span class="o">:</span><span class="nx">SKPhysicsBody</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span><span class="nx">SKPhysicsBody</span><span class="p">){</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">body</span> <span class="o">=</span> <span class="nx">body</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">acceptVisitor</span><span class="p">(</span><span class="nx">visitor</span><span class="o">:</span><span class="nx">ContactVisitor</span><span class="p">){</span>
</span><span class='line'>        <span class="nx">visitor</span><span class="p">.</span><span class="nx">visitBody</span><span class="p">(</span><span class="nx">body</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>acceptVisitor</code>方法传入的是一个<code>ContactVisitor</code>类，它是访问者的基类（也相当于接口），访问者的<code>visitBody(body:SKPhysicsBody)</code>方法会根据传入的<code>body</code>实例来推断出被访问者的真实类别，然后调用对应的方法来处理碰撞：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="nx">visitBody</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span><span class="nx">SKPhysicsBody</span><span class="p">){</span>
</span><span class='line'>        <span class="c1">//第二次dispatch，通过构造方法名来执行对应方法</span>
</span><span class='line'>        <span class="c1">// 生成方法名，比如&quot;visitPlayer&quot;</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">contactSelectorString</span> <span class="o">=</span> <span class="s2">&quot;visit&quot;</span> <span class="o">+</span> <span class="nx">body</span><span class="p">.</span><span class="nx">node</span><span class="p">.</span><span class="nx">name</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">selector</span> <span class="o">=</span> <span class="nx">NSSelectorFromString</span><span class="p">(</span><span class="nx">contactSelectorString</span><span class="p">)</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">self</span><span class="p">.</span><span class="nx">respondsToSelector</span><span class="p">(</span><span class="nx">selector</span><span class="p">){</span>
</span><span class='line'>            <span class="nx">dispatch_after</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nx">dispatch_get_main_queue</span><span class="p">(),</span> <span class="p">{</span>
</span><span class='line'>                <span class="nx">NSThread</span><span class="p">.</span><span class="nx">detachNewThreadSelector</span><span class="p">(</span><span class="nx">selector</span><span class="p">,</span> <span class="nx">toTarget</span><span class="o">:</span><span class="nx">self</span><span class="p">,</span> <span class="nx">withObject</span><span class="o">:</span> <span class="nx">body</span><span class="p">)</span>
</span><span class='line'>                <span class="p">})</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>Swift废弃了<code>performSelector</code>方法，所以这里耍了个小聪明来将消息传给具体的访问者。有关Swift中替代<code>performSelector</code>的方案，参见<a href="http://www.cnblogs.com/yangzhou1030/p/3830592.html">这里</a></p>

<p>下面让<code>GameScene</code>实现<code>SKPhysicsContactDelegate</code>协议：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="nx">didBeginContact</span><span class="p">(</span><span class="nx">contact</span><span class="o">:</span><span class="nx">SKPhysicsContact</span><span class="p">){</span>
</span><span class='line'>        <span class="c1">//A-&gt;B</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">visitorA</span> <span class="o">=</span> <span class="nx">ContactVisitor</span><span class="p">.</span><span class="nx">contactVisitorWithBody</span><span class="p">(</span><span class="nx">contact</span><span class="p">.</span><span class="nx">bodyA</span><span class="p">,</span> <span class="nx">forContact</span><span class="o">:</span> <span class="nx">contact</span><span class="p">)</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">visitableBodyB</span> <span class="o">=</span> <span class="nx">VisitablePhysicsBody</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span> <span class="nx">contact</span><span class="p">.</span><span class="nx">bodyB</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">visitableBodyB</span><span class="p">.</span><span class="nx">acceptVisitor</span><span class="p">(</span><span class="nx">visitorA</span><span class="p">)</span>
</span><span class='line'>        <span class="c1">//B-&gt;A</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">visitorB</span> <span class="o">=</span> <span class="nx">ContactVisitor</span><span class="p">.</span><span class="nx">contactVisitorWithBody</span><span class="p">(</span><span class="nx">contact</span><span class="p">.</span><span class="nx">bodyB</span><span class="p">,</span> <span class="nx">forContact</span><span class="o">:</span> <span class="nx">contact</span><span class="p">)</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">visitableBodyA</span> <span class="o">=</span> <span class="nx">VisitablePhysicsBody</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span> <span class="nx">contact</span><span class="p">.</span><span class="nx">bodyA</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">visitableBodyA</span><span class="p">.</span><span class="nx">acceptVisitor</span><span class="p">(</span><span class="nx">visitorB</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
跟Objective-C中实现访问者模式类似，也是通过<code>ContactVisitor</code>类的工厂方法返回一个对应的子类实例来作为访问者，然后实例化一个被访问者，被访问者接受访问者的访问。A访问B和B访问A在大多数场合是相同的，但是你不知道谁是A谁是B，所以需要两种情况都调用。下面是<code>ContactVisitor</code>类的工厂方法和构造器：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">ContactVisitor</span><span class="o">:</span><span class="nx">NSObject</span><span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">body</span><span class="o">:</span><span class="nx">SKPhysicsBody</span><span class="o">!</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">contact</span><span class="o">:</span><span class="nx">SKPhysicsContact</span><span class="o">!</span>
</span><span class='line'>    <span class="kr">class</span> <span class="nx">func</span> <span class="nx">contactVisitorWithBody</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span><span class="nx">SKPhysicsBody</span><span class="p">,</span><span class="nx">forContact</span> <span class="nx">contact</span><span class="o">:</span><span class="nx">SKPhysicsContact</span><span class="p">)</span><span class="o">-&gt;</span><span class="nx">ContactVisitor</span><span class="o">!</span><span class="p">{</span>
</span><span class='line'>        <span class="c1">//第一次dispatch，通过node类别返回对应的实例</span>
</span><span class='line'>        <span class="k">if</span> <span class="mi">0</span> <span class="o">!=</span> <span class="nx">body</span><span class="p">.</span><span class="nx">categoryBitMask</span><span class="o">&amp;</span><span class="nx">playerCategory</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">PlayerContactVisitor</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span> <span class="nx">body</span><span class="p">,</span> <span class="nx">forContact</span><span class="o">:</span> <span class="nx">contact</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="mi">0</span> <span class="o">!=</span> <span class="nx">body</span><span class="p">.</span><span class="nx">categoryBitMask</span><span class="o">&amp;</span><span class="nx">killerCategory</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">KillerContactVisitor</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span> <span class="nx">body</span><span class="p">,</span> <span class="nx">forContact</span><span class="o">:</span> <span class="nx">contact</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="mi">0</span> <span class="o">!=</span> <span class="nx">body</span><span class="p">.</span><span class="nx">categoryBitMask</span><span class="o">&amp;</span><span class="nx">scoreCategory</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">ScoreContactVisitor</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span> <span class="nx">body</span><span class="p">,</span> <span class="nx">forContact</span><span class="o">:</span> <span class="nx">contact</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="mi">0</span> <span class="o">!=</span> <span class="nx">body</span><span class="p">.</span><span class="nx">categoryBitMask</span><span class="o">&amp;</span><span class="nx">shieldCategory</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">ShieldContactVisitor</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span> <span class="nx">body</span><span class="p">,</span> <span class="nx">forContact</span><span class="o">:</span> <span class="nx">contact</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">nil</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span><span class="nx">SKPhysicsBody</span><span class="p">,</span> <span class="nx">forContact</span> <span class="nx">contact</span><span class="o">:</span><span class="nx">SKPhysicsContact</span><span class="p">){</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">body</span> <span class="o">=</span> <span class="nx">body</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">contact</span> <span class="o">=</span> <span class="nx">contact</span>
</span><span class='line'>        <span class="kr">super</span><span class="p">.</span><span class="nx">init</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>PS：上面的代码省略了已经提到过的<code>visitBody(body:SKPhysicsBody)</code>方法</p>

<p>因为这个游戏逻辑比较简单，所有碰撞后的逻辑都写到了<code>PlayerContactVisitor</code>类里：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="nx">visitKiller</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span><span class="nx">SKPhysicsBody</span><span class="p">){</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">thisNode</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">node</span> <span class="nx">as</span> <span class="nx">Player</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">otherNode</span> <span class="o">=</span> <span class="nx">body</span><span class="p">.</span><span class="nx">node</span>
</span><span class='line'><span class="c1">//        println(thisNode.name+&quot;-&gt;&quot;+otherNode.name)</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">thisNode</span><span class="p">.</span><span class="nx">shield</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">otherNode</span><span class="p">.</span><span class="nx">removeFromParent</span><span class="p">()</span>
</span><span class='line'>            <span class="nx">thisNode</span><span class="p">.</span><span class="nx">shield</span> <span class="o">=</span> <span class="kc">false</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">Data</span><span class="p">.</span><span class="nx">gameOver</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">visitScore</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span><span class="nx">SKPhysicsBody</span><span class="p">){</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">thisNode</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">node</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">otherNode</span> <span class="o">=</span> <span class="nx">body</span><span class="p">.</span><span class="nx">node</span>
</span><span class='line'><span class="c1">//        println(thisNode.name+&quot;-&gt;&quot;+otherNode.name)</span>
</span><span class='line'>        <span class="nx">otherNode</span><span class="p">.</span><span class="nx">removeFromParent</span><span class="p">()</span>
</span><span class='line'>        <span class="nx">Data</span><span class="p">.</span><span class="nx">score</span> <span class="o">+=</span> <span class="mi">2</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">visitShield</span><span class="p">(</span><span class="nx">body</span><span class="o">:</span><span class="nx">SKPhysicsBody</span><span class="p">){</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">thisNode</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">body</span><span class="p">.</span><span class="nx">node</span> <span class="nx">as</span> <span class="nx">Player</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">otherNode</span> <span class="o">=</span> <span class="nx">body</span><span class="p">.</span><span class="nx">node</span>
</span><span class='line'>        <span class="nx">otherNode</span><span class="p">.</span><span class="nx">removeFromParent</span><span class="p">()</span>
</span><span class='line'>        <span class="nx">thisNode</span><span class="p">.</span><span class="nx">shield</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'>        <span class="nx">Data</span><span class="p">.</span><span class="nx">score</span><span class="o">++</span>
</span><span class='line'>        <span class="c1">//        println(thisNode.name+&quot;-&gt;&quot;+otherNode.name)</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>上面的方法都是“visit+类名”格式的，处理的是<code>Player</code>碰撞到其他三种精灵的逻辑。而其他三种精灵之间的碰撞不需要处理，所以<code>KillerContactVisitor</code>、<code>ScoreContactVisitor</code>和<code>ShieldContactVisitor</code>这三个<code>ContactVisitor</code>的子类很空旷，这里不再赘述。</p>

<p>我们设置<code>Player</code>碰撞到<code>Killer</code>游戏结束，碰撞到<code>Score</code>加两分，碰撞到<code>Shield</code>加一分并获得护甲（shield属性设为true）。可以看到这里大量用到了<code>Data</code>“类“”，它其实是一个存储并管理全局数据的结构体，它里面存储了一些静态的成员属性，也可看做非线程安全的单例。</p>

<h2>界面数据显示</h2>

<p>这部分很简单，主要是将<code>Data</code>结构体中存储的分数和等级等数据通过<code>SKLabelNode</code>显示在界面上，只不过我封装了一个<code>Display</code>类来将所有的<code>SKLabelNode</code>统一管理，并让其实现我定义的<code>DisplayData</code>协议来让<code>Data</code>中的数据变化驱动界面更新：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">protocol</span> <span class="nx">DisplayData</span><span class="p">{</span>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">updateData</span><span class="p">()</span>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">levelUp</span><span class="p">()</span>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">gameOver</span><span class="p">()</span>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">restart</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>下面是Data结构体代码，大量使用了存储属性的监察器来响应数据变化：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">struct</span> <span class="nx">Data</span><span class="p">{</span>
</span><span class='line'>    <span class="kr">static</span> <span class="kd">var</span> <span class="nx">display</span><span class="o">:</span><span class="nx">DisplayData</span><span class="o">?</span>
</span><span class='line'>    <span class="kr">static</span> <span class="kd">var</span> <span class="nx">updateScore</span><span class="o">:</span><span class="nx">Int</span> <span class="o">=</span> <span class="mi">5</span>
</span><span class='line'>    <span class="kr">static</span> <span class="kd">var</span> <span class="nx">score</span><span class="o">:</span><span class="nx">Int</span> <span class="o">=</span> <span class="mi">0</span><span class="p">{</span>
</span><span class='line'>    <span class="nx">willSet</span><span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">newValue</span><span class="o">&gt;=</span><span class="nx">updateScore</span><span class="p">{</span>
</span><span class='line'>            <span class="nx">updateScore</span><span class="o">+=</span><span class="mi">5</span> <span class="o">*</span> <span class="o">++</span><span class="nx">level</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">didSet</span><span class="p">{</span>
</span><span class='line'>        <span class="nx">display</span><span class="o">?</span><span class="p">.</span><span class="nx">updateData</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kr">static</span> <span class="kd">var</span> <span class="nx">highScore</span><span class="o">:</span><span class="nx">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="kr">static</span> <span class="kd">var</span> <span class="nx">gameOver</span><span class="o">:</span><span class="nx">Bool</span> <span class="o">=</span> <span class="kc">false</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">willSet</span><span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">newValue</span> <span class="p">{</span>
</span><span class='line'>            <span class="kd">let</span> <span class="nx">standardDefaults</span> <span class="o">=</span> <span class="nx">NSUserDefaults</span><span class="p">.</span><span class="nx">standardUserDefaults</span><span class="p">()</span>
</span><span class='line'>            <span class="nx">Data</span><span class="p">.</span><span class="nx">highScore</span> <span class="o">=</span> <span class="nx">standardDefaults</span><span class="p">.</span><span class="nx">integerForKey</span><span class="p">(</span><span class="s2">&quot;highscore&quot;</span><span class="p">)</span>
</span><span class='line'>            <span class="k">if</span> <span class="nx">Data</span><span class="p">.</span><span class="nx">highScore</span> <span class="o">&lt;</span> <span class="nx">Data</span><span class="p">.</span><span class="nx">score</span> <span class="p">{</span>
</span><span class='line'>                <span class="nx">Data</span><span class="p">.</span><span class="nx">highScore</span> <span class="o">=</span> <span class="nx">Data</span><span class="p">.</span><span class="nx">score</span>
</span><span class='line'>                <span class="nx">standardDefaults</span><span class="p">.</span><span class="nx">setInteger</span><span class="p">(</span><span class="nx">Data</span><span class="p">.</span><span class="nx">score</span><span class="p">,</span> <span class="nx">forKey</span><span class="o">:</span> <span class="s2">&quot;highscore&quot;</span><span class="p">)</span>
</span><span class='line'>                <span class="nx">standardDefaults</span><span class="p">.</span><span class="nx">synchronize</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="nx">display</span><span class="o">?</span><span class="p">.</span><span class="nx">gameOver</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">display</span><span class="o">?</span><span class="p">.</span><span class="nx">restart</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">didSet</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kr">static</span> <span class="kd">var</span> <span class="nx">level</span><span class="o">:</span><span class="nx">Int</span> <span class="o">=</span> <span class="mi">1</span><span class="p">{</span>
</span><span class='line'>    <span class="nx">willSet</span><span class="p">{</span>
</span><span class='line'>        <span class="nx">speedScale</span> <span class="o">=</span> <span class="nx">Float</span><span class="p">(</span><span class="nx">newValue</span><span class="p">)</span><span class="o">*</span><span class="mf">0.1</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">newValue</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">{</span>
</span><span class='line'>            <span class="nx">display</span><span class="o">?</span><span class="p">.</span><span class="nx">levelUp</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">didSet</span><span class="p">{</span>
</span><span class='line'>        <span class="nx">display</span><span class="o">?</span><span class="p">.</span><span class="nx">updateData</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kr">static</span> <span class="kd">var</span> <span class="nx">speedScale</span><span class="o">:</span><span class="nx">Float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">{</span>
</span><span class='line'>    <span class="nx">willSet</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">didSet</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="kr">static</span> <span class="nx">func</span> <span class="nx">restart</span><span class="p">(){</span>
</span><span class='line'>        <span class="nx">Data</span><span class="p">.</span><span class="nx">updateScore</span> <span class="o">=</span> <span class="mi">5</span>
</span><span class='line'>        <span class="nx">Data</span><span class="p">.</span><span class="nx">score</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>        <span class="nx">Data</span><span class="p">.</span><span class="nx">level</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>        <span class="nx">Data</span><span class="p">.</span><span class="nx">speedScale</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这里不得不提到一个更新界面时遇到的一个坑，当我想通过名字遍历<code>GameScene</code>子节点的时候，一般会用到<code>enumerateChildNodesWithName(name: String?, usingBlock: ((SKNode!, UnsafePointer&lt;ObjCBool&gt;) -&gt; Void)?)</code>方法，但是这个方法在Xcode6Beta3更新后经常会抛异常强退，这让我很费解，恰巧遇到此问题的不只是我一个人，所以还是老老实实的自己写循环遍历加判断吧。</p>

<h2>按钮的绘制和截图分享</h2>

<p>参考我的另外两篇文章：<a href="http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button/">在游戏的SKScene中添加Button</a>和<a href="http://yulingtianxia.com/blog/2014/04/22/spritekitjie-ping-bing-fen-xiang-zhi-she-jiao-wang-luo/">SpriteKit截屏并分享至社交网络</a></p>

<p>在本工程中只有<code>ShareButton</code>和<code>ReplayButton</code>两个按钮，Swift版本的代码很简洁，而我通过<code>Social.Framework</code>中的<code>UIActivityViewController</code>来分享得分，这部分代码写在了<code>ShareButton.swift</code>中：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">scene</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">scene</span> <span class="nx">as</span> <span class="nx">GameScene</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">image</span> <span class="o">=</span> <span class="nx">scene</span><span class="p">.</span><span class="nx">imageFromNode</span><span class="p">(</span><span class="nx">scene</span><span class="p">)</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">text</span> <span class="o">=</span> <span class="s2">&quot;我在Spiral游戏中得了\(Data.score)分，快来追逐我的步伐吧！&quot;</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">activityItems</span> <span class="o">=</span> <span class="p">[</span><span class="nx">image</span><span class="p">,</span><span class="nx">text</span><span class="p">]</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">activityController</span> <span class="o">=</span> <span class="nx">UIActivityViewController</span><span class="p">(</span><span class="nx">activityItems</span><span class="o">:</span> <span class="nx">activityItems</span><span class="p">,</span> <span class="nx">applicationActivities</span><span class="o">:</span> <span class="nx">nil</span><span class="p">)</span>
</span><span class='line'>        <span class="p">(</span><span class="nx">scene</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">nextResponder</span><span class="p">()</span> <span class="nx">as</span> <span class="nx">UIViewController</span><span class="p">).</span><span class="nx">presentViewController</span><span class="p">(</span><span class="nx">activityController</span><span class="p">,</span> <span class="nx">animated</span><span class="o">:</span> <span class="kc">true</span><span class="p">,</span> <span class="nx">completion</span><span class="o">:</span> <span class="nx">nil</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中的位运算符和溢出运算符]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/11/bitwise-and-overflow-operators-in-swift/"/>
    <updated>2014-07-11T15:15:59+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/11/bitwise-and-overflow-operators-in-swift</id>
    <content type="html"><![CDATA[<p>位运算符（Bitwise Operators），在各种语言中都存在，虽然用的有些少，但是在诸如类别判断，类型检测等方案中经常用位运算来实现。很多枚举类型的成员都是将<code>0x1</code>左移位来赋值，而不是从0递增，这其中就蕴含着位运算。而数值运算中的溢出也是一个不常遇到但又值得注意的地方，虽然很少有人用<code>Int8</code>来存储大数，但了解下Swift处理溢出的这一特性也是很有用的。</p>

<!--more-->


<h2>基本位运算符</h2>

<p><code>~</code>,<code>&amp;</code>,<code>|</code>,<code>^</code>分别为取反，与，或，异或运算：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let firstBit: UInt8 = 0b10000000
</span><span class='line'>let lastBit: UInt8  = 0b00000001
</span><span class='line'>let invertedBits = ~lastBit  // 等于 0b11111110
</span><span class='line'>let noneBit = firstBit & lastBit  // 等于 0b00000000
</span><span class='line'>let twoSideBits = firstBit | lastBit //等于 0b10000001
</span><span class='line'>let middleSixBits = firstBit ^ lastBit //等于 0b10000001</span></code></pre></td></tr></table></div></figure>


<p>
左移运算符<code>&lt;&lt;</code>和右移运算符<code>&gt;&gt;</code>分别扮演着乘2和除2的角色，对于<code>UInt</code>来讲很简单，只需要填充0就行：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftUnsigned_2x.png" alt="" /></p>

<p>但对于有符号整型数，移位时需要考虑到符号位，第一个比特位表达这个整数是正数还是负数。0代表正数，1代表负数。也就是说<code>Int8</code>最大是127，因为只有7位存储实际值，而且负数采用补码来表示。</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedFour_2x.png" alt="" /></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFour_2x.png" alt="" /></p>

<p>正数的补码是原码；负数的补码是符号位不变，数值位各位取反，最后整个数加1，补码之所以被机器采用是因为它符合机器的架构设计，只用加法就能算减法：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedAddition_2x.png" alt="" /></p>

<p>有符号整型右移运算时用符号位填充：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSigned_2x.png" alt="" /></p>

<p>这就确保了在右移的过程中，有符整型的符号不会发生变化。这称为算术移位。</p>

<h2>溢出运算符</h2>

<p>Swift中如果计算结果超出了它的类型能承载的范围，那么就会发生溢出错误，除非你已经使用溢出运算符来进行操作：</p>

<ul>
<li>溢出加法 <code>&amp;+</code></li>
<li>溢出减法 <code>&amp;-</code></li>
<li>溢出乘法 <code>&amp;*</code></li>
<li>溢出除法 <code>&amp;/</code></li>
<li>溢出求余 <code>&amp;%</code></li>
</ul>


<h3>值的上溢出</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var willOverflow = UInt8.max
</span><span class='line'>// willOverflow 等于UInt8的最大整数 255
</span><span class='line'>willOverflow = willOverflow &+ 1
</span><span class='line'>// 此时 willOverflow 等于 0</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowAddition_2x.png" alt="" /></p>

<h3>值的下溢出</h3>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var willUnderflow = UInt8.min
</span><span class='line'>// willUnderflow 等于UInt8的最小值0
</span><span class='line'>willUnderflow = willUnderflow &- 1
</span><span class='line'>// 此时 willUnderflow 等于 255</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowUnsignedSubtraction_2x.png" alt="" /></p>

<p>有符整型也有类似的下溢出</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>var signedUnderflow = Int8.min
</span><span class='line'>// signedUnderflow 等于最小的有符整数 -128
</span><span class='line'>signedUnderflow = signedUnderflow &- 1
</span><span class='line'>// 此时 signedUnderflow 等于 127</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowSignedSubtraction_2x.png" alt="" /></p>

<h3>除零溢出</h3>

<p>一个数除以0，或者对0求余数，就会产生一个错误；使用它们对应的可溢出的版本的运算符<code>&amp;/</code>和<code>&amp;%</code>进行除0操作时就会得到0值。</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>let x = 1
</span><span class='line'>let y = x &/ 0
</span><span class='line'>// y 等于 0</span></code></pre></td></tr></table></div></figure>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Setup Your Own VPN With PPTP]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/11/setup-your-own-vpn-with-pptp/"/>
    <updated>2014-07-11T13:22:16+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/11/setup-your-own-vpn-with-pptp</id>
    <content type="html"><![CDATA[<p>博主买的DigitalOcean的VPS服务，在配置好SSH远程访问后，准备继续配置pptp来搭建VPN科学上网。DO官网有详细的<a href="https://www.digitalocean.com/community/tutorials/how-to-setup-your-own-vpn-with-pptp">配置教程</a></p>

<p>PS:这里附上我的优惠链接，你用这个链接注册可以获得10美元：<a href="https://www.digitalocean.com/?refcode=2c163841a4f4">https://www.digitalocean.com/?refcode=2c163841a4f4</a></p>

<p>但是一步一步配置效率较低，多亏了脚本<a href="http://yansu.org/2013/12/11/deploy-pptp-vpn-in-ubuntu.html">http://yansu.org</a></p>

<!--more-->


<p>脚本虽然方便，但是需要改动几个地方，比如你可以设定你喜欢的<code>remoteip</code>范围，这样就可以调整你的VPN分配的IP范围；还可以添加可以使用VPN的自定义账户密码，下面是我修改过的脚本，里面添加了两个账户：yulingtianxia和802，每行四个参数分别是账户名、服务类型、密码和验证IP：</p>

<script src="https://gist.github.com/yulingtianxia/296b1b3b2edf5d762ae7.js"></script>


<p>在VPS上使用自动脚本只需要下面的操作：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>wget -c https://gist.githubusercontent.com/yulingtianxia/296b1b3b2edf5d762ae7/raw/e2ef1b18e85b393d22c82d26d72b20af14567e9c/pptp.sh
</span><span class='line'>chmod +x pptp.sh
</span><span class='line'>./pptp.sh</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>上面的命令先是用ssh的wget命令下载gist上的原始Shell脚本文件到VPS上，速度之快和安全性是ftp上传所不能比拟的。然后赋予pptp.sh可执行权限，最后执行pptp.sh</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Core Data(3)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3/"/>
    <updated>2014-07-03T10:28:28+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3</id>
    <content type="html"><![CDATA[<p>在Swift发布后，我尝试用Swift和Core Data做了一个小Demo，名字叫“<a href="http://hardchoice.yulingtianxia.com">HardChoice</a>”。它用于帮助人们随机生成一个问题的结果，当然结果是预设好的，并可以加入权值。本文将通过这个Demo来进一步阐述Core Data的知识。</p>

<p>本文包含以下内容：</p>

<ul>
<li>建立数据模型</li>
<li>Swift与Objective-C桥接</li>
<li>NSFetchedResultsController</li>
<li>UITextField键盘响应</li>
<li>随机选择算法</li>
</ul>


<!--more-->


<p>你可以在<a href="https://github.com/yulingtianxia/HardChoice">GitHub</a>上下载HardChoice的代码</p>

<p>在没弄懂Core Data的基础知识之前，我建议你先阅读我之前的两篇博文：</p>

<p><a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a><br/>
<a href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/">初识Core Data(2)</a></p>

<p>如果你不懂Swift也没关系，只要了解OC和Core Data，总是能看懂的</p>

<p>在写代码前先了解下我们要做什么：<br/>
<img src="http://yulingtianxia.qiniudn.com/140435701469.png" alt="" />
<img src="http://yulingtianxia.qiniudn.com/1404357012.png" alt="" /></p>

<p>先在第一个页面添加问题（吃啥？），然后点击问题进入到第二个添加选项（鸭子，蛋，猪）的页面。每个选项左边是选项名，右边是该选项的权值。摇动手机就能随机从所有选项中选出答案（就像第二张图那样）。</p>

<h2>建立数据模型</h2>

<p>还是像以前那样新建一个Master-Detail Application，勾选Use Core Data选项，语言选择Swift，然后Xcode会自动生成一个具有<code>UITableView</code>的Demo，这些内容之前说过。下面我们需要打开xcdatamodeld文件来建立我们的数据模型：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140436356516.png" alt="" /></p>

<p><code>Question</code>这个实体只具有一个属性，那就是问题内容<code>content</code>，类型为<code>String</code>；<code>Choice</code>实体有一个类型为<code>String</code>的<code>name</code>属性和一个类型为<code>Integer32</code>的<code>weight</code>属性，分别代表问题选项的名字和权重。</p>

<p>下面我们来建立<code>Question</code>和<code>Choice</code>这两个实体之间的关系：</p>

<p>假设每个问题都对应多个选项，也可以没有选项：</p>

<p><img src="http://yulingtianxia.qiniudn.com/14043675716.png" alt="" /></p>

<p><code>Optional</code>被打钩是因为问题可以没有任何选项，在Tpye那里我们选择<code>To Many</code></p>

<p>相反，每个选项一定会对应一个问题，并且是唯一的问题：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140436793089.png" alt="" /></p>

<p><code>Optional</code>那里不打钩是为了避免关系的目标为空，在<code>Tpye</code>那里我们选择了<code>To One</code></p>

<p><strong>关于<code>Delete Rule</code>的选择</strong></p>

<p>下面会通过部门与员工的例子来阐述<code>Delete Rule</code>的用法</p>

<ul>
<li><strong><code>Deny</code></strong> 如果关系指向的目标仍然有对象，那么关系的源对象就不会被删除，比如你想删除一个部门，必须先确保该部门所有员工已经调到其他部门（或被解雇），否则这个部门就不会被删除。</li>
<li><strong><code>Nullify</code></strong> 将被删除对象反向关系的目标设为null，比如如果你删除了一个部门，那么将这个部门所有成员的department关系目标设为null。需要注意的是员工的department关系应该被勾选为Optional，或者是在删除部门之后马上给该部门员工设置一个新的部门。</li>
<li><strong><code>Cascade</code></strong> 顾名思义它会传递删除命令，删除一个对象会导致这个对象关系中所指向的所有目标对象也被删除。比如如果你删除了一个部门那么这个部门所有员工都会被立即删除。</li>
<li><strong><code>No Action</code></strong> 无为而治。比如如果你删除了一个部门，那么这个部门底下的所有员工什么都不知道，他们还以为自己还属于这个部门。</li>
</ul>


<p>回到我们的例子，因为<code>Question</code>指向<code>Choice</code>的<code>choices</code>关系具有从属的性质，问题被删除后<code>choices</code>所指向的选项也应该被删除，所以<code>choices</code>关系中的<code>Delete Rule</code>我们选择<code>Cascade</code>；而<code>Choice</code>指向<code>Question</code>的<code>question</code>关系中<code>Delete Rule</code>被设置成了<code>Nullify</code>，也就是解除了<code>Question</code>与这个<code>Choice</code>的关系，并且我们之前已经设置<code>Question</code>的<code>choices</code>关系设置为<code>Optional</code>来满足<code>Nullify</code>这一选项的要求。</p>

<p><strong>注意：每当你修改过数据模型后，需要将以前生成好的APP删除后再重新Run一下，这样才不会发生错误。这是因为手动删除APP会连同将其数据一起删除，然后重新Run一下会将新的数据表结构安装在模拟器或真机上</strong></p>

<p>如果你对建立数据模型的过程生疏，建议回到<a href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/">初识Core Data(2)</a>中复习下“使用数据模型设计器”一节</p>

<h2>Swift与Objective-C桥接</h2>

<p>在使用Xcode6 Beta2生成<code>NSManagedObject</code>子类的时候，生成的代码依然是Objective-C的代码（即使我的工程是用Swift语言建立的），这就涉及到在Swift工程中调用Objective-C类的问题。苹果给我们提供了一个比较简单的解决方案。在你向工程中加入OC文件时，Xcode会自动弹出消息问你是否需要生成一个桥接头文件（“工程名-Bridging-Header.h”），然后我们在这个头文件中加入想要在Swift中调用的OC类的头文件：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="c1">//</span>
</span><span class='line'><span class="c1">//  Use this file to import your target&#39;s public headers that you would like to expose to Swift.</span>
</span><span class='line'><span class="c1">//</span>
</span><span class='line'>
</span><span class='line'><span class="cp">#import &quot;Question.h&quot;</span>
</span><span class='line'><span class="cp">#import &quot;Choice.h&quot;</span>
</span><span class='line'><span class="cp">#import &quot;CustomIOS7AlertView.h&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>Question</code>和<code>Choice</code>这两个类是用之前数据模型中同名实例创建的<code>NSManagedObject</code>子类，<code>CustomIOS7AlertView</code>类是本项目用到的一个自定义AlertView（iOS7之后苹果不再允许自定义<code>UIAlertView</code>了）</p>

<p>这样在Swift文件中不用<code>import</code>任何东西就可以直接使用上面被引入的OC类了</p>

<p>有关Swift和OC在同一项目中混合使用的方法详见<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/Swift%20and%20Objective-C%20in%20the%20Same%20Project.md">这里</a></p>

<h2>NSFetchedResultsController</h2>

<p>在<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a>中我们提到过<code>NSFetchedResultsController</code>的作用，简单地说，<code>NSFetchedResultsController</code>的作用就是有效率的管理从CoreData获取请求的数据结果，并将结果提供给<code>UITableView</code>作为数据源。</p>

<p>在<code>MasterViewController.swift</code>文件中，Xcode生成了两个<code>NSFetchedResultsController</code>属性：一个只读计算属性<code>fetchedResultsController</code>和一个可选存储属性<code>_fetchedResultsController</code>，通过两者搭配来实现setter，这里不再多说，将计算属性<code>fetchedResultsController</code>的定义替换如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'>   <span class="kd">var</span> <span class="nx">fetchedResultsController</span><span class="o">:</span> <span class="nx">NSFetchedResultsController</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">_fetchedResultsController</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">_fetchedResultsController</span><span class="o">!</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">fetchRequest</span> <span class="o">=</span> <span class="nx">NSFetchRequest</span><span class="p">()</span>
</span><span class='line'>        <span class="c1">// Edit the entity name as appropriate.</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">entity</span> <span class="o">=</span> <span class="nx">NSEntityDescription</span><span class="p">.</span><span class="nx">entityForName</span><span class="p">(</span><span class="s2">&quot;Question&quot;</span><span class="p">,</span> <span class="nx">inManagedObjectContext</span><span class="o">:</span> <span class="nx">self</span><span class="p">.</span><span class="nx">managedObjectContext</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">fetchRequest</span><span class="p">.</span><span class="nx">entity</span> <span class="o">=</span> <span class="nx">entity</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Set the batch size to a suitable number.</span>
</span><span class='line'>        <span class="nx">fetchRequest</span><span class="p">.</span><span class="nx">fetchBatchSize</span> <span class="o">=</span> <span class="mi">20</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Edit the sort key as appropriate.</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">sortDescriptor</span> <span class="o">=</span> <span class="nx">NSSortDescriptor</span><span class="p">(</span><span class="nx">key</span><span class="o">:</span> <span class="s2">&quot;content&quot;</span><span class="p">,</span> <span class="nx">ascending</span><span class="o">:</span> <span class="kc">true</span><span class="p">)</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">sortDescriptors</span> <span class="o">=</span> <span class="p">[</span><span class="nx">sortDescriptor</span><span class="p">]</span>
</span><span class='line'>
</span><span class='line'>        <span class="nx">fetchRequest</span><span class="p">.</span><span class="nx">sortDescriptors</span> <span class="o">=</span> <span class="nx">sortDescriptors</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Edit the section name key path and cache name if appropriate.</span>
</span><span class='line'>        <span class="c1">// nil for section name key path means &quot;no sections&quot;.</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">aFetchedResultsController</span> <span class="o">=</span> <span class="nx">NSFetchedResultsController</span><span class="p">(</span><span class="nx">fetchRequest</span><span class="o">:</span> <span class="nx">fetchRequest</span><span class="p">,</span> <span class="nx">managedObjectContext</span><span class="o">:</span> <span class="nx">self</span><span class="p">.</span><span class="nx">managedObjectContext</span><span class="p">,</span> <span class="nx">sectionNameKeyPath</span><span class="o">:</span> <span class="nx">nil</span><span class="p">,</span> <span class="nx">cacheName</span><span class="o">:</span> <span class="s2">&quot;Master&quot;</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">aFetchedResultsController</span><span class="p">.</span><span class="nx">delegate</span> <span class="o">=</span> <span class="nx">self</span>
</span><span class='line'>        <span class="nx">_fetchedResultsController</span> <span class="o">=</span> <span class="nx">aFetchedResultsController</span>
</span><span class='line'>
</span><span class='line'>      <span class="kd">var</span> <span class="nx">error</span><span class="o">:</span> <span class="nx">NSError</span><span class="o">?</span> <span class="o">=</span> <span class="nx">nil</span>
</span><span class='line'>      <span class="k">if</span> <span class="o">!</span><span class="nx">_fetchedResultsController</span><span class="o">!</span><span class="p">.</span><span class="nx">performFetch</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>           <span class="c1">// Replace this implementation with code to handle the error appropriately.</span>
</span><span class='line'>           <span class="c1">// abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. </span>
</span><span class='line'>             <span class="c1">//println(&quot;Unresolved error \(error), \(error.userInfo)&quot;)</span>
</span><span class='line'>           <span class="nx">abort</span><span class="p">()</span>
</span><span class='line'>      <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="k">return</span> <span class="nx">_fetchedResultsController</span><span class="o">!</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>NSFetchRequest</code>对象描述了从数据持久层获取数据的标准，也就是相当于SQL中的from和where等条件语句，它是初始化<code>NSFetchedResultsController</code>的必要参数之一，因为它规定了从<code>NSManagedObjectContext</code>实例中获取什么样的数据。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353389167.png" alt="" /></p>

<p><code>NSFetchRequest</code>的属性<code>NSEntityDescription</code>，<code>predicate</code>和<code>sortDescriptors</code>分别对应着SQL中的from，where和order by语句，只不过<code>NSFetchRequest</code>把复杂的SQL语句进行了简化，查抄条件和排序方法更加灵活。</p>

<p>在上面的<code>fetchedResultsController</code>属性中我们设置了<code>NSFetchRequest</code>实例：获取所有<code>Question</code>实体对应的数据，并将结果按照<code>content</code>属性的升序排列。</p>

<p><code>init(fetchRequest: NSFetchRequest!, managedObjectContext context: NSManagedObjectContext!, sectionNameKeyPath: String!, cacheName name: String!)</code>是<code>NSFetchedResultsController</code>的指定构造器，除了刚才提到的<code>fetchRequest</code>参数外，还需传入一个必要参数<code>managedObjectContext</code>，在这里我们传入的<code>managedObjectContext</code>是来自<code>AppDelegate</code>的<code>managedObjectContext</code>属性。有关<code>NSManagedObjectContext</code>的知识参见<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a>，这里不再赘述。<strong>当构造器执行结束后，你就不能再修改<code>NSFetchedResultsController</code>的<code>fetchRequest</code>属性了</strong>。</p>

<p><code>sectionNameKeyPath</code>参数是用来指定抓取数据结果的<code>section</code>信息的，这样<code>UITableView</code>的<code>section</code>信息此时已经预编译好了。因为我们的程序只需要一个<code>section</code>，所以只需传入<code>nil</code>；<code>cacheName</code>参数用于指定缓存<code>section</code>预编译信息的文件名，我们不需要缓存<code>section</code>信息，所以传入<code>nil</code>。</p>

<p>当执行<code>performFetch(error: NSErrorPointer) -&gt; Bool</code>方法成功后，你可以通过<code>NSFetchedResultsController</code>的<code>fetchedObjects</code>属性来获取数据结果，如果为<code>UITableView</code>提供数据，可以用<code>objectAtIndexPath(indexPath: NSIndexPath!) -&gt; AnyObject!</code>方法来更加便捷的将数据与<code>NSIndexPath</code>对接上。在我们的例子中，会把数据结果转化为<code>NSManagedObject</code>的子类<code>Question</code>或<code>Choice</code>类：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="nx">configureCell</span><span class="p">(</span><span class="nx">cell</span><span class="o">:</span> <span class="nx">UITableViewCell</span><span class="p">,</span> <span class="nx">atIndexPath</span> <span class="nx">indexPath</span><span class="o">:</span> <span class="nx">NSIndexPath</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">object</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">fetchedResultsController</span><span class="p">.</span><span class="nx">objectAtIndexPath</span><span class="p">(</span><span class="nx">indexPath</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">Question</span>
</span><span class='line'>    <span class="nx">cell</span><span class="p">.</span><span class="nx">textLabel</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="nx">object</span><span class="p">.</span><span class="nx">content</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>下面修改<code>insertNewObject</code>方法来添加新的<code>Question</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">addAV</span> <span class="o">=</span> <span class="nx">CustomIOS7AlertView</span><span class="p">()</span>
</span><span class='line'><span class="nx">func</span> <span class="nx">insertNewObject</span><span class="p">(</span><span class="nx">sender</span><span class="o">:</span> <span class="nx">AnyObject</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">textField</span> <span class="o">=</span> <span class="nx">UITextField</span><span class="p">(</span><span class="nx">frame</span><span class="o">:</span><span class="nx">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">290</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">becomeFirstResponder</span><span class="p">()</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">placeholder</span> <span class="o">=</span> <span class="s2">&quot;question&quot;</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">keyboardType</span> <span class="o">=</span> <span class="p">.</span><span class="nx">Default</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">returnKeyType</span> <span class="o">=</span> <span class="p">.</span><span class="nx">Done</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">delegate</span> <span class="o">=</span> <span class="nx">self</span>
</span><span class='line'>    <span class="nx">addAV</span><span class="p">.</span><span class="nx">containerView</span> <span class="o">=</span> <span class="nx">textField</span>
</span><span class='line'>    <span class="nx">addAV</span><span class="p">.</span><span class="nx">buttonTitles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;OK&quot;</span><span class="p">,</span><span class="s2">&quot;Cancel&quot;</span><span class="p">]</span>
</span><span class='line'>    <span class="nx">addAV</span><span class="p">.</span><span class="nx">delegate</span> <span class="o">=</span> <span class="nx">self</span>
</span><span class='line'>    <span class="nx">addAV</span><span class="p">.</span><span class="nx">useMotionEffects</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'>    <span class="nx">addAV</span><span class="p">.</span><span class="nx">show</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>有了添加<code>Question</code>功能，当然还会有修改功能：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">modifyAV</span> <span class="o">=</span> <span class="nx">CustomIOS7AlertView</span><span class="p">()</span>
</span><span class='line'><span class="nx">func</span> <span class="nx">modifyObject</span><span class="p">(</span><span class="nx">indexPath</span><span class="o">:</span><span class="nx">NSIndexPath</span><span class="p">){</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">question</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">fetchedResultsController</span><span class="p">.</span><span class="nx">objectAtIndexPath</span><span class="p">(</span><span class="nx">indexPath</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">Question</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">textField</span> <span class="o">=</span> <span class="nx">UITextField</span><span class="p">(</span><span class="nx">frame</span><span class="o">:</span><span class="nx">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">290</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">becomeFirstResponder</span><span class="p">()</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">placeholder</span> <span class="o">=</span> <span class="s2">&quot;question&quot;</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">keyboardType</span> <span class="o">=</span> <span class="p">.</span><span class="nx">Default</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">returnKeyType</span> <span class="o">=</span> <span class="p">.</span><span class="nx">Done</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">delegate</span> <span class="o">=</span> <span class="nx">self</span>
</span><span class='line'>    <span class="nx">modifyAV</span><span class="p">.</span><span class="nx">containerView</span> <span class="o">=</span> <span class="nx">textField</span>
</span><span class='line'>    <span class="nx">modifyAV</span><span class="p">.</span><span class="nx">buttonTitles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;OK&quot;</span><span class="p">,</span><span class="s2">&quot;Cancel&quot;</span><span class="p">]</span>
</span><span class='line'>    <span class="nx">modifyAV</span><span class="p">.</span><span class="nx">delegate</span> <span class="o">=</span> <span class="nx">self</span>
</span><span class='line'>    <span class="nx">modifyAV</span><span class="p">.</span><span class="nx">useMotionEffects</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'>    <span class="p">(</span><span class="nx">modifyAV</span><span class="p">.</span><span class="nx">containerView</span> <span class="nx">as</span> <span class="nx">UITextField</span><span class="p">).</span><span class="nx">text</span> <span class="o">=</span> <span class="nx">question</span><span class="p">.</span><span class="nx">content</span>
</span><span class='line'>    <span class="nx">modifyAV</span><span class="p">.</span><span class="nx">show</span><span class="p">()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>CustomIOS7AlertView</code>是一个第三方的开源AlertView，它允许我们自定义AlertView的内容，并提供了<code>CustomIOS7AlertViewDelegate</code>协议来用于按钮点击的回调，我们将这两个<code>CustomIOS7AlertView</code>实例的<code>delegate</code>属性都设置为<code>self</code>，然后在<code>MasterViewController</code>中的实现协议中唯一的方法<code>customIOS7dialogButtonTouchUpInside(alertView:AnyObject!, clickedButtonAtIndex buttonIndex:Int)</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="nx">customIOS7dialogButtonTouchUpInside</span><span class="p">(</span><span class="nx">alertView</span><span class="o">:</span><span class="nx">AnyObject</span><span class="o">!</span><span class="p">,</span> <span class="nx">clickedButtonAtIndex</span> <span class="nx">buttonIndex</span><span class="o">:</span><span class="nx">Int</span><span class="p">){</span>
</span><span class='line'>    <span class="k">switch</span> <span class="nx">buttonIndex</span><span class="p">{</span>
</span><span class='line'>        <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">fetchedResultsController</span><span class="p">.</span><span class="nx">managedObjectContext</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">entity</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">fetchedResultsController</span><span class="p">.</span><span class="nx">fetchRequest</span><span class="p">.</span><span class="nx">entity</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">newManagedObject</span><span class="o">:</span><span class="nx">Question</span><span class="o">!</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">av</span> <span class="o">=</span> <span class="nx">alertView</span> <span class="nx">as</span> <span class="nx">CustomIOS7AlertView</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">addAV</span> <span class="o">==</span> <span class="nx">av</span><span class="p">{</span>
</span><span class='line'>            <span class="nx">newManagedObject</span> <span class="o">=</span> <span class="nx">NSEntityDescription</span><span class="p">.</span><span class="nx">insertNewObjectForEntityForName</span><span class="p">(</span><span class="nx">entity</span><span class="p">.</span><span class="nx">name</span><span class="p">,</span> <span class="nx">inManagedObjectContext</span><span class="o">:</span> <span class="nx">context</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">Question</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">modifyAV</span> <span class="o">==</span> <span class="nx">av</span><span class="p">{</span>
</span><span class='line'>            <span class="nx">newManagedObject</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">fetchedResultsController</span><span class="p">.</span><span class="nx">objectAtIndexPath</span><span class="p">(</span><span class="nx">selectedIndexPath</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">Question</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="c1">// If appropriate, configure the new managed object.</span>
</span><span class='line'>        <span class="c1">// Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.</span>
</span><span class='line'>        <span class="nx">newManagedObject</span><span class="p">.</span><span class="nx">content</span> <span class="o">=</span> <span class="p">(</span><span class="nx">av</span><span class="p">.</span><span class="nx">containerView</span> <span class="nx">as</span> <span class="nx">UITextField</span><span class="p">).</span><span class="nx">text</span>
</span><span class='line'>
</span><span class='line'>        <span class="c1">// Save the context.</span>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">error</span><span class="o">:</span> <span class="nx">NSError</span><span class="o">?</span> <span class="o">=</span> <span class="nx">nil</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">!</span><span class="nx">context</span><span class="p">.</span><span class="nx">save</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// Replace this implementation with code to handle the error appropriately.</span>
</span><span class='line'>            <span class="c1">// abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.</span>
</span><span class='line'>            <span class="c1">//println(&quot;Unresolved error \(error), \(error.userInfo)&quot;)</span>
</span><span class='line'>            <span class="nx">abort</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="nx">alertView</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
</span><span class='line'>        <span class="k">default</span><span class="o">:</span>
</span><span class='line'>        <span class="nx">alertView</span><span class="p">.</span><span class="nx">close</span><span class="p">()</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当用户点击<code>alertView</code>的OK按钮时，判断<code>alertView</code>对象是<code>addAV</code>还是<code>modifyAV</code>，然后对应通过不同途径（新插入到<code>ManagedObjectContext</code>还是从<code>ManagedObjectContext</code>中取出）产生<code>Question</code>实例<code>newManagedObject</code>，最后的结果会保存回<code>ManagedObjectContext</code>中，最后关闭<code>alertView</code>。</p>

<p>添加<code>Question</code>时使用的<code>insertNewObjectForEntityForName(entityName: String!, inManagedObjectContext context: NSManagedObjectContext!) -&gt; AnyObject!</code>方法是一个配置和添加实体，并返回该实体对应<code>NSManagedObject</code>子类（在这里是<code>Question</code>类）的便捷方法，这是一个很强大的类方法，我们无需知道创建<code>Question</code>类的细节就能创建并添加一个<code>Question</code>实例到<code>NSManagedObjectContext</code>中，在保存前我们还可以对这个方法返回的<code>Question</code>实例做修改，然后再通过<code>save(error: NSErrorPointer) -&gt; Bool</code>方法保存。</p>

<p>修改<code>Question</code>的过程其实就是先通过<code>objectAtIndexPath(indexPath: NSIndexPath!) -&gt; AnyObject!</code>方法取出数据请求结果当中的某一项并转换成<code>Question</code>对象，对其进行修改后再保存。在界面中通过点击cell右侧带有字母i的蓝色圆圈来修改<code>Question</code>内容：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140438530596.png" alt="" /></p>

<p>上图的中的蓝色圆圈是<code>AccessoryButton</code>，需要在IB中设置<code>TableViewCell</code>的<code>Identifier</code>为<code>QuestionCell</code>，<code>Accessory</code>为<code>Detail Disclosure</code>，这样我们就能在<code>UITableViewDelegate</code>的<code>tableView(tableView: UITableView!, accessoryButtonTappedForRowWithIndexPath indexPath: NSIndexPath!)</code>方法中响应<code>AccessoryButton</code>了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">override</span> <span class="nx">func</span> <span class="nx">tableView</span><span class="p">(</span><span class="nx">tableView</span><span class="o">:</span> <span class="nx">UITableView</span><span class="o">!</span><span class="p">,</span> <span class="nx">accessoryButtonTappedForRowWithIndexPath</span> <span class="nx">indexPath</span><span class="o">:</span> <span class="nx">NSIndexPath</span><span class="o">!</span><span class="p">){</span>
</span><span class='line'>    <span class="nx">selectedIndexPath</span> <span class="o">=</span> <span class="nx">indexPath</span>
</span><span class='line'>    <span class="nx">modifyObject</span><span class="p">(</span><span class="nx">indexPath</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>导航栏右侧的添加<code>Question</code>按钮已经通过下面的代码配置了响应函数：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">addButton</span> <span class="o">=</span> <span class="nx">UIBarButtonItem</span><span class="p">(</span><span class="nx">barButtonSystemItem</span><span class="o">:</span> <span class="p">.</span><span class="nx">Add</span><span class="p">,</span> <span class="nx">target</span><span class="o">:</span> <span class="nx">self</span><span class="p">,</span> <span class="nx">action</span><span class="o">:</span> <span class="s2">&quot;insertNewObject:&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">self</span><span class="p">.</span><span class="nx">navigationItem</span><span class="p">.</span><span class="nx">rightBarButtonItem</span> <span class="o">=</span> <span class="nx">addButton</span>
</span></code></pre></td></tr></table></div></figure>


<p>
在<code>UITableViewDelegate</code>中删除<code>Question</code>的代码如下：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">override</span> <span class="nx">func</span> <span class="nx">tableView</span><span class="p">(</span><span class="nx">tableView</span><span class="o">:</span> <span class="nx">UITableView</span><span class="p">,</span> <span class="nx">commitEditingStyle</span> <span class="nx">editingStyle</span><span class="o">:</span> <span class="nx">UITableViewCellEditingStyle</span><span class="p">,</span> <span class="nx">forRowAtIndexPath</span> <span class="nx">indexPath</span><span class="o">:</span> <span class="nx">NSIndexPath</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">if</span> <span class="nx">editingStyle</span> <span class="o">==</span> <span class="p">.</span><span class="nx">Delete</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">context</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">fetchedResultsController</span><span class="p">.</span><span class="nx">managedObjectContext</span>
</span><span class='line'>        <span class="nx">context</span><span class="p">.</span><span class="nx">deleteObject</span><span class="p">(</span><span class="nx">self</span><span class="p">.</span><span class="nx">fetchedResultsController</span><span class="p">.</span><span class="nx">objectAtIndexPath</span><span class="p">(</span><span class="nx">indexPath</span><span class="p">)</span> <span class="nx">as</span> <span class="nx">NSManagedObject</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'>        <span class="kd">var</span> <span class="nx">error</span><span class="o">:</span> <span class="nx">NSError</span><span class="o">?</span> <span class="o">=</span> <span class="nx">nil</span>
</span><span class='line'>        <span class="k">if</span> <span class="o">!</span><span class="nx">context</span><span class="p">.</span><span class="nx">save</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">error</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>            <span class="c1">// Replace this implementation with code to handle the error appropriately.</span>
</span><span class='line'>            <span class="c1">// abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.</span>
</span><span class='line'>            <span class="c1">//println(&quot;Unresolved error \(error), \(error.userInfo)&quot;)</span>
</span><span class='line'>            <span class="nx">abort</span><span class="p">()</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这里多说一嘴，如果你想打印出错误信息的话，不要直接反注释那行<code>println</code>代码，还需要在<code>error</code>后加上感叹号，因为<code>error</code>是可选类型，需要强制解析：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">println</span><span class="p">(</span><span class="s2">&quot;Unresolved error \(error!), \(error!.userInfo)&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>UITextField键盘响应</h2>

<p>在将<code>UITextField</code>实例赋值给<code>CustomIOS7AlertView</code>的<code>containerView</code>属性前需要先让其获取当前焦点，并将<code>UITextField</code>的<code>delegate</code>属性设为<code>self</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">addAV</span> <span class="o">=</span> <span class="nx">CustomIOS7AlertView</span><span class="p">()</span>
</span><span class='line'><span class="nx">func</span> <span class="nx">insertNewObject</span><span class="p">(</span><span class="nx">sender</span><span class="o">:</span> <span class="nx">AnyObject</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">textField</span> <span class="o">=</span> <span class="nx">UITextField</span><span class="p">(</span><span class="nx">frame</span><span class="o">:</span><span class="nx">CGRectMake</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mi">290</span><span class="p">,</span><span class="mi">50</span><span class="p">))</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">becomeFirstResponder</span><span class="p">()</span><span class="c1">//获取当前焦点</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">placeholder</span> <span class="o">=</span> <span class="s2">&quot;question&quot;</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">keyboardType</span> <span class="o">=</span> <span class="p">.</span><span class="nx">Default</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">returnKeyType</span> <span class="o">=</span> <span class="p">.</span><span class="nx">Done</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">delegate</span> <span class="o">=</span> <span class="nx">self</span>
</span><span class='line'>    <span class="nx">addAV</span><span class="p">.</span><span class="nx">containerView</span> <span class="o">=</span> <span class="nx">textField</span>
</span><span class='line'>    <span class="nx">addAV</span><span class="p">.</span><span class="nx">buttonTitles</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;OK&quot;</span><span class="p">,</span><span class="s2">&quot;Cancel&quot;</span><span class="p">]</span>
</span><span class='line'>    <span class="nx">addAV</span><span class="p">.</span><span class="nx">delegate</span> <span class="o">=</span> <span class="nx">self</span>
</span><span class='line'>    <span class="nx">addAV</span><span class="p">.</span><span class="nx">useMotionEffects</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'>    <span class="nx">addAV</span><span class="p">.</span><span class="nx">show</span><span class="p">()</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>然后让<code>MasterViewController</code>遵循<code>UITextFieldDelegate</code>协议，并实现下面两个协议中的方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="nx">textFieldDidBeginEditing</span><span class="p">(</span><span class="nx">textField</span><span class="o">:</span> <span class="nx">UITextField</span><span class="o">!</span><span class="p">){</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">animationDuration</span><span class="o">:</span><span class="nx">NSTimeInterval</span>  <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">frame</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">frame</span><span class="p">.</span><span class="nx">origin</span><span class="p">.</span><span class="nx">y</span><span class="o">-=</span><span class="mi">116</span>
</span><span class='line'>    <span class="nx">frame</span><span class="p">.</span><span class="nx">size</span><span class="p">.</span><span class="nx">height</span><span class="o">+=</span><span class="mi">116</span>
</span><span class='line'>    <span class="nx">self</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">frame</span> <span class="o">=</span> <span class="nx">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">UIView</span><span class="p">.</span><span class="nx">animateWithDuration</span><span class="p">(</span><span class="nx">animationDuration</span><span class="p">){</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">frame</span> <span class="o">=</span> <span class="nx">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="nx">func</span> <span class="nx">textFieldShouldEndEditing</span><span class="p">(</span><span class="nx">textField</span><span class="o">:</span> <span class="nx">UITextField</span><span class="o">!</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Bool</span><span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">animationDuration</span><span class="o">:</span><span class="nx">NSTimeInterval</span>  <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">frame</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">frame</span><span class="p">.</span><span class="nx">origin</span><span class="p">.</span><span class="nx">y</span><span class="o">+=</span><span class="mi">116</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">frame</span><span class="p">.</span><span class="nx">size</span><span class="p">.</span><span class="nx">height</span><span class="o">-=</span><span class="mi">116</span><span class="p">;</span>
</span><span class='line'>    <span class="nx">self</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">frame</span> <span class="o">=</span> <span class="nx">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="c1">//self.view移回原位置</span>
</span><span class='line'>    <span class="nx">UIView</span><span class="p">.</span><span class="nx">animateWithDuration</span><span class="p">(</span><span class="nx">animationDuration</span><span class="p">){</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">view</span><span class="p">.</span><span class="nx">frame</span> <span class="o">=</span> <span class="nx">frame</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">textField</span><span class="p">.</span><span class="nx">resignFirstResponder</span><span class="p">();</span>
</span><span class='line'>    <span class="k">return</span> <span class="kc">true</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这里我将键盘高度硬编码为116，当<code>UITextField</code>开始编辑时获取焦点键盘弹出，背景上移；当其结束编辑时键盘消失，背景移回原位。</p>

<p>在Xcode6 beta2中的模拟器不是很好使，经常不能弹出键盘，这里给出的代码有很多疏漏，只提供个参考，主要是处理<code>UITextField</code>代理的思想</p>

<h2>随机选择算法</h2>

<p><code>DetailViewController</code>的内容跟<code>MasterViewController</code>内容很像，最大的区别在于多了一个从<code>Choice</code>数据中随机抽选的一个方法。因为是通过摇一摇的方式来触发随机算法，所以我们重载<code>motionBegan(motion: UIEventSubtype, withEvent event: UIEvent!)</code>方法来响应手机摇动：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">override</span> <span class="nx">func</span> <span class="nx">motionBegan</span><span class="p">(</span><span class="nx">motion</span><span class="o">:</span> <span class="nx">UIEventSubtype</span><span class="p">,</span> <span class="nx">withEvent</span> <span class="nx">event</span><span class="o">:</span> <span class="nx">UIEvent</span><span class="o">!</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">motion</span> <span class="o">==</span> <span class="p">.</span><span class="nx">MotionShake</span><span class="p">{</span>
</span><span class='line'>
</span><span class='line'>            <span class="kd">let</span> <span class="nx">count</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">fetchedResultsController</span><span class="p">.</span><span class="nx">fetchedObjects</span><span class="p">.</span><span class="nx">count</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">arr</span> <span class="o">=</span> <span class="nx">fetchedResultsController</span><span class="p">.</span><span class="nx">fetchedObjects</span>
</span><span class='line'>            <span class="kd">var</span> <span class="nx">sum</span><span class="o">:</span><span class="nx">Int</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>            <span class="k">for</span> <span class="nx">object</span> <span class="o">:</span> <span class="nx">AnyObject</span> <span class="k">in</span> <span class="nx">arr</span><span class="p">{</span>
</span><span class='line'>                <span class="nx">sum</span><span class="o">+=</span><span class="p">(</span><span class="nx">object</span> <span class="nx">as</span> <span class="nx">Choice</span><span class="p">).</span><span class="nx">weight</span><span class="p">.</span><span class="nx">integerValue</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="nx">sum</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">{</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">lucknum</span> <span class="o">=</span> <span class="nx">arc4random</span><span class="p">()</span><span class="o">%</span><span class="nx">UInt32</span><span class="p">(</span><span class="nx">sum</span><span class="p">)</span>
</span><span class='line'><span class="c1">//                println(&quot;\(lucknum)&quot;)</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">num</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">n</span><span class="o">:</span><span class="nx">UInt32</span> <span class="o">=</span> <span class="mi">0</span>
</span><span class='line'>                <span class="k">while</span> <span class="nx">lucknum</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">{</span>
</span><span class='line'>                    <span class="k">if</span> <span class="nx">lucknum</span> <span class="o">&lt;=</span> <span class="nx">n</span><span class="p">{</span>
</span><span class='line'>                        <span class="k">break</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                    <span class="k">else</span><span class="p">{</span>
</span><span class='line'>                        <span class="nx">num</span><span class="o">++</span>
</span><span class='line'>                        <span class="nx">lucknum</span><span class="o">-=</span><span class="nx">n</span>
</span><span class='line'>                        <span class="k">if</span> <span class="nx">num</span><span class="o">&gt;=</span><span class="nx">count</span><span class="p">{</span>
</span><span class='line'>                            <span class="k">break</span>
</span><span class='line'>                        <span class="p">}</span>
</span><span class='line'>                        <span class="nx">n</span> <span class="o">=</span> <span class="nx">UInt32</span><span class="p">((</span><span class="nx">arr</span><span class="p">[</span><span class="nx">num</span><span class="p">]</span> <span class="nx">as</span> <span class="nx">Choice</span><span class="p">).</span><span class="nx">weight</span><span class="p">.</span><span class="nx">integerValue</span><span class="p">)</span>
</span><span class='line'>                    <span class="p">}</span>
</span><span class='line'>                <span class="p">}</span>
</span><span class='line'><span class="c1">//                println(&quot;\(num)&quot;)</span>
</span><span class='line'>                <span class="kd">var</span> <span class="nx">alertView</span> <span class="o">=</span> <span class="nx">UIAlertView</span><span class="p">()</span>
</span><span class='line'>                <span class="nx">alertView</span><span class="p">.</span><span class="nx">alertViewStyle</span> <span class="o">=</span> <span class="p">.</span><span class="nx">Default</span>
</span><span class='line'>                <span class="nx">alertView</span><span class="p">.</span><span class="nx">title</span> <span class="o">=</span> <span class="s2">&quot;恭喜&quot;</span>
</span><span class='line'>                <span class="nx">alertView</span><span class="p">.</span><span class="nx">message</span> <span class="o">=</span> <span class="s2">&quot;\(detailItem!.content)的答案是：\n\((arr[num] as Choice).name)&quot;</span>
</span><span class='line'>                <span class="nx">alertView</span><span class="p">.</span><span class="nx">addButtonWithTitle</span><span class="p">(</span><span class="s2">&quot;OK&quot;</span><span class="p">)</span>
</span><span class='line'>                <span class="nx">alertView</span><span class="p">.</span><span class="nx">show</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>前面提到过<code>NSFetchedResultsController</code>对象在执行<code>performFetch(error: NSErrorPointer) -&gt; Bool</code>方法后会将获取的数据存在<code>fetchedObjects</code>数组中，上面这段代码首先获取该问题对应的选项数量，并通过加权运算得到总的权重，然后通过随机数算法生成一个幸运数字，最后计算幸运数字落在哪个选项上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Initialization in Swift]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/24/initialization-in-swift/"/>
    <updated>2014-06-24T09:50:23+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/24/initialization-in-swift</id>
    <content type="html"><![CDATA[<p>本文参考自Swift文档，主要包括以下内容：</p>

<ul>
<li>简介</li>
<li>自定义构造过程</li>
<li>默认构造器</li>
<li>值类型的构造器代理</li>
<li>类的继承和构造过程</li>
<li>通过闭包和函数来设置属性的默认值</li>
</ul>


<p>(2014-8-8更新至beta5语法)</p>

<!--more-->


<h2>简介</h2>

<p>构造过程是为了使用某个类、结构体或枚举类型的实例而进行的准备过程。这个过程包含了为实例中的每个属性设置初始值和为其执行必要的准备和初始化任务。</p>

<p>Swift中的构造器不像Objective-C那样有返回值，但是跟C++有点像：所有的构造器都以<code>init</code>命名，用参数列表来区分各个构造器</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">struct</span> <span class="nx">Fahrenheit</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">temperature</span> <span class="o">=</span> <span class="mf">16.0</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">temperature</span> <span class="o">=</span> <span class="mf">32.0</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">f</span> <span class="o">=</span> <span class="nx">Fahrenheit</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>Fahrenheit</code>是一个结构体，与类一样，Swift中的值类型也有构造器和普通方法。上面的代码先是定义了<code>temperature</code>属性的默认值，然后又在构造器中将其赋值，最后<code>temperature</code>属性的值为32。对于<code>temperature</code>这种存储型属性，无论定义默认值还是在构造器中赋值，最终它们实现的效果是一样的。</p>

<p><strong>给存储型类型属性赋默认值或在初始构造器中设置初始值时，此属性的属性观察者不会被调用</strong></p>

<h2>自定义构造过程</h2>

<p>你可以定义一些带参数的构造器</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">struct</span> <span class="nx">Celsius</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">temperatureInCelsius</span><span class="o">:</span> <span class="nx">Double</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">fromFahrenheit</span> <span class="nx">fahrenheit</span><span class="o">:</span> <span class="nx">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">temperatureInCelsius</span> <span class="o">=</span> <span class="p">(</span><span class="nx">fahrenheit</span> <span class="o">-</span> <span class="mf">32.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">fromKelvin</span> <span class="nx">kelvin</span><span class="o">:</span> <span class="nx">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">temperatureInCelsius</span> <span class="o">=</span> <span class="nx">kelvin</span> <span class="o">-</span> <span class="mf">273.15</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
构造器的参数也跟Swift中的方法定义（注意不是函数）一样，也分内部和外部参数名。上面代码中两个构造器外部参数名不同，调用构造器的时候也是通过外部参数名来区分的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">boilingPointOfWater</span> <span class="o">=</span> <span class="nx">Celsius</span><span class="p">(</span><span class="nx">fromFahrenheit</span><span class="o">:</span> <span class="mf">212.0</span><span class="p">)</span>
</span><span class='line'><span class="c1">// boilingPointOfWater.temperatureInCelsius 是 100.0</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">freezingPointOfWater</span> <span class="o">=</span> <span class="nx">Celsius</span><span class="p">(</span><span class="nx">fromKelvin</span><span class="o">:</span> <span class="mf">273.15</span><span class="p">)</span>
</span><span class='line'><span class="c1">// freezingPointOfWater.temperatureInCelsius 是 0.0”</span>
</span></code></pre></td></tr></table></div></figure>


<p>
如果不写外部参数名那么外部参数名就等于内部参数名：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">struct</span> <span class="nx">Color</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">red</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">green</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">blue</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">red</span><span class="o">:</span> <span class="nx">Double</span><span class="p">,</span> <span class="nx">green</span><span class="o">:</span> <span class="nx">Double</span><span class="p">,</span> <span class="nx">blue</span><span class="o">:</span> <span class="nx">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">red</span>   <span class="o">=</span> <span class="nx">red</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">green</span> <span class="o">=</span> <span class="nx">green</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">blue</span>  <span class="o">=</span> <span class="nx">blue</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">magenta</span> <span class="o">=</span> <span class="nx">Color</span><span class="p">(</span><span class="nx">red</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nx">green</span><span class="o">:</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">blue</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>如果你不希望为构造器的某个参数提供外部名字，你还可以使用下划线<code>_</code>来显示描述它的外部名：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">struct</span> <span class="nx">Celsius</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">temperatureInCelsius</span><span class="o">:</span> <span class="nx">Double</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">fromFahrenheit</span> <span class="nx">fahrenheit</span><span class="o">:</span> <span class="nx">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">temperatureInCelsius</span> <span class="o">=</span> <span class="p">(</span><span class="nx">fahrenheit</span> <span class="o">-</span> <span class="mf">32.0</span><span class="p">)</span> <span class="o">/</span> <span class="mf">1.8</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">fromKelvin</span> <span class="nx">kelvin</span><span class="o">:</span> <span class="nx">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">temperatureInCelsius</span> <span class="o">=</span> <span class="nx">kelvin</span> <span class="o">-</span> <span class="mf">273.15</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">_</span> <span class="nx">celsius</span><span class="o">:</span> <span class="nx">Double</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">temperatureInCelsius</span> <span class="o">=</span> <span class="nx">celsius</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">bodyTemperature</span> <span class="o">=</span> <span class="nx">Celsius</span><span class="p">(</span><span class="mf">37.0</span><span class="p">)</span>
</span><span class='line'><span class="c1">// bodyTemperature.temperatureInCelsius is 37.0</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>你会发现构造器的第一个内部参数名也会默认作为其外部参数名供调用，这一点与方法不同（方法不会默认将第一个内部参数名作为外部参数名使用），因为方法名可以在结尾加上介词来烘托出第一个参数的名字，这样就不需要为第一个参数弄一个外部参数名了，但是构造器只能用<code>init</code>关键字来定义。</p>

<p>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性&mdash;不管是因为它无法在初始化时赋值，还是因为它可以在之后某个时间点可以赋值为空&mdash;你都需要将它定义为可选类型<code>optional type</code>。可选类型的属性将自动初始化为空<code>nil</code>，表示这个属性是故意在初始化时设置为空的。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">SurveyQuestion</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">text</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">response</span><span class="o">:</span> <span class="nb">String</span><span class="o">?</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">text</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="nx">text</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">ask</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">println</span><span class="p">(</span><span class="nx">text</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">cheeseQuestion</span> <span class="o">=</span> <span class="nx">SurveyQuestion</span><span class="p">(</span><span class="nx">text</span><span class="o">:</span> <span class="s2">&quot;Do you like cheese?&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">cheeseQuestion</span><span class="p">.</span><span class="nx">ask</span><span class="p">()</span>
</span><span class='line'><span class="c1">// 输出 &quot;Do you like cheese?&quot;</span>
</span><span class='line'><span class="nx">cheeseQuestion</span><span class="p">.</span><span class="nx">response</span> <span class="o">=</span> <span class="err">&quot;</span><span class="nx">Yes</span><span class="p">,</span> <span class="nx">I</span> <span class="k">do</span> <span class="nx">like</span> <span class="nx">cheese</span><span class="p">.</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>调查问题在问题提出之后，我们才能得到回答。所以我们将属性回答response声明为String?类型，或者说是可选字符串类型optional String。当SurveyQuestion实例化时，它将自动赋值为空nil，表明暂时还不存在此字符串。<br/>
只要在构造过程结束前常量的值能确定，你可以在构造过程中的任意时间点修改常量属性的值。尽管text属性是常量，我们仍然可以在其类的构造器中设置它的值。<strong>对某个类实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</strong></p>

<h2>默认构造器</h2>

<p>Swift将为所有属性已提供默认值的且自身没有定义任何构造器的结构体或基类，提供一个默认的构造器。这个默认构造器将简单的创建一个所有属性值都设置为默认值的实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">ShoppingListItem</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="o">?</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">quantity</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">purchased</span> <span class="o">=</span> <span class="kc">false</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">item</span> <span class="o">=</span> <span class="nx">ShoppingListItem</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>
<code>ShoppingListItem</code>类没有父类（是基类），所有属性都有默认值（可选属性默认值为<code>nil</code>），所以可以直接调用默认的无参数构造器来初始化。<br/>
除上面提到的默认构造器，如果结构体对所有存储型属性提供了默认值且自身没有提供定制的构造器，它们能自动获得一个<strong>逐一成员构造器（Memberwise Initializers）</strong>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">struct</span> <span class="nx">Size</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">twoByTwo</span> <span class="o">=</span> <span class="nx">Size</span><span class="p">(</span><span class="nx">width</span><span class="o">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nx">height</span><span class="o">:</span> <span class="mf">2.0</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>

<h2>值类型的构造器代理</h2>

<p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">struct</span> <span class="nx">Size</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">width</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">height</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">struct</span> <span class="nx">Point</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">struct</span> <span class="nx">Rect</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">origin</span> <span class="o">=</span> <span class="nx">Point</span><span class="p">()</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">size</span> <span class="o">=</span> <span class="nx">Size</span><span class="p">()</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">()</span> <span class="p">{}</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">origin</span><span class="o">:</span> <span class="nx">Point</span><span class="p">,</span> <span class="nx">size</span><span class="o">:</span> <span class="nx">Size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">origin</span> <span class="o">=</span> <span class="nx">origin</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">size</span> <span class="o">=</span> <span class="nx">size</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">center</span><span class="o">:</span> <span class="nx">Point</span><span class="p">,</span> <span class="nx">size</span><span class="o">:</span> <span class="nx">Size</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">originX</span> <span class="o">=</span> <span class="nx">center</span><span class="p">.</span><span class="nx">x</span> <span class="o">-</span> <span class="p">(</span><span class="nx">size</span><span class="p">.</span><span class="nx">width</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="kd">let</span> <span class="nx">originY</span> <span class="o">=</span> <span class="nx">center</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="p">(</span><span class="nx">size</span><span class="p">.</span><span class="nx">height</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">origin</span><span class="o">:</span> <span class="nx">Point</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">originX</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">originY</span><span class="p">),</span> <span class="nx">size</span><span class="o">:</span> <span class="nx">size</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
在值类型中，如果你添加了自定义构造器（如<code>init(center: Point, size: Size)</code>），Swift不会再为结构体生成一个默认构造器和逐一成员构造器，所以我们自己定义了<code>init()</code>和<code>init(origin: Point, size: Size)</code>，他们与自动生成的默认构造器和逐一成员构造器是一样的。这样子会显得很麻烦，我们可以将自定义构造器<code>init(center: Point, size: Size)</code>写在结构体<code>Rect</code>的扩展（<code>extension</code>）里，这样就不用自己把默认构造器和逐一成员构造器写一遍了。</p>

<p>构造器<code>init(center:size:)</code>先通过<code>center</code>和<code>size</code>的值计算出<code>origin</code>的坐标。然后再调用（或代理给）<code>init(origin:size:)</code>构造器来将新的<code>origin</code>和<code>size</code>值赋值到对应的属性中。因为值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给本身提供的其它构造器：你只能在构造器内部调用<code>self.init</code></p>

<h2>类的继承和构造过程</h2>

<p>类里面的所有存储型属性&mdash;包括所有继承自父类的属性&mdash;都必须在构造过程中设置初始值。</p>

<p>Swift 提供了两种类型的类构造器来确保所有类实例中存储型属性都能获得初始值，它们分别是指定构造器(<code>Designated Initializers</code>)和便利构造器(<code>Convenience Initializers</code>)。</p>

<h3>指定构造器和便利构造器</h3>

<p>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。<strong>每一个类都必须拥有至少一个指定构造器。</strong></p>

<p>便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入的实例。</p>

<p>类的指定构造器的写法跟值类型简单构造器一样，便利构造器也采用相同样式的写法，但需要在<code>init</code>关键字之前放置<code>convenience</code>关键字：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">convenience</span> <span class="nx">init</span><span class="p">(</span><span class="nx">parameters</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">statements</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>构造器链</h3>

<p>为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：</p>

<ol>
<li>指定构造器必须调用其直接父类的的指定构造器。</li>
<li>便利构造器必须调用同一类中定义的其它构造器。</li>
<li>便利构造器必须最终以调用一个指定构造器结束。</li>
</ol>


<p>一个更方便记忆的方法是:</p>

<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializerDelegation01_2x.png" alt="" />
举个栗子：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Food</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">convenience</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;[Unnamed]&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">namedMeat</span> <span class="o">=</span> <span class="nx">Food</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Bacon&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// namedMeat 的名字是 &quot;Bacon”</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">mysteryMeat</span> <span class="o">=</span> <span class="nx">Food</span><span class="p">()</span>
</span><span class='line'><span class="c1">// mysteryMeat 的名字是 [Unnamed]</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample01_2x.png" alt="" /></p>

<h3>两段式构造过程</h3>

<p>Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性通过引入它们的类的构造器来设置初始值。当每一个存储型属性值被确定后，第二阶段开始，它给每个类一次机会在新实例准备使用之前进一步定制它们的存储型属性。<br/>
下图展示了在假定的子类和父类之间构造的阶段1：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/twoPhaseInitialization01_2x.png" alt="" /></p>

<p>指定构造器将确保所有子类的属性都有值，然后它将调用父类的指定构造器，并沿着造器链一直往上完成父类的构建过程。一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，而阶段1也已完成。</p>

<p>以下展示了相同构造过程的阶段2：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/twoPhaseInitialization02_2x.png" alt="" /></p>

<p>父类中的指定构造器现在有机会进一步来定制实例（尽管它没有这种必要）。</p>

<p>一旦父类中的指定构造器完成调用，子类的构指定构造器可以执行更多的定制操作（同样，它也没有这种必要）。</p>

<p>最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。</p>

<p>两段式构造过程是基于<strong>安全检查</strong>的，可以简单的理解为：</p>

<ul>
<li>指定构造器初始化顺序：初始化类自己引入的属性->向上代理调用父类指定构造器->为继承的属性设置新值</li>
<li>便利构造器初始化顺序：代理调用同一类中的其它构造器->为任意属性赋新值</li>
<li>构造器在第一阶段构造完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用self的值。</li>
</ul>


<h3>构造器的继承和重载</h3>

<p><strong>跟 Objective-C 中的子类不同，Swift 中的子类不会默认继承父类的构造器。</strong>这是为了防止你想初始化一个很牛逼的类，但是调用的却是它继承于父类的菜逼构造器，那将会是个悲剧。</p>

<p><strong>但是如果特定条件可以满足，父类构造器是可以被自动继承的：</strong></p>

<ol>
<li>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</li>
<li>如果子类提供了所有父类指定构造器的实现&mdash;不管是通过规则1继承过来的，还是通过自定义实现的&mdash;它将自动继承所有父类的便利构造器。</li>
</ol>


<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。子类可以通过定义便利构造器来实现父类中的指定构造器，来部分满足规则2</p>

<p>如果你需要在子类中重写一个父类的指定构造器（包括自动生成的默认构造器），无论子类中的构造器是指定构造器还是便利构造器，都需要在子类定义重载的构造器前加上<code>override</code>修饰；如果你需要在子类中重写一个父类的便利构造器，根据构造器链，父类的便利构造器不会被子类直接调用，所以不必在子类重写构造器的定义前用<code>override</code>修饰。这是Xcode6beta5新修订的规则，在以前的版本中重载构造器不用<code>override</code>修饰。</p>

<p>还记得之前指定的<code>Food</code>类吧，现在它多了一个子类<code>RecipeIngredient</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">RecipeIngredient</span><span class="o">:</span> <span class="nx">Food</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">quantity</span><span class="o">:</span> <span class="nx">Int</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">quantity</span><span class="o">:</span> <span class="nx">Int</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">quantity</span> <span class="o">=</span> <span class="nx">quantity</span>
</span><span class='line'>        <span class="kr">super</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nx">name</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">override</span> <span class="nx">convenience</span> <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nx">name</span><span class="p">,</span> <span class="nx">quantity</span><span class="o">:</span> <span class="mi">1</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
可以看出来<code>RecipeIngredient</code>类的指定构造器和便利构造器都符合两段式构造安全检查，并且便利构造器跟<code>Food</code>类中的指定构造器具有相同的参数，尽管<code>RecipeIngredient</code>这个构造器是便利构造器，<code>RecipeIngredient</code>依然提供了对所有父类指定构造器的实现。因此，<code>RecipeIngredient</code>也能自动继承了所有父类的便利构造器(也就是<code>init()</code>):</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample02_2x.png" alt="" /></p>

<p>上图中<code>RecipeIngredient</code>类继承的init()函数版本跟Food提供的版本是一样的，除了它是将任务代理给RecipeIngredient版本的init(name: String)而不是Food提供的版本。</p>

<p>食材都已经建立好了，下面开始采购吧！我们需要一个购物单，购物单中每一项是这样子的：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">ShoppingListItem</span><span class="o">:</span> <span class="nx">RecipeIngredient</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">purchased</span> <span class="o">=</span> <span class="kc">false</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">description</span><span class="o">:</span> <span class="nb">String</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">output</span> <span class="o">=</span> <span class="s2">&quot;\(quantity) x \(name.lowercaseString)&quot;</span>
</span><span class='line'>        <span class="nx">output</span> <span class="o">+=</span> <span class="nx">purchased</span> <span class="o">?</span> <span class="s2">&quot; ✔&quot;</span> <span class="o">:</span> <span class="s2">&quot; ✘&quot;</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">output</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，ShoppingListItem将自动继承所有父类中的指定构造器和便利构造器。</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample03_2x.png" alt="" /></p>

<p>你可以使用全部三个继承来的构造器来创建ShoppingListItem的新实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">breakfastList</span> <span class="o">=</span> <span class="p">[</span>
</span><span class='line'>    <span class="nx">ShoppingListItem</span><span class="p">(),</span>
</span><span class='line'>    <span class="nx">ShoppingListItem</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Bacon&quot;</span><span class="p">),</span>
</span><span class='line'>    <span class="nx">ShoppingListItem</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Eggs&quot;</span><span class="p">,</span> <span class="nx">quantity</span><span class="o">:</span> <span class="mi">6</span><span class="p">),</span>
</span><span class='line'><span class="p">]</span>
</span><span class='line'><span class="nx">breakfastList</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">name</span> <span class="o">=</span> <span class="s2">&quot;Orange juice&quot;</span>
</span><span class='line'><span class="nx">breakfastList</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">purchased</span> <span class="o">=</span> <span class="kc">true</span>
</span><span class='line'><span class="k">for</span> <span class="nx">item</span> <span class="k">in</span> <span class="nx">breakfastList</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="nx">item</span><span class="p">.</span><span class="nx">description</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 1 x orange juice ✔</span>
</span><span class='line'><span class="c1">// 1 x bacon ✘</span>
</span><span class='line'><span class="c1">// 6 x eggs ✘</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>必需构造器</h3>

<p>当你想让一个类的某个构造器被所有子类都实现，你可以在定义这个构造器时在前面用<code>required</code>修饰：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">SomeClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">required</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// initializer implementation goes here</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>你也必须在它的子类定义必需构造器前用<code>required</code>修饰，但不必用<code>override</code>修饰：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">SomeSubClass</span><span class="o">:</span> <span class="nx">SomeClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">required</span> <span class="nx">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// subclass implementation of the required initializer goes here</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这样的语法可以将这种“必需”信号传递给未来更多的子类，表明这个构造器一定要实现，千秋万代~</p>

<p>当然你可以满足构造器的继承规则来继承必需构造器，这样就不用“必须”重写“必需”构造器了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">SomeSubSubClass</span><span class="o">:</span><span class="nx">SomeSubClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">convenience</span> <span class="nx">init</span><span class="p">(</span><span class="nx">a</span><span class="o">:</span><span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">init</span><span class="p">()</span>
</span><span class='line'>        <span class="c1">//subsubclass implementation of a convenience initializer goes here</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>通过闭包和函数来设置属性的默认值</h2>

<p>如果某个存储型属性的默认值需要特别的定制或准备，你就可以使用闭包或全局函数来为其属性提供定制的默认值。每当某个属性所属的新类型实例创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">SomeClass</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">someProperty</span><span class="o">:</span> <span class="nx">SomeType</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="c1">// 在这个闭包中给 someProperty 创建一个默认值</span>
</span><span class='line'>        <span class="c1">// someValue 必须和 SomeType 类型相同</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">someValue</span>
</span><span class='line'>        <span class="p">}()</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>注意闭包结尾的大括号后面接了一对空的小括号。这是用来告诉 Swift 需要立刻执行此闭包。如果你忽略了这对括号，相当于是将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>

<p>如果你使用闭包来初始化属性的值，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能够在闭包里访问其它的属性，就算这个属性有默认值也不允许。同样，你也不能使用隐式的self属性，或者调用其它的实例方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[让软件支持Retina]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/19/rang-ruan-jian-zhi-chi-retina/"/>
    <updated>2014-06-19T16:07:28+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/19/rang-ruan-jian-zhi-chi-retina</id>
    <content type="html"><![CDATA[<ol>
<li>右键单击程序，选择“显示包内容”</li>
<li>找到“info.plist”文件并打开</li>
<li>如果用Xcode打开：添加一个新的键值对，类型为Boolean，Key为“NSHighResolutionCapable”，Value选择“YES”；如果用其他软件打开，直接在plist节点中的dict中添加一个键值对就可以：<key>NSHighResolutionCapable</key><br/>
<true/></li>
<li>为了使系统更新，复制一份“软件.app”，改成别的名字如“软件1.app”，删除原来的“软件.app”，再把“软件1.app”重命名为“软件.app”</li>
</ol>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optionals and Optional Chaining in Swift]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/17/optionals-and-optional-chaining-in-swift/"/>
    <updated>2014-06-17T20:42:17+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/17/optionals-and-optional-chaining-in-swift</id>
    <content type="html"><![CDATA[<p>可选类型（<code>Optionals</code>）在Swift中用于处理值可能缺失的情况，也就是说可能存在没有值的情况。C 和 Objective-C 中并没有可选类型这个概念。但在Objective-C中，一个方法的返回值可以是一个对象或<code>nil</code>值（<code>nil</code>表示缺少一个合法对象），而对象只是针对类而言，结构体、基本C类型和枚举并不适用<code>nil</code>来表示值的缺失，对于这些类型，Objective-C 方法一般会返回一个特殊值（比如<code>NSNotFound</code>）来暗示值缺失。这种表示“值缺失”方法不统一的局面使得调用方法的程序员蛋疼了-需要针对不同情况进行处理-但随着可选类型的诞生，这种情形在Swift中得到解决，<code>Optionals</code>可以表示任意类型值的缺失。(2014-8-8更新至beta5语法)</p>

<!--more-->


<h2>可选类型（Optionals）</h2>

<h3>理论</h3>

<p><strong>Xcode6beta5发布后，<code>Optional</code>的定义有了修改：</strong></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>enum Optional&lt;T&gt; : Reflectable, NilLiteralConvertible {
</span><span class='line'>    case None
</span><span class='line'>    case Some(T)
</span><span class='line'>    init()
</span><span class='line'>    init(_ some: T)
</span><span class='line'>    var hasValue: Bool { get }
</span><span class='line'>
</span><span class='line'>    /// Haskell's fmap, which was mis-named
</span><span class='line'>    func map&lt;U&gt;(f: (T) -&gt; U) -&gt; U?
</span><span class='line'>    func getMirror() -&gt; MirrorType
</span><span class='line'>    static func convertFromNilLiteral() -&gt; T?
</span><span class='line'>}</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>可选类型是本质是一个枚举类型，包含两个成员：<code>None</code>和<code>Some</code>，其中<code>Some</code>成员还有一个类型为泛型<code>T</code>的关联值（Associated Values）。</p>

<p>光凭猜测大约知道：当可选类型有值的时候其实是<code>Some</code>成员，并在构造器<code>init(_ some: T)</code>调用时将值存储在<code>Some</code>成员的关联值中，此时<code>getLogicValue()</code>方法返回true；当可选类型没有值的时候其实是<code>None</code>成员，并在构造器<code>init()</code>调用时将<code>nil</code>给了<code>None</code>成员，具体细节不是很清楚。</p>

<p>看得出可选类型的设计借鉴了Haskell语言，至于<code>nil</code>这个字面量到底是什么：</p>

<p>Swift 的<code>nil</code>和 Objective-C 中的<code>nil</code>并不一样。在 Objective-C 中，<code>nil</code>是一个指向不存在对象的指针。在 Swift 中，<code>nil</code>不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选值都可以被设置为<code>nil</code>，不只是对象（object）类型。</p>

<p><strong>可选类型默认值为<code>nil</code></strong></p>

<h3>if条件判断和强制解析</h3>

<p>在Swift中，有时候需要把内容为数字的字符串转化成数字：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">possibleNumber</span> <span class="o">=</span> <span class="s2">&quot;123&quot;</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">convertedNumber</span> <span class="o">=</span> <span class="nx">possibleNumber</span><span class="p">.</span><span class="nx">toInt</span><span class="p">()</span>
</span><span class='line'><span class="c1">// convertedNumber 被推测为类型 &quot;Int?&quot;， 或者类型 &quot;optional Int&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>因为Swift是类型安全的语言，为了保证转化过程中不出错，<code>toInt()</code>方法返回的是一个<code>Optional&lt;Int&gt;</code>(也可写成<code>Int?</code>)类型的实例。如果被转化的字符串不是一个数字（比如是“hello world”），那样<code>toInt()</code>返回的内容将不含有<code>Int</code>值。这保证了整个过程不报错，下面我们可以“优雅的”检查下<code>convertedNumber</code>是否有<code>Int</code>值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="nx">convertedNumber</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;convertedNumber has an integer value of \(convertedNumber!).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 输出 &quot;123 has an integer value of 123&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的<strong>强制解析（forced unwrapping）</strong></p>

<p>PS：beta5中去掉了<code>LogicValue</code>协议，并用<code>hasValue</code>替代它来存储是否有值。也就是<code>Optional</code>不会隐式转换成<code>Bool</code>，在条件判断语句中需要用<code>==</code>或<code>!=</code>来判断是否为空。苹果取消了<code>Optional</code>的隐式<code>Bool</code>值是为了防止混淆。（新手可以无视这段话，我在讲述Swift的变更史，哈哈）</p>

<h3>可选绑定</h3>

<p>除了用if语句判断和强制解析来获取可选类型中的值，还可以用<strong>可选绑定</strong>的方式来来判断可选类型是否包含值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="kd">let</span> <span class="nx">constantName</span> <span class="o">=</span> <span class="nx">someOptional</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">statements</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
于是之前的例子可以可以改写为：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="kd">let</span> <span class="nx">actualNumber</span> <span class="o">=</span> <span class="nx">possibleNumber</span><span class="p">.</span><span class="nx">toInt</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;\(possibleNumber) has an integer value of \(actualNumber)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;\(possibleNumber) could not be converted to an integer&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 输出 &quot;123 has an integer value of 123&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>如果<code>possibleNumber.toInt</code>返回的可选<code>Int</code>包含一个值，创建一个叫做<code>actualNumber</code>的新常量并将可选包含的值赋给它。它已经被可选类型包含的值初始化过，所以不需要再使用<code>!</code>后缀来获取它的值。</p>

<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。这种类型的可选状态被定义为<strong>隐式解析可选类型</strong>（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（<code>String?</code>）改成感叹号（<code>String!</code>）来声明一个隐式解析可选类型。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">possibleString</span><span class="o">:</span> <span class="nb">String</span><span class="o">?</span> <span class="o">=</span> <span class="s2">&quot;An optional string.&quot;</span>
</span><span class='line'><span class="nx">println</span><span class="p">(</span><span class="nx">possibleString</span><span class="o">!</span><span class="p">)</span> <span class="c1">// 需要惊叹号来获取值</span>
</span><span class='line'><span class="c1">// 输出 &quot;An optional string.&quot;</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">assumedString</span><span class="o">:</span> <span class="nb">String</span><span class="o">!</span> <span class="o">=</span> <span class="s2">&quot;An implicitly unwrapped optional string.&quot;</span>
</span><span class='line'><span class="nx">println</span><span class="p">(</span><span class="nx">assumedString</span><span class="p">)</span>  <span class="c1">// 不需要感叹号</span>
</span><span class='line'><span class="c1">// 输出 &quot;An implicitly unwrapped optional string.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="nx">assumedString</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="nx">assumedString</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 输出 &quot;An implicitly unwrapped optional string.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="kd">let</span> <span class="nx">definiteString</span> <span class="o">=</span> <span class="nx">assumedString</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="nx">definiteString</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 输出 &quot;An implicitly unwrapped optional string.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
可能看到这里你会觉得隐式解析可选类型的存在意义是什么？为何不直接用普通的非可选类型呢？其实<code>Implicitly Unwrapped Optionals</code>被用于类的初始化方法中，避免循环引用:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Country</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">capitalCity</span><span class="o">:</span> <span class="nx">City</span><span class="o">!</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">capitalName</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">capitalCity</span> <span class="o">=</span> <span class="nx">City</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nx">capitalName</span><span class="p">,</span> <span class="nx">country</span><span class="o">:</span> <span class="nx">self</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">class</span> <span class="nx">City</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="nx">unowned</span> <span class="kd">let</span> <span class="nx">country</span><span class="o">:</span> <span class="nx">Country</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">country</span><span class="o">:</span> <span class="nx">Country</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">country</span> <span class="o">=</span> <span class="nx">country</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kd">var</span> <span class="nx">country</span> <span class="o">=</span> <span class="nx">Country</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Canada&quot;</span><span class="p">,</span> <span class="nx">capitalName</span><span class="o">:</span> <span class="s2">&quot;Ottawa&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">println</span><span class="p">(</span><span class="s2">&quot;\(country.name)&#39;s capital city is called \(country.capitalCity.name)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;Canada&#39;s capital city is called Ottawa”</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>因为编译器会将其认为默认<code>nil</code>，不需赋值就可以完成类的初始化，在例子中<code>capitalCity</code>还没被赋值时<code>Country</code>类就已经初始化并可以被引用；这样就能实现一行代码建立<code>Country</code>和<code>City</code>实例而不造成强引用循环。有关ARC的更多知识可以看看这篇<a href="http://yulingtianxia.com/blog/2014/06/17/swiftzhong-de-arc/">文章</a></p>

<h3>Nil Coalescing Operator</h3>

<p><code>??</code>是beta5新加入的一个二元运算符，<code>a ?? b</code>相当于<code>a != nil ? a! : b</code>的简写。也就是如果<code>a</code>是有值就返回<code>a</code>的值，否则返回<code>b</code>的值。</p>

<h2>可选链（Optional Chaining）</h2>

<p>可选链（Optional Chaining）是一种可以请求和调用属性、方法及下标的过程，它的可选性体现于请求或调用的目标当前可能为空（<code>nil</code>）。如果可选的目标有值，那么调用就会成功；相反，如果选择的目标为空（<code>nil</code>），则这种调用将返回空（<code>nil</code>）。多次请求或调用可以被链接在一起形成一个链，如果任何一个节点为空（<code>nil</code>）将导致整个链失效。</p>

<p>可能官方的定义不接地气，先来个例子做铺垫：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">residence</span><span class="o">:</span> <span class="nx">Residence</span><span class="o">?</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">class</span> <span class="nx">Residence</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">rooms</span> <span class="o">=</span> <span class="p">[</span><span class="nx">Room</span><span class="p">]()</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">numberOfRooms</span><span class="o">:</span> <span class="nx">Int</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="nx">rooms</span><span class="p">.</span><span class="nx">count</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">subscript</span><span class="p">(</span><span class="nx">i</span><span class="o">:</span> <span class="nx">Int</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Room</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">get</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">rooms</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="nx">set</span> <span class="p">{</span>
</span><span class='line'>            <span class="nx">rooms</span><span class="p">[</span><span class="nx">i</span><span class="p">]</span> <span class="o">=</span> <span class="nx">newValue</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">printNumberOfRooms</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;The number of rooms is \(numberOfRooms)&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">address</span><span class="o">:</span> <span class="nx">Address</span><span class="o">?</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">class</span> <span class="nx">Room</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">class</span> <span class="nx">Address</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">buildingName</span><span class="o">:</span> <span class="nb">String</span><span class="o">?</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">buildingNumber</span><span class="o">:</span> <span class="nb">String</span><span class="o">?</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">street</span><span class="o">:</span> <span class="nb">String</span><span class="o">?</span>
</span><span class='line'>    <span class="nx">func</span> <span class="nx">buildingIdentifier</span><span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">String</span><span class="o">?</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="nx">buildingName</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">buildingName</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="nx">buildingNumber</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">buildingNumber</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="nx">nil</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>人（<code>Person</code>）可能会拥有住所（<code>Residence</code>），一个住所肯定会有一些带名字的房间（<code>Room</code>），还有可能注明所在地址（<code>Address</code>）。住所还提供了获取房间数目的方法，并能通过下标访问某个房间，而地址包含了一些可选的信息。</p>

<p>PS：不要嫌我墨迹，官方文档比我墨迹多了。。。</p>

<p>现在我造个人（邪恶的孩子面壁思过去！），就叫john</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">john</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">()</span>
</span></code></pre></td></tr></table></div></figure>


<p>
如果我们想知道john同学家房子大不大，有几个房间啊？但是直接问不太好，万一john家里穷漂泊不定四海为家，那不就玩脱了么？</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">roomCount</span> <span class="o">=</span> <span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">!</span><span class="p">.</span><span class="nx">numberOfRooms</span>
</span><span class='line'><span class="c1">//将导致运行时错误</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>所以还是先问问他家有没有房子吧：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="kd">let</span> <span class="nx">roomCount</span> <span class="o">=</span> <span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">?</span><span class="p">.</span><span class="nx">numberOfRooms</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;John&#39;s residence has \(roomCount) room(s).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;我造john的时候没给他分房子，这可怜孩子！&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 打印 &quot;我造john的时候没给他分房子，这可怜孩子！&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
可选链提供了一种另一种获得<code>numberOfRooms</code>的方法。利用可选链，使用<code>?</code>来代替原来<code>!</code>的位置，因为这种尝试获得<code>numberOfRooms</code>的操作有可能失败，可选链会返回<code>Int?</code>类型值。要注意的是，虽然<code>numberOfRooms</code>是非可选<code>Int</code>，这一点也成立。只要是通过可选链的请求就意味着最后<code>numberOfRooms</code>总是返回一个<code>Int?</code>而不是<code>Int</code>。</p>

<p>反过来我们也可以通过可选链给属性赋值，比如当我们还不确定john有没有房子的时候就给人家房子规定好地址：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">someAddress</span> <span class="o">=</span> <span class="nx">Address</span><span class="p">()</span>
</span><span class='line'><span class="nx">someAddress</span><span class="p">.</span><span class="nx">buildingNumber</span> <span class="o">=</span> <span class="s2">&quot;29&quot;</span>
</span><span class='line'><span class="nx">someAddress</span><span class="p">.</span><span class="nx">street</span> <span class="o">=</span> <span class="s2">&quot;Acacia Road&quot;</span>
</span><span class='line'><span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">?</span><span class="p">.</span><span class="nx">address</span> <span class="o">=</span> <span class="nx">someAddress</span>
</span></code></pre></td></tr></table></div></figure>


<p>
现在<code>john.residence</code>还是<code>nil</code>，所以给它的<code>address</code>属性赋值只会引起地产商的不满-赋值会失败-好在这种“不满”并不会让程序崩溃。</p>

<p>我们也可以在可选链上调用方法：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">?</span><span class="p">.</span><span class="nx">printNumberOfRooms</span><span class="p">()</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;It was possible to print the number of rooms.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;It was not possible to print the number of rooms.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 打印 &quot;It was not possible to print the number of rooms.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>虽然<code>printNumberOfRooms</code>方法无返回值，但是它有一个隐式的返回类型<code>Void</code>，在可选链上调用后返回类型就成了<code>Void?</code>，既然是可选类型，就可以放到if语句条件判断中啦！</p>

<p>其实在可选链上给属性赋值也会返回类型为<code>Void?</code>的值，我们可以判断下返回值是否为<code>nil</code>，这样就知道赋值操作是否成功：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="p">(</span><span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">?</span><span class="p">.</span><span class="nx">address</span> <span class="o">=</span> <span class="nx">someAddress</span><span class="p">)</span> <span class="o">!=</span> <span class="nx">nil</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;房子选址成功&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;地产商再次不满！&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;地产商再次不满！&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>博主你够了地产商快被你玩坏了，好吧换个话题：</p>

<p>接下来想看看john家第一间房子名字叫啥，但却怕人家没房子遭遇尴尬，不用怕：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="kd">let</span> <span class="nx">firstRoomName</span> <span class="o">=</span> <span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">name</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;The first room name is \(firstRoomName).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;连房子都没有更别提第一间房间名了！&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 打印 &quot;连房子都没有更别提第一间房间名了！&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在下标调用中可选链的问号直接跟在<code>john.residence</code>的后面，在下标中括号的前面，因为<code>john.residence</code>才是可选链试图获得的可选值。（关键是<code>Person</code>不一定有<code>residence</code>，但<code>Residence</code>肯定有<code>rooms</code>）</p>

<p>但是如果下标的值本来就是可选值（如果<code>Residence</code>不一定有9号房间，正如Swift中的Dictionary类型，下标给定的key不一定能返回value：<code>subscript (key: Key) -&gt; Value?</code>），那么我们在存取下标的时候需要在下标右中括号的右边标记<code>?</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">testScores</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;Dave&quot;</span><span class="o">:</span> <span class="p">[</span><span class="mi">86</span><span class="p">,</span> <span class="mi">82</span><span class="p">,</span> <span class="mi">84</span><span class="p">],</span> <span class="s2">&quot;Tim&quot;</span><span class="o">:</span> <span class="p">[</span><span class="mi">79</span><span class="p">,</span> <span class="mi">94</span><span class="p">,</span> <span class="mi">81</span><span class="p">]]</span>
</span><span class='line'><span class="nx">testScores</span><span class="p">[</span><span class="s2">&quot;Dave&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">91</span>
</span><span class='line'><span class="nx">testScores</span><span class="p">[</span><span class="s2">&quot;Tim&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">++</span>
</span><span class='line'><span class="nx">testScores</span><span class="p">[</span><span class="s2">&quot;Brian&quot;</span><span class="p">]</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="mi">72</span>
</span><span class='line'><span class="c1">// the &quot;Dave&quot; array is now [91, 82, 84] and the &quot;Tim&quot; array is now [80, 94, 81]&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
显而易见“Brian”并不存在，更别提把它当做数组并给第一个元素赋值了。华丽丽的失败。</p>

<p>类似前面用可选链给属性赋值，也可以给下标赋值：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="nx">Room</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Bathroom&quot;</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>当然这不会成功，因为john没房子！</p>

<p>造个john还玩了人家这么久，还不快给人家分套房子！（其实是为了演示后面的<code>Address</code>）</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">johnsHouse</span> <span class="o">=</span> <span class="nx">Residence</span><span class="p">()</span>
</span><span class='line'><span class="nx">johnsHouse</span><span class="p">.</span><span class="nx">rooms</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">Room</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Living Room&quot;</span><span class="p">))</span>
</span><span class='line'><span class="nx">johnsHouse</span><span class="p">.</span><span class="nx">rooms</span><span class="p">.</span><span class="nx">append</span><span class="p">(</span><span class="nx">Room</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Kitchen&quot;</span><span class="p">))</span>
</span><span class='line'><span class="nx">john</span><span class="p">.</span><span class="nx">residence</span> <span class="o">=</span> <span class="nx">johnsHouse</span>
</span><span class='line'>
</span><span class='line'><span class="k">if</span> <span class="kd">let</span> <span class="nx">firstRoomName</span> <span class="o">=</span> <span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">?</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">name</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;The first room name is \(firstRoomName).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;Unable to retrieve the first room name.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;The first room name is Living Room.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>现在john乔迁新居奔小康了，快问问他家地址，好串个门</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">johnsAddress</span> <span class="o">=</span> <span class="nx">Address</span><span class="p">()</span>
</span><span class='line'><span class="nx">johnsAddress</span><span class="p">.</span><span class="nx">buildingName</span> <span class="o">=</span> <span class="s2">&quot;The Larches&quot;</span>
</span><span class='line'><span class="nx">johnsAddress</span><span class="p">.</span><span class="nx">street</span> <span class="o">=</span> <span class="s2">&quot;Laurel Street&quot;</span>
</span><span class='line'><span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">!</span><span class="p">.</span><span class="nx">address</span> <span class="o">=</span> <span class="nx">johnsAddress</span>
</span><span class='line'><span class="k">if</span> <span class="kd">let</span> <span class="nx">johnsStreet</span> <span class="o">=</span> <span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">?</span><span class="p">.</span><span class="nx">address</span><span class="o">?</span><span class="p">.</span><span class="nx">street</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;John&#39;s street name is \(johnsStreet).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;Unable to retrieve the address.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 打印 &quot;John&#39;s street name is Laurel Street.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>值得注意的是<code>john.residence</code>属性是一个可选类型并且已经不为<code>nil</code>(刚刚奔小康了嘛)，因此你需要在它获取<code>address</code>属性之前使用<code>!</code>强制解析以获得它的实际值。</p>

<p>虽然这条可选链上有两个问号（两层可选链），但其返回类型依然是可选类型（<code>String?</code>），而不是可选类型的嵌套（<code>String??</code>即<code>Optional&lt;Optional&lt;String&gt;&gt;</code>）。你可以将多层可选链连接在一起，可以掘取模型内更下层的属性方法和下标。然而多层可选链不能再添加比已经返回的可选值更多的层。 也就是说：</p>

<p><strong>如果你试图获得的类型不是可选类型，由于使用了可选链它将变成可选类型。 如果你试图获得的类型已经是可选类型，由于可选链它也不会提高可选性。</strong></p>

<p>前面的例子解释了如何通过可选链来获得可选类型属性值。你也可以通过可选链调用一个返回可选类型值的方法并按需链接该方法的返回值。 如上所述，<code>buildingIdentifier</code>方法在可选链调用后最终的返回值类型依然是<code>String?</code>:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="kd">let</span> <span class="nx">buildingIdentifier</span> <span class="o">=</span> <span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">?</span><span class="p">.</span><span class="nx">address</span><span class="o">?</span><span class="p">.</span><span class="nx">buildingIdentifier</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;John&#39;s building identifier is \(buildingIdentifier).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 打印 &quot;John&#39;s building identifier is The Larches.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
如果你还想进一步对方法返回值执行可选链，将可选链问号符放在方法括号的后面：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="k">if</span> <span class="kd">let</span> <span class="nx">upper</span> <span class="o">=</span> <span class="nx">john</span><span class="p">.</span><span class="nx">residence</span><span class="o">?</span><span class="p">.</span><span class="nx">address</span><span class="o">?</span><span class="p">.</span><span class="nx">buildingIdentifier</span><span class="p">()</span><span class="o">?</span><span class="p">.</span><span class="nx">uppercaseString</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;John&#39;s uppercase building identifier is \(upper).&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// 打印 &quot;John&#39;s uppercase building identifier is THE LARCHES.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
你将可选链问号符放在括号后面是因为你想要链接的可选值是<code>buildingIdentifier</code>方法的返回值，不是<code>buildingIdentifier</code>方法本身。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中的ARC]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/17/swiftzhong-de-arc/"/>
    <updated>2014-06-17T10:32:38+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/17/swiftzhong-de-arc</id>
    <content type="html"><![CDATA[<p>Objective-C中的ARC被Swift很好的继承下来了，本文参考自Swift文档网上的翻译，主要重点记录下Swift中的ARC与OC对比需要注意的地方。(2014-8-8更新至beta5语法)</p>

<!--more-->


<h2>简介</h2>

<p>当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>

<h2>类实例之间强引用循环的产生</h2>

<p>如果你对OC中的强引用循环很了解，可以直接跳过这节。</p>

<p>但是如果两个类的实例之间互相引用，这样就产生了强引用循环。下面展示了一个不经意产生强引用循环的例子。例子定义了两个类：<code>Person</code>和<code>Apartment</code>，用来建模公寓和它其中的居民:</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="p">}</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">apartment</span><span class="o">:</span> <span class="nx">Apartment</span><span class="o">?</span>
</span><span class='line'>    <span class="nx">deinit</span> <span class="p">{</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="kr">class</span> <span class="nx">Apartment</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">number</span><span class="o">:</span> <span class="nx">Int</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">number</span><span class="o">:</span> <span class="nx">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">number</span> <span class="o">=</span> <span class="nx">number</span> <span class="p">}</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">tenant</span><span class="o">:</span> <span class="nx">Person</span><span class="o">?</span>
</span><span class='line'>    <span class="nx">deinit</span> <span class="p">{</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;Apartment #\(number) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>接下来的代码片段定义了两个可选类型的变量<code>john</code>和<code>number73</code>,并分别被设定为下面的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为<code>nil</code>，并为可选的（让它们可选是为了以后能销毁，为了演示程序）：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">john</span><span class="o">:</span> <span class="nx">Person</span><span class="o">?</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">number73</span><span class="o">:</span> <span class="nx">Apartment</span><span class="o">?</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>现在你可以创建特定的<code>Person</code>和<code>Apartment</code>实例并将类实例赋值给<code>john</code>和<code>number73</code>变量：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">john</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;John Appleseed&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">number73</span> <span class="o">=</span> <span class="nx">Apartment</span><span class="p">(</span><span class="nx">number</span><span class="o">:</span> <span class="mi">73</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在<code>john</code>和<code>number73</code>互相引用之前，它们的强引用关系是这样的：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png" alt="" /></p>

<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来强制解析可选变量<code>john</code>和<code>number73</code>中的实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">john</span><span class="o">!</span><span class="p">.</span><span class="nx">apartment</span> <span class="o">=</span> <span class="nx">number73</span>
</span><span class='line'><span class="nx">number73</span><span class="o">!</span><span class="p">.</span><span class="nx">tenant</span> <span class="o">=</span> <span class="nx">john</span>
</span></code></pre></td></tr></table></div></figure>


<p>
在将两个实例联系在一起之后，强引用的关系变成了这样：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png" alt="" /></p>

<p>这样即使让<code>john</code>和<code>number73</code>断开它们持有的强引用，内存中的那两个<code>Person</code>和<code>Apartment</code>实例并不会销毁，因为它们互相引用，引用计数都为1：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">john</span> <span class="o">=</span> <span class="nx">nil</span>
</span><span class='line'><span class="nx">number73</span> <span class="o">=</span> <span class="nx">nil</span>
</span></code></pre></td></tr></table></div></figure>


<p>
当你把这两个变量设为<code>nil</code>时，没有任何一个析构函数被调用。强引用循环阻止了<code>Person</code>和<code>Apartment</code>类实例的销毁，并在你的应用程序中造成了内存泄漏。</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png" alt="" /></p>

<h2>如何解决实例间强引用循环</h2>

<h3>弱引用</h3>

<p>跟OC中的弱引用相似，声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。弱引用不会牢牢保持住引用的实例，并且不会阻止 ARC 销毁被引用的实例。因为弱引用的值会变化并可能为<code>nil</code>，所以弱引用不能是常量，必须是可选类型（Optional）。因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。</p>

<p>下面的例子跟上面<code>Person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>属性被声明为弱引用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Person</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span> <span class="p">}</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">apartment</span><span class="o">:</span> <span class="nx">Apartment</span><span class="o">?</span>
</span><span class='line'>    <span class="nx">deinit</span> <span class="p">{</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kr">class</span> <span class="nx">Apartment</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">number</span><span class="o">:</span> <span class="nx">Int</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">number</span><span class="o">:</span> <span class="nx">Int</span><span class="p">)</span> <span class="p">{</span> <span class="nx">self</span><span class="p">.</span><span class="nx">number</span> <span class="o">=</span> <span class="nx">number</span> <span class="p">}</span>
</span><span class='line'>    <span class="nx">weak</span> <span class="kd">var</span> <span class="nx">tenant</span><span class="o">:</span> <span class="nx">Person</span><span class="o">?</span>
</span><span class='line'>    <span class="nx">deinit</span> <span class="p">{</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;Apartment #\(number) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
然后跟之前一样，建立两个变量（<code>john</code>和<code>number73</code>）之间的强引用，并关联两个实例：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">john</span><span class="o">:</span> <span class="nx">Person</span><span class="o">?</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">number73</span><span class="o">:</span> <span class="nx">Apartment</span><span class="o">?</span>
</span><span class='line'>
</span><span class='line'><span class="nx">john</span> <span class="o">=</span> <span class="nx">Person</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;John Appleseed&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">number73</span> <span class="o">=</span> <span class="nx">Apartment</span><span class="p">(</span><span class="nx">number</span><span class="o">:</span> <span class="mi">73</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="nx">john</span><span class="o">!</span><span class="p">.</span><span class="nx">apartment</span> <span class="o">=</span> <span class="nx">number73</span>
</span><span class='line'><span class="nx">number73</span><span class="o">!</span><span class="p">.</span><span class="nx">tenant</span> <span class="o">=</span> <span class="nx">john</span>
</span></code></pre></td></tr></table></div></figure>


<p>
现在的引用关系如下：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png" alt="" /></p>

<p>当<code>john</code>的强引用断开后，引用关系变成了这样子：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png" alt="" /></p>

<p>因为没有强引用指向<code>Person</code>实例，它的引用计数为0，所以该实例会被销毁。因此<code>number73</code>指向的<code>Apartment</code>实例的的引用计数会变为1，因为<code>Person</code>实例销毁后，其<code>apartment</code>属性对<code>Apartment</code>实例的强引用也会断开。此时如果再断开<code>number73</code>对<code>Apartment</code>实例的强引用：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png" alt="" /></p>

<p><code>Apartment</code>实例因为引用计数为0，会被销毁，到此为止强引用循环被打破。</p>

<h3>无主引用</h3>

<p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的（不能为<code>nil</code>）。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字<code>unowned</code>表示这是一个无主引用。</p>

<p>下面的例子定义了两个类，<code>Customer</code>和<code>CreditCard</code>，模拟了银行客户和客户的信用卡。一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。所以<code>Customer</code>类的<code>card</code>属性可以为<code>nil</code>，但是<code>CreditCard</code>类的<code>customer</code>属性不能为<code>nil</code>，所以创建CreditCard实例的时候必须给<code>customer</code>属性赋值避免其为<code>nil</code>。将<code>customer</code>属性定义为无主引用，用以避免循环强引用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Customer</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">card</span><span class="o">:</span> <span class="nx">CreditCard</span><span class="o">?</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">deinit</span> <span class="p">{</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kr">class</span> <span class="nx">CreditCard</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">number</span><span class="o">:</span> <span class="nx">Int64</span>
</span><span class='line'>    <span class="nx">unowned</span> <span class="kd">let</span> <span class="nx">customer</span><span class="o">:</span> <span class="nx">Customer</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">number</span><span class="o">:</span> <span class="nx">Int64</span><span class="p">,</span> <span class="nx">customer</span><span class="o">:</span> <span class="nx">Customer</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">number</span> <span class="o">=</span> <span class="nx">number</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">customer</span> <span class="o">=</span> <span class="nx">customer</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nx">deinit</span> <span class="p">{</span> <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;Card #\(number) is being deinitialized&quot;</span><span class="p">)</span> <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">var</span> <span class="nx">john</span><span class="o">:</span> <span class="nx">Customer</span><span class="o">?</span>
</span><span class='line'><span class="nx">john</span> <span class="o">=</span> <span class="nx">Customer</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;John Appleseed&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">john</span><span class="o">!</span><span class="p">.</span><span class="nx">card</span> <span class="o">=</span> <span class="nx">CreditCard</span><span class="p">(</span><span class="nx">number</span><span class="o">:</span> <span class="mi">1234</span><span class="nx">_5678_9012_3456</span><span class="p">,</span> <span class="nx">customer</span><span class="o">:</span> <span class="nx">john</span><span class="o">!</span><span class="p">)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
关联两个实例后，引用关系如下：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png" alt="" /></p>

<p>由于<code>customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png" alt="" /></p>

<p>于是<code>Customer</code>实例被销毁，这样又导致没有强引用指向<code>CreditCard</code>实例，最后<code>CreditCard</code>实例也被销毁了，这样说明强引用循环被打破了。</p>

<h3>无主引用以及隐式解析可选属性</h3>

<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，而每一个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>country</code>属性：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">Country</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">capitalCity</span><span class="o">:</span> <span class="nx">City</span><span class="o">!</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">capitalName</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">capitalCity</span> <span class="o">=</span> <span class="nx">City</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nx">capitalName</span><span class="p">,</span> <span class="nx">country</span><span class="o">:</span> <span class="nx">self</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kr">class</span> <span class="nx">City</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="nx">unowned</span> <span class="kd">let</span> <span class="nx">country</span><span class="o">:</span> <span class="nx">Country</span>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">country</span><span class="o">:</span> <span class="nx">Country</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">country</span> <span class="o">=</span> <span class="nx">country</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
在这种场景中，两个属性都必须有值，并且初始化完成后不能为<code>nil</code>。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>

<p>隐式解析可选(<code>Implicitly Unwrapped Optionals</code>)被用于类的初始化方法中，避免循环引用，因为编译器会将其认为默认<code>nil</code>，不需赋值就可以完成类的初始化，在例子中一旦<code>name</code>属性被赋值后(但<code>capitalCity</code>还没被赋值时)<code>Country</code>类就已经初始化并且自身（<code>self</code>）可以被引用；这样就能实现一行代码建立<code>Country</code>和<code>City</code>实例而不造成强引用循环。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">country</span> <span class="o">=</span> <span class="nx">Country</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;Canada&quot;</span><span class="p">,</span> <span class="nx">capitalName</span><span class="o">:</span> <span class="s2">&quot;Ottawa&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">println</span><span class="p">(</span><span class="s2">&quot;\(country.name)&#39;s capital city is called \(country.capitalCity.name)&quot;</span><span class="p">)</span>
</span><span class='line'><span class="c1">// prints &quot;Canada&#39;s capital city is called Ottawa&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p>
使用隐式解析可选值的意义在于满足了两个类构造函数的需求。<code>capitalCity</code>属性在初始化完成后，能像非可选值一样使用和存取同时还避免了循环强引用。</p>

<h3>总结</h3>

<p><code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>

<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>，而另一个属性的值不允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合通过无主引用来解决。</p>

<p><code>Country</code>和<code>City</code>的例子展示了两个属性的值都不允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>

<h2>闭包引起的强引用循环</h2>

<p>强引用循环还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如<code>self.someMethod</code>。这两种情况都导致了闭包 “捕获&#8221; <code>self</code>，因为闭包也是引用类型，从而产生了强引用循环。在Swift中闭包如果想使用外部的实例，不必像OC中的Block那样在外部实例前加<code>__block</code>加以修饰，而是可以直接用“值捕获”的方式捕获到闭包外面的实例。Swift 会决定捕获引用还是拷贝值，并负责管理内存释放。</p>

<p>Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod（而不只是someProperty或someMethod）。这提醒你可能会不小心就捕获了self。</p>

<p>在OC中也存在<code>Block</code>中引用<code>self</code>或<code>self</code>的属性而导致<code>self</code>被<code>Block</code> retain，进而产生引用循环，这也是为什么代理属性都被声明为<code>weak</code>的原因。</p>

<p>下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 中的一个单独的元素：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">HTMLElement</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">text</span><span class="o">:</span> <span class="nb">String</span><span class="o">?</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">lazy</span> <span class="kd">var</span> <span class="nx">asHTML</span><span class="o">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">String</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">if</span> <span class="kd">let</span> <span class="nx">text</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">text</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s2">&quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s2">&quot;&lt;\(self.name) /&gt;&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="nb">String</span><span class="o">?</span> <span class="o">=</span> <span class="nx">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="nx">text</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">deinit</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>HTMLElement</code>定义了一个<code>lazy</code>属性<code>asHTML</code>。这个属性引用了一个闭包，将<code>name</code>和<code>text</code>组合成 HTML 字符串片段。该属性是<code>() -&gt; String</code>类型，或者可以理解为“一个没有参数，返回<code>String</code>的函数”。因为该闭包无参数并可推断出返回值类型，所以采取了简写，省略了关键字<code>in</code>和闭包的参数和返回值类型声明。</p>

<p><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要处理为HTML输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>

<p>下面的代码展示了如何用HTMLElement类创建实例并打印消息</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">paragraph</span><span class="o">:</span> <span class="nx">HTMLElement</span><span class="o">?</span> <span class="o">=</span> <span class="nx">HTMLElement</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="s2">&quot;p&quot;</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="s2">&quot;hello, world&quot;</span><span class="p">)</span>
</span><span class='line'><span class="nx">println</span><span class="p">(</span><span class="nx">paragraph</span><span class="o">!</span><span class="p">.</span><span class="nx">asHTML</span><span class="p">())</span>
</span><span class='line'><span class="c1">// prints&quot;hello, world&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>不幸的是，上面写的HTMLElement类产生了类实例和asHTML默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png" alt="" /></p>

<p>虽然闭包多次使用了<code>self</code>，它只捕获<code>HTMLElement</code>实例的一个强引用。如果设置<code>paragraph</code>变量为<code>nil</code>，打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMLElement</code>实例和它的闭包都不会被销毁，也是因为强引用循环</p>

<h2>解决闭包引起的循环强引用</h2>

<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closuer capture list）</p>

<h3>定义捕获列表</h3>

<p>捕获列表放置在闭包参数列表和返回类型之前，列表中每项都是由<code>weak</code>或<code>unowned</code>关键字和实例的引用（如self或someInstance）成对组成。每项都通过逗号分开写在方括号中。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">lazy</span> <span class="kd">var</span> <span class="nx">someClosure</span><span class="o">:</span> <span class="p">(</span><span class="nx">Int</span><span class="p">,</span> <span class="nb">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">String</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nx">unowned</span> <span class="nx">self</span><span class="p">]</span> <span class="p">(</span><span class="nx">index</span><span class="o">:</span> <span class="nx">Int</span><span class="p">,</span> <span class="nx">stringToProcess</span><span class="o">:</span> <span class="nb">String</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">String</span> <span class="k">in</span>
</span><span class='line'>    <span class="c1">// closure body goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
如果闭包没有指定参数列表或者返回类型，则可以通过上下文推断，那么可以捕获列表放在闭包开始的地方，跟着是关键字<code>in</code>：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">lazy</span> <span class="kd">var</span> <span class="nx">someClosure</span><span class="o">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">String</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>    <span class="p">[</span><span class="nx">unowned</span> <span class="nx">self</span><span class="p">]</span> <span class="k">in</span>
</span><span class='line'>    <span class="c1">// closure body goes here</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>捕获列表中的弱引用和无主引用</h3>

<p>当捕获引用有时可能会是<code>nil</code>时，将闭包内的捕获定义为弱引用。<br/>
当闭包和捕获的实例总是互相引用时并且总是同时销毁时，将闭包内的捕获定义为无主引用。<br/>
如果捕获的引用绝对不会置为<code>nil</code>，应该用无主引用，而不是弱引用。</p>

<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法。这样编写<code>HTMLElement</code>类来避免循环强引用：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kr">class</span> <span class="nx">HTMLElement</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">name</span><span class="o">:</span> <span class="nb">String</span>
</span><span class='line'>    <span class="kd">let</span> <span class="nx">text</span><span class="o">:</span> <span class="nb">String</span><span class="o">?</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">lazy</span> <span class="kd">var</span> <span class="nx">asHTML</span><span class="o">:</span> <span class="p">()</span> <span class="o">-&gt;</span> <span class="nb">String</span> <span class="o">=</span> <span class="p">{</span>
</span><span class='line'>        <span class="p">[</span><span class="nx">unowned</span> <span class="nx">self</span><span class="p">]</span> <span class="k">in</span>
</span><span class='line'>        <span class="k">if</span> <span class="kd">let</span> <span class="nx">text</span> <span class="o">=</span> <span class="nx">self</span><span class="p">.</span><span class="nx">text</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s2">&quot;&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;&quot;</span>
</span><span class='line'>        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">return</span> <span class="s2">&quot;&lt;\(self.name) /&gt;&quot;</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">init</span><span class="p">(</span><span class="nx">name</span><span class="o">:</span> <span class="nb">String</span><span class="p">,</span> <span class="nx">text</span><span class="o">:</span> <span class="nb">String</span><span class="o">?</span> <span class="o">=</span> <span class="nx">nil</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">name</span> <span class="o">=</span> <span class="nx">name</span>
</span><span class='line'>        <span class="nx">self</span><span class="p">.</span><span class="nx">text</span> <span class="o">=</span> <span class="nx">text</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>    <span class="nx">deinit</span> <span class="p">{</span>
</span><span class='line'>        <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;\(name) is being deinitialized&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>上面的例子只是多了一个捕获列表并增加关键字<code>in</code>，使用捕获列表后引用关系如下图所示：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png" alt="" /></p>

<p>这一次，闭包以无主引用的形式捕获<code>self</code>，并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为<code>nil</code>，<code>HTMLElement</code>实例将会被销毁，并能看到它的析构函数打印出的消息。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">paragraph</span> <span class="o">=</span> <span class="nx">nil</span>
</span><span class='line'><span class="c1">// prints &quot;p is being deinitialized&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift重载和自定义运算符]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/16/swiftzhong-zai-yun-suan-fu/"/>
    <updated>2014-06-16T20:45:20+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/16/swiftzhong-zai-yun-suan-fu</id>
    <content type="html"><![CDATA[<p>最近一直边忙毕设边学Swift，终于看完了官方的教程（语言参考暂不打算看），在iBooks上做了一些笔记（看英文伤不起），感觉Swift是一门大杂烩类型的语言，我会记录一些我自认为以前遇到较少或者需要重点记忆的语法特性，在此作为分享，这次是运算符的重载，几乎每门语言都有，只是语法不一样罢了。<br/>
(2014-8-8更新至beta5语法)</p>

<!--more-->


<h2>运算符重载</h2>

<p>在Swift的官方文档中运算符重载叫做运算符函数（Operator Functions），顾名思义就是对已经有的运算符覆盖定义自己的函数实现。三元运算符（a？b：c）和默认的默认的赋值符(=)是不可重载的。</p>

<h3>中缀运算符的重载</h3>

<p>在<code>func</code>关键字前使用属性<code>@infix</code>来重载中缀运算符，函数名为想要重载的中缀运算符：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">struct</span> <span class="nx">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="kd">var</span> <span class="nx">x</span> <span class="o">=</span> <span class="mf">0.0</span><span class="p">,</span> <span class="nx">y</span> <span class="o">=</span> <span class="mf">0.0</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">func</span> <span class="o">+</span> <span class="p">(</span><span class="nx">left</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">,</span> <span class="nx">right</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">left</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">right</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">left</span><span class="p">.</span><span class="nx">y</span> <span class="o">+</span> <span class="nx">right</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
上面的代码是对结构体<code>Vector2D</code>之间双目运算符<code>+</code>的重载，下面可以直接使用<code>+</code>对<code>Vector2D</code>进行操作了：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">vector</span> <span class="o">=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">)</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">anotherVector</span> <span class="o">=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">combinedVector</span> <span class="o">=</span> <span class="nx">vector</span> <span class="o">+</span> <span class="nx">anotherVector</span>
</span><span class='line'><span class="c1">// combinedVector 是一个新的Vector2D, 值为 (5.0, 5.0)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>除了对双目运算符的重载，还有对比较运算符的重载</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="o">==</span> <span class="p">(</span><span class="nx">left</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">,</span> <span class="nx">right</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="p">(</span><span class="nx">left</span><span class="p">.</span><span class="nx">x</span> <span class="o">==</span> <span class="nx">right</span><span class="p">.</span><span class="nx">x</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="nx">left</span><span class="p">.</span><span class="nx">y</span> <span class="o">==</span> <span class="nx">right</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="nx">func</span> <span class="o">!=</span> <span class="p">(</span><span class="nx">left</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">,</span> <span class="nx">right</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Bool</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="nx">left</span> <span class="o">==</span> <span class="nx">right</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>现在我们可以使用这两个运算符来判断两个Vector2D对象是否相等</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">twoThree</span> <span class="o">=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">3.0</span><span class="p">)</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">anotherTwoThree</span> <span class="o">=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">2.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">3.0</span><span class="p">)</span>
</span><span class='line'><span class="k">if</span> <span class="nx">twoThree</span> <span class="o">==</span> <span class="nx">anotherTwoThree</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">println</span><span class="p">(</span><span class="s2">&quot;这两个向量是相等的.&quot;</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="c1">// prints &quot;这两个向量是相等的.&quot;</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>前缀和后缀运算符的重载</h3>

<p>前缀和后缀一元运算符重载需要在将<code>func</code>关键字前用<code>prefix</code>和<code>postfix</code>修饰，比如：</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">prefix</span> <span class="nx">func</span> <span class="o">-</span> <span class="p">(</span><span class="nx">vector</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="o">-</span><span class="nx">vector</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="o">-</span><span class="nx">vector</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这段代码为<code>Vector2D</code>类型提供了单目减运算，并且是前缀，也就是取负操作。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">let</span> <span class="nx">positive</span> <span class="o">=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">negative</span> <span class="o">=</span> <span class="o">-</span><span class="nx">positive</span>
</span><span class='line'><span class="c1">// negative 为 (-3.0, -4.0)</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">alsoPositive</span> <span class="o">=</span> <span class="o">-</span><span class="nx">negative</span>
</span><span class='line'><span class="c1">// alsoPositive 为 (3.0, 4.0)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h3>组合赋值运算符的重载</h3>

<p>组合赋值是其他运算符和赋值运算符一起执行的运算。如<code>+=</code>把加运算和赋值运算组合成一个操作。实现一个组合赋值符号需要把运算符的左参数设置成<code>inout</code>，因为这个参数会在运算符函数内直接修改它的值。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">func</span> <span class="o">+=</span> <span class="p">(</span><span class="nx">inout</span> <span class="nx">left</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">,</span> <span class="nx">right</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">left</span> <span class="o">=</span> <span class="nx">left</span> <span class="o">+</span> <span class="nx">right</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>因为加法运算在之前定义过了，这里无需重新定义。所以，加赋运算符函数使用已经存在的高级加法运算符函数来执行左值加右值的运算。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">original</span> <span class="o">=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">2.0</span><span class="p">)</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">vectorToAdd</span> <span class="o">=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="nx">original</span> <span class="o">+=</span> <span class="nx">vectorToAdd</span>
</span><span class='line'><span class="c1">// original 现在为 (4.0, 6.0)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
你可以将赋值运算结合<code>prefix</code> 或 <code>postfix</code>修饰，例如实现一个<code>Vector2D</code>的前缀自增运算符（++a）。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="err">@</span><span class="nx">prefix</span> <span class="nx">func</span> <span class="o">++</span> <span class="p">(</span><span class="nx">inout</span> <span class="nx">vector</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">vector</span> <span class="o">+=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">)</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">vector</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
这个前缀使用了已经定义好的高级加赋运算，将自己加上一个值为<code>(1.0，1.0)</code>的对象然后赋给自己，然后再将自己返回。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">toIncrement</span> <span class="o">=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">afterIncrement</span> <span class="o">=</span> <span class="o">++</span><span class="nx">toIncrement</span>
</span><span class='line'><span class="c1">// toIncrement 现在是 (4.0, 5.0)</span>
</span><span class='line'><span class="c1">// afterIncrement 现在也是 (4.0, 5.0)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>自定义运算符</h2>

<p>标准的运算符不够玩，那你可以声明一些个性的运算符，但个性的运算符只能使用这些字符 <code>/ = - + * % &lt; &gt; ! &amp; | ^ . ~</code>  <br/>
新的运算符声明需在全局域使用<code>operator</code>关键字声明，可以声明为前缀，中缀或后缀的，分别用<code>prefix</code>、<code>infix</code>和<code>postfix</code>修饰。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">prefix</span> <span class="nx">operator</span> <span class="o">+++</span> <span class="p">{}</span>
</span></code></pre></td></tr></table></div></figure>


<p>
这段代码定义了一个新的前缀运算符叫<code>+++</code>，此前Swift并不存在这个运算符。此处为了演示，我们让<code>+++</code>对<code>Vector2D</code>对象的操作定义为“双自增”（prefix doubling incrementer） 这样一个独有的操作，这个操作使用了之前定义的加赋运算（<code>+=</code>）实现了自已加上自己然后返回的运算。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">prefix</span> <span class="nx">func</span> <span class="o">+++</span> <span class="p">(</span><span class="nx">inout</span> <span class="nx">vector</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="nx">vector</span> <span class="o">+=</span> <span class="nx">vector</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">vector</span>
</span><span class='line'><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p><code>+++</code>运算的实现是把自己再加上自己</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="kd">var</span> <span class="nx">toBeDoubled</span> <span class="o">=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">afterDoubling</span> <span class="o">=</span> <span class="o">+++</span><span class="nx">toBeDoubled</span>
</span><span class='line'><span class="c1">// toBeDoubled 现在是 (2.0, 8.0)</span>
</span><span class='line'><span class="c1">// afterDoubling 现在也是 (2.0, 8.0)</span>
</span></code></pre></td></tr></table></div></figure>


<p>
此外还可以定义运算符的结合性(associativity)和优先级(precedence)，结合性(associativity)的值可取的值有left，right和none。左结合运算符跟其他优先级相同的左结合运算符写在一起时，会跟左边的操作数结合。同理，右结合运算符会跟右边的操作数结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。<br/>
结合性(associativity)的值默认为none，优先级(precedence)默认为100。</p>

<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
</pre></td><td class='code'><pre><code class='js'><span class='line'><span class="nx">infix</span> <span class="nx">operator</span> <span class="o">+-</span> <span class="p">{</span> <span class="nx">associativity</span> <span class="nx">left</span> <span class="nx">precedence</span> <span class="mi">140</span> <span class="p">}</span>
</span><span class='line'><span class="nx">func</span> <span class="o">+-</span> <span class="p">(</span><span class="nx">left</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">,</span> <span class="nx">right</span><span class="o">:</span> <span class="nx">Vector2D</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nx">Vector2D</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="nx">left</span><span class="p">.</span><span class="nx">x</span> <span class="o">+</span> <span class="nx">right</span><span class="p">.</span><span class="nx">x</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="nx">left</span><span class="p">.</span><span class="nx">y</span> <span class="o">-</span> <span class="nx">right</span><span class="p">.</span><span class="nx">y</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">firstVector</span> <span class="o">=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">1.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">2.0</span><span class="p">)</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">secondVector</span> <span class="o">=</span> <span class="nx">Vector2D</span><span class="p">(</span><span class="nx">x</span><span class="o">:</span> <span class="mf">3.0</span><span class="p">,</span> <span class="nx">y</span><span class="o">:</span> <span class="mf">4.0</span><span class="p">)</span>
</span><span class='line'><span class="kd">let</span> <span class="nx">plusMinusVector</span> <span class="o">=</span> <span class="nx">firstVector</span> <span class="o">+-</span> <span class="nx">secondVector</span>
</span><span class='line'><span class="c1">// plusMinusVector 此时的值为 (4.0, -2.0)</span>
</span></code></pre></td></tr></table></div></figure>


<p></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Publish Your Pods on CocoaPods with Trunk]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/26/publish-your-pods-on-cocoapods-with-trunk/"/>
    <updated>2014-05-26T12:03:08+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/26/publish-your-pods-on-cocoapods-with-trunk</id>
    <content type="html"><![CDATA[<h2>简介</h2>

<p>2014年5月20日，CocoaPods不再接受向<a href="git@github.com:CocoaPods/Specs.git">CocoaPods/Specs</a>的pull request，官方的说法是为了安全考虑，防止每个人的pod被其他人修改，于是CocoaPods团队开发了trunk服务，这样每个人都是其发布的pod的owner，没有权限的人无法修改，这样更安全。</p>

<p>更改后的提交架构是这样的：(来自官方图片)</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353388207.png" alt="" /></p>

<!--more-->


<p>以前的podspec文件都是ruby格式，而trunk为我们带来了更轻便的json格式，你后你可以用json来配置你的pod了。不用担心过去我们发布的pod，他们依然健在，并且trunk会将podspec文件转化为podspec.json文件。</p>

<p>这里给出一个官方的介绍链接（自备梯子）：<a href="http://blog.cocoapods.org/CocoaPods-Trunk/#transition">http://blog.cocoapods.org/CocoaPods-Trunk/#transition</a></p>

<p><strong>废话不多说，简要介绍下如何使用trunk新建我们的pod：</strong></p>

<h2>开始注册</h2>

<p>trunk需要CocoaPods 0.33版本以上，用<code>pod --version</code>命令查看版本，如果版本低，需要升级：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>sudo gem install cocoapods
</span><span class='line'>pod setup
</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>然后会一直卡在<code>Setting up CocoaPods master repo</code>这里，这条命令用于跟新本地电脑上的保存的Pods依赖库tree。由于每天有很多人会创建或者更新Pods依赖库，这条命令执行的时候会相当慢，还请耐心等待。我们需要经常执行这条命令，否则有新的Pods依赖库的时候执行pod search命令是搜不出来的。再开启一个终端，通过<code>cd  ~/.cocoapods</code>命令进入cocoapods根目录，然后通过<code>du -sh *</code>命令查看总的文件大小，如果隔一阵子会增加，那么说明一切正常，下载速度取决于你的网络。</p>

<p>更新完成后，下一步是注册trunk，这一步需要自备梯子，否则就会出现这种<a href="https://github.com/CocoaPods/CocoaPods/issues/2174">问题</a></p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod trunk register yulingtianxia@gmail.com 'Yang Xiaoyu' --description='macbook pro' --verbose</span></code></pre></td></tr></table></div></figure>


<p>
上面的命令是我注册时使用的，你需要把邮箱和名字以及描述替换成你的，加上<code>--verbose</code>可以输出详细debug信息，方便出错时查看。</p>

<p>注册后CocoaPods会给你的邮箱发送验证链接，点击后就注册成功了，可以用<code>pod trunk me</code>命令查看自己的注册信息：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>bogon:YXYNumberAnimationLabel yangxiaoyu$ pod trunk me
</span><span class='line'>  - Name:     Yang Xiaoyu
</span><span class='line'>  - Email:    yulingtianxia@gmail.com
</span><span class='line'>  - Since:    May 25th, 20:27
</span><span class='line'>  - Sessions: 
</span><span class='line'>    - May 25th, 20:27 - September 30th, 22:41. IP: 23.228.209.171
</span><span class='line'>  Description: macbook pro</span></code></pre></td></tr></table></div></figure>


<p>
上面是我的注册信息，CocoaPods不通过密码来验证用户，而是通过一个session token。</p>

<h2>部署你的Pod</h2>

<p>首先你需要建立一个podspec文件，这是我的podspec文件：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>Pod::Spec.new do |s|
</span><span class='line'>  s.name         = "YXYNumberAnimationLabel"
</span><span class='line'>  s.version      = "1.0.1"
</span><span class='line'>  s.summary      = "一个可以动起来的数字Label"
</span><span class='line'>  s.description  = &lt;&lt;-DESC
</span><span class='line'>                    通过设置数字变化的插值来展现动画效果
</span><span class='line'>                   DESC
</span><span class='line'>  s.homepage     = "https://github.com/yulingtianxia/YXYNumberAnimationLabel"
</span><span class='line'>  
</span><span class='line'>  s.license      = 'MIT'
</span><span class='line'>  s.author       = { "YangXiaoyu" =&gt; "yulingtianxia@gmail.com" }
</span><span class='line'>  s.social_media_url = "http://twitter.com/yulingtianxia"
</span><span class='line'>  s.source       = { :git =&gt; "https://github.com/yulingtianxia/YXYNumberAnimationLabel.git", :tag =&gt; s.version.to_s }
</span><span class='line'>
</span><span class='line'>  s.platform     = :ios, '6.0'
</span><span class='line'>  s.requires_arc = true
</span><span class='line'>
</span><span class='line'>  s.source_files = 'YXYNumberAnimationLabel/*'
</span><span class='line'>  s.frameworks = 'Foundation', 'UIKit'
</span><span class='line'>  #s.private_header_files = 'Classes/ios/private/*.h'
</span><span class='line'>  
</span><span class='line'>  #s.dependency 'FLKAutoLayout', '~&gt; 0.1'
</span><span class='line'>end</span></code></pre></td></tr></table></div></figure>


<p>
<strong>具体配置什么的大家走很熟悉，这里只是讲述使用trunk后需要注意的地方和新的操作</strong></p>

<p>在验证和上传你的podspec文件到trunk之前，需要将你的源码push到Github上，tag一个版本号并发布一个release版本，这样podspec文件中的<code>s.source</code>的值才能是准确的：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>git add -A && git commit -m "Release 1.0.1."  
</span><span class='line'>git tag '1.0.1'  
</span><span class='line'>git push --tags  
</span><span class='line'>git push origin master</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>这两条命令是为pod添加版本号并打上tag:</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>set the new version to 1.0.1
</span><span class='line'>set the new tag to 1.0.1</span></code></pre></td></tr></table></div></figure>


<p></p>

<p>在你podspec文件下的路径运行<code>pod trunk push YXYNumberAnimationLabel.podspec</code> 命令，同样需要翻墙梯子自备，别忘了将<code>YXYNumberAnimationLabel.podspec</code>替换成你的podspec文件名。</p>

<p>pod trunk push命令做了如下三个工作：</p>

<ol>
<li>验证你本地的podspec文件（你也可以用<code>pod lib lint</code>命令来验证）</li>
<li>上传你的podspec文件到trunk</li>
<li>将你的podspec文件转化成trunk需要的JSON文件</li>
</ol>


<p>如果部署成功，CocosPods会在Twitter上@你</p>

<p>就像文章最开始的架构图描述的那样，你在trunk中的操作依然会在<a href="git@github.com:CocoaPods/Specs.git">CocoaPods/Specs</a>仓库中更新。以后再做更改时只需要更新版本号然后通过trunk来提交，不用向<a href="git@github.com:CocoaPods/Specs.git">CocoaPods/Specs</a>pull request并等待审核和merge了。</p>

<p>运行<code>pod setup</code>来更新你的Pods依赖库tree后，再使用<code>pod search YXYNumberAnimationLabel</code>命令来查找刚刚加入的名字叫<code>YXYNumberAnimationLabel</code>的依赖库：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-&gt; YXYNumberAnimationLabel (1.0.1)
</span><span class='line'>   一个可以动起来的数字Label
</span><span class='line'>   pod 'YXYNumberAnimationLabel', '~&gt; 1.0.1'
</span><span class='line'>   - Homepage: https://github.com/yulingtianxia/YXYNumberAnimationLabel
</span><span class='line'>   - Source:   https://github.com/yulingtianxia/YXYNumberAnimationLabel.git
</span><span class='line'>   - Versions: 1.0.1, 1.0.0 [master repo]</span></code></pre></td></tr></table></div></figure>


<p></p>

<h2>将其他人加入到你的Pod</h2>

<p>为了让其他人也有权限来和你一起建设你的代码，你需要运行下面的命令来赋予别人权限，假如我将<code>kyle@cocoapods.org</code>加入到我的名字叫<code>ARAnalytics</code>的库中，我需要运行下面的命令：</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>pod trunk add-owner ARAnalytics kyle@cocoapods.org</span></code></pre></td></tr></table></div></figure>


<p></p>
]]></content>
  </entry>
  
</feed>
