<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Xcode | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/xcode/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-11-16T15:18:33+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Xcode6将你的项目本地化]]></title>
    <link href="http://yulingtianxia.com/blog/2014/10/02/localizing-with-xcode-6/"/>
    <updated>2014-10-02T12:54:41+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/10/02/localizing-with-xcode-6</id>
    <content type="html"><![CDATA[<p>iOS和OSX支持40种语言的本地化，Xcode无疑为这一过程提供了强有力的支持。苹果将这一多语言适配过程细分为Internationalization（国际化）和Localization（本地化）两个阶段。</p>

<!--more-->


<h2>国际化&mdash;准备你的APP</h2>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-9%402x.png" alt="" /></p>

<p>在将你的APP适配各种语言本地化之前，你得先让你的APP富有国际范儿，也就是说国际化是一条通往本地化的必经之路。在国际化阶段，你需要让你的APP与语言和区域独立。</p>

<p>苹果的框架已经帮我们把不同语言的数据分离开，这更有助于我们管理这些资源，包括图片、声音、视频、文档、用户界面文字（甚至代码中编写的用户界面文字），它们会被建立在同一个bundle中。</p>

<h3>NSLocalizedString</h3>

<p>我们来使用<code>NSLocalizedString</code>来让用户界面的文字国际化，不过这些文字不是在IB上输入的，而是在代码中产生并赋值的：</p>

<p><code>js
func NSLocalizedString(key: String, tableName: String? = default, bundle: NSBundle = default, value: String = default, #comment: String) -&gt; String
</code>
上面这个Swift语言声明的函数可以直接返回一个经过本地化处理过的字符串，这就使得你在代码中给一些控件文本赋值时更有“国际化视野”：<br/>
<code>
self.text = NSLocalizedString("SHARE", comment: "share score")
</code>
因为不用的语言会有不同的专业名词，所以最后的comment参数很重要，它可以暗示翻译人员这段文字要表达的含义。而第一个参数key的内容为基础语种的内容，将它作为“键”来映射其他语言对应翻译后的“值”。如果我们需要在字符串中插入其他内容，这时需要改进下：</p>

<p><code>
let text = String.localizedStringWithFormat(NSLocalizedString("I got %d points in Spiral. Come on with me! https://itunes.apple.com/us/app/square-spiral/id920811081", comment: "share content"), Data.score)
</code>
<code>localizedStringWithFormat:</code>方法保证了插入字符串中的内容也被转化成本地格式，比如时间格式、数字的格式等。而此时在Swift字符串中插入其他数据就不能使用<code>\()</code>了，只能用百分号占位的形式。</p>

<p>对应的在Localizable.strings中可以这样写：</p>

<p><code>
/*share score*/
"SHARE"="分享战绩";
/*share content*/
"I got %d points in Spiral. Come on with me! https://itunes.apple.com/us/app/square-spiral/id920811081"="我在Spiral游戏中得了%1$d分，快来超越我吧！https://itunes.apple.com/cn/app/square-spiral/id920811081";
</code></p>

<p>这样就将英文与中文键值对应起来了，注意那个“1$”表示是在键内容（即英文原文）中第一个插入的数据，因为不用语言表达同一个意思时，插入字符串中的数据顺序可能会有变化，这个"数字+$&ldquo;的标记记录了它们原本的顺序。</p>

<h3>NSFormatter</h3>

<p>NSFormatter算是老朋友了，它把数据转化成人们易读的字符串，而且还会根据不同语言和区域进行格式上的优化。它默认使用当地的语言习惯，我们不需要配置任何参数。比如显示时间日期，数字，金融，字节计数等格式上的本地化。现在iOS8和OSX Yosemite加入了健康相关的功能，NSFormatter也加入了很多新的量词，比如能量、长度高度、重量等方面。</p>

<h3>NSBundle</h3>

<p>你的APP构建于很多文件夹中，而不是一个单独的文件。这些文件夹被叫做bundle。它们不仅仅包含了你的APP，还有你APP的扩展(extensions)，你的构架(frameworks)等。而NSBundle提供了获取这些bundle中资源的标准API。当你使用这些API的时候，它们会自动使用符合当前地区语言的最恰当的资源。建立bundle是Xcode的活儿，所以我们不需要手动去管理这些资源文件放在bundle的具体位置，而是告诉Xcode哪些资源可以被本地化，设置好资源文件对应的语言，然后就交给Xcode去管理这些资源文件在bundle中的位置吧。</p>

<p>所以我们在加载一些资源文件的时候依然向以前那样从bundle获取url就行啦，Xcode已经帮我们替换成了本地化的资源，前提是你已经在Xcode中设置好了当前语言版本的对应资源。</p>

<h3>Xcode</h3>

<p>在Xcode5中支持了使用base国际化并用自动布局优化国际化后的界面，现在其他资源文件也可以这么干了，甚至可以在Xcode中预览界面布局效果。</p>

<p>点选一个xib或storyboard文件后，在File Inspector中的Localization中可以设置支持的语言。Xcode会自动从界面元素中提取出文字到strings文件中，翻译人员可以根据注释来在对应语言的strings文件中进行翻译。当然也可以直观化的转换成界面形式的文件来直观化翻译工作：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-2%402x.png" alt="" /></p>

<p>其他诸如图片、声音、影片等资源文件也可以通过类似的方法本地化：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-3%402x.png" alt="" /></p>

<p>在Xcode6中我们可以在Debug时预览不同语言和地区APP的界面效果，这样我们就不用在debug阶段不断的切换模拟器或真机的系统语言了！首先要在scheme中更改下运行APP的语言和地区：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-4%402x.png" alt="" /></p>

<p>注意到后面还有两项：双倍长度的模拟语言和从右到左的模拟语言，这两种是模拟极端状况下来考验我们UI效果的。比如在表达相同语义时英语的长度要比汉语长很多，而德语又比英语长一些，这很可能让APP的界面造成混乱；而还有语言是从右到作的（古汉语的写法？），这也都是一些APP需要考虑的地方。</p>

<p>在Xcode6的Assistent Editor中我们可以无须在模拟器或真机上运行APP就可以在设计界面时预览界面的本地化效果，并在右下角的语言选项中切换语言：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-5%402x.png" alt="" /></p>

<p>PS：语言和地区这两个选项是有差别的，比如当我们将地区设置成瑞典，虽然我们没有提供对应的瑞典版本的界面文字翻译，但是时间日期的显示方式等还是会遵从瑞典的习惯来显示。所以地区这一项可供选择的选项包含了所有地区，而语言这一选项只包含了我们在国际化工作中所支持的语言，因为只有国际化中支持的语言（比如上图，我只加入了英语和汉语）才有相应的资源文件；而NSFormatter地区格式优化是内建的，无需我们提供格式。</p>

<h2>本地化&mdash;翻译你的APP</h2>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-8%402x.png" alt="" /></p>

<p>之前国际化的工作就是将工程变得有国际范儿，建立起了支持多语种的架构，那么接下来就是苦逼的翻译工作和本地资源准备工作，说好听点儿就叫本地化。</p>

<p>首先要把表面上的工作做了，也就是翻译用户界面上所有的文字。当然这不是程序员该干的活儿，更不能直接交给谷歌翻译，而程序员与专业翻译人员沟通时还是需要成本的：首先把需要翻译的内容从工程里整理出来，然后交给负责翻译的妹子，等妹子翻译好后再把结果导入工程中，嗯目测工作量亚历山大。PS：为什么翻译是妹子？</p>

<p>就算妹子再萌，也不能因为这占用了程序猿们宝贵的工作时间！Xcode6简化了导入导出这些资源的流程，它会检查IB资源和源文件并提取“source strings”，并生成XLIFF文件。翻译好的XLIFF文件也可以通过Xcode导入到工程中来生成和更新资源。嗯，可以把省下来的时间干一些其他的事情咯。</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-6%402x.png" alt="" /></p>

<p>PS：XLIFF是由软件开发商、本地化服务提供商、本地化工具提供商等团体共同倡议和设计，由OASIS标准组织发布的用于本地化数据交换的格式标准。它基于XML技术制定软件资源文件格式的转换规格，其目的在于提高软件的本地化作业效率。</p>

<p>导出和导出XLIFF就是如此简单，选中项目，在Editor菜单中可以就找到：</p>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-7%402x.png" alt="" /></p>

<p>也可以通过命令行的方式进行导入导出XLIFF文件操作：</p>

<p><code>
xcodebuide -exportLocalizations -project &lt;project&gt; -localizationPath &lt;path&gt;
xcodebuide -importLocalizations -project &lt;project&gt; -localizationPath &lt;path&gt;
</code></p>

<h2>迭代开发&mdash;更新你的APP</h2>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141002-10%402x.png" alt="" /></p>

<p>无需把翻译工作推到最后去做，因为导入和导出XLIFF文件是可以持续集成的，一边写代码，一边把现有内容导出XLIFF给他人翻译，这样能提高效率。每当有新的翻译修改时也可以及时更新，Xcode会把XLIFF文件内容与当前翻译进度合并；在导出XLIFF时可以选择导出当前开发使用的语言还是已经翻译中的语言，这些强大的服务无疑是Xcode6所赐予我们的。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode单元测试-XCTest]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/28/iosdan-yuan-ce-shi-xctest/"/>
    <updated>2014-04-28T13:25:12+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/28/iosdan-yuan-ce-shi-xctest</id>
    <content type="html"><![CDATA[<p>第一次接触单元测试还是在SQA课程上，那时我用的是JUnit来对Java程序进行单元测试。如今XCode自带的单元测试工具已经从OCUnit演变到了XCTest，但其本质还是差不多的，其好处在于XCode集成，简单方便</p>

<!--more-->


<p>在XCode5中新建一个工程的时候，会默认带一个用于单元测试的target，其名字为工程名加Test后缀，并且文件名也以Test结尾。你会发现已经有了一个默认的测试用例，其中有三个方法：<code>setUp</code>,<code>tearDown</code>,<code>testExample</code>。其中<code>testExample</code>方法左侧有一个播放按钮，点击它就会对这个方法进行测试，而在整个文件的<code>@implementation</code>那行也有个同样的按钮，点击后会对当前测试用例的所有方法进行测试，也可通过Command＋U快捷键来触发。这个测试用例类没有头文件，因为测试用例不需要给外部暴漏接口。按照苹果官方的文档，建立一个测试用例的过程应该是这样的：<br/>
1. 建立一个<code>XCTestCase</code>的子类
2. 实现测试方法
3. 选择性的定义一些实例变量来存储fixture的状态
4. 通过重写<code>setUp</code>方法选择性的实例化fixture
5. 通过重写<code>tearDown</code>方法来在测试后清除
测试方法没有参数和返回值，用test作为前缀，比如：</p>

<p><code>objc
 - (void) testSomething;
</code>
会自动被<code>XCTest</code>架构识别为测试用例，每个<code>XCTestCase</code>的子类中的<code>defaultTestSuite</code>都是一个<code>XCTestSuite</code>，它包含了这些测试用例。<br/>
测试方法的实现经常包含断言，必须通过验证才能通过测试，举个例子：</p>

<p>```
 @interface MathTest : XCTestCase {
 @private</p>

<pre><code>float f1;
float f2;
</code></pre>

<p> }</p>

<ul>
<li>(void) testAddition;</li>
</ul>


<p> @end</p>

<p> @implementation MathTest</p>

<ul>
<li><p>(void) setUp
{
 f1 = 2.0;
 f2 = 3.0;
}</p></li>
<li><p>(void) testAddition
{
 XCTAssertTrue (f1 + f2 == 5.0, @&ldquo;%f + %f should equal 5.0&rdquo;, f1, f2);
}
@end
```
感觉这根JUnit很像的，下面列出所有的断言：<br/>
XCTFail(format…) 生成一个失败的测试；</p></li>
</ul>


<p>XCTAssertNil(a1, format&hellip;)为空判断，a1为空时通过，反之不通过；</p>

<p>XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；</p>

<p>XCTAssert(expression, format&hellip;)当expression求值为TRUE时通过；</p>

<p>XCTAssertTrue(expression, format&hellip;)当expression求值为TRUE时通过；</p>

<p>XCTAssertFalse(expression, format&hellip;)当expression求值为False时通过；</p>

<p>XCTAssertEqualObjects(a1, a2, format&hellip;)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；</p>

<p>XCTAssertNotEqualObjects(a1, a2, format&hellip;)判断不等，[a1 isEqual:a2]值为False时通过，</p>

<p>XCTAssertEqual(a1, a2, format&hellip;)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</p>

<p>XCTAssertNotEqual(a1, a2, format&hellip;)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</p>

<p>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format&hellip;)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</p>

<p>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format&hellip;) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</p>

<p>XCTAssertThrows(expression, format&hellip;)异常测试，当expression发生异常时通过；反之不通过；（很变态）</p>

<p>XCTAssertThrowsSpecific(expression, specificException, format&hellip;) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</p>

<p>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format&hellip;)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p>

<p>XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；</p>

<p>XCTAssertNoThrowSpecific(expression, specificException, format&hellip;)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p>

<p>XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format&hellip;)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</p>

<p>关于测试函数执行的顺序：以函数名中test后面的字符大小有关，比如-（void）test001XXX会先于-（void）test002XXX执行；</p>

<p>这里只是Mark下单元测试的基本知识，具体应用的话这里推荐几篇不错的教程：</p>

<p><a href="http://objccn.io/issue-1-3/">测试 View Controllers</a><br/>
<a href="http://blog.csdn.net/jymn_chen/article/details/21552941">Xcode 5 单元测试（一）使用XCTest进行单元测试</a><br/>
<a href="http://blog.csdn.net/jymn_chen/article/details/21562869">Xcode 5 单元测试（二）OCMock和GHUnit</a><br/>
<a href="http://objccn.io/issue-15-2/">XCTest 测试实战</a></p>

<p>可能有的测试工具会用到CocoaPods来管理，给出一篇入门文章：</p>

<p><a href="http://blog.csdn.net/mysevenmi/article/details/17878421">iOS中使用cocoaPods管理第三方类库</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode中断点的威力]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/17/xcodezhong-duan-dian-de-wei-li/"/>
    <updated>2014-04-17T13:34:26+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/17/xcodezhong-duan-dian-de-wei-li</id>
    <content type="html"><![CDATA[<p><strong>本文转载自<a href="http://beyondvincent.com">破船</a></strong></p>

<hr />

<p>本文目录：</p>

<p><strong><span style="color: #339966;">1、添加一个特殊的断点</span></strong><br/>
<strong><span style="color: #339966;">    异常断点(Exception breakpoint)</span></strong><br/>
<strong><span style="color: #339966;">    符号断点(Symbolic breakpoint)</span></strong><br/>
<strong><span style="color: #339966;">2、打印到控制台</span></strong><br/>
<strong><span style="color: #339966;">    使用NSLog打印字符串</span></strong><br/>
<strong><span style="color: #339966;">    使用NSLog打印对象(po)</span></strong><br/>
<strong><span style="color: #339966;">    带条件的打印</span></strong><br/>
<strong><span style="color: #339966;">    在循环里面打印一些东西</span></strong><br/>
<strong><span style="color: #339966;">3、运行时设置断点</span></strong><br/>
<strong><span style="color: #339966;">4、调试中播放声音</span></strong><br/>
<strong><span style="color: #339966;">5、LLDB中有用的一些命令</span></strong><br/>
<strong><span style="color: #339966;">    打印帮助</span></strong><br/>
<strong><span style="color: #339966;">    打印调用栈</span></strong><br/>
<strong><span style="color: #339966;">    打印最基本的内容 (p)</span></strong><br/>
<strong><span style="color: #339966;">    打印对象(po)</span></strong><br/>
<strong><span style="color: #339966;">    打印表达式(expr)</span></strong><br/>
<strong><span style="color: #339966;">    打印线程中的一些东西</span></strong></p>

<p>&nbsp;</p>

<!--more-->


<p>正文</p>

<p>下面是非常有用的一些Xcode调试技术(使用断点和LLDB调试器)</p>

<p>1、添加一个特殊的断点</p>

<ul>
<li>异常断点(Exception breakpoint)</li>
</ul>


<p>如果添加了异常断点，当程序每次发生了异常，都会被中断。<strong><span style="color: #339966;">一般用来捕获未知异常</span></strong>。如下示例：</p>

<pre class="wp-code-highlight prettyprint linenums:1">*** Terminating app due to uncaught exception ’NSRangeException’, reason:
’-[__NSCFArray objectAtIndex:]: index (10) beyond bounds (3)</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-01.png"><img class="alignnone size-full wp-image-1497" alt="xcode-debug-01" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-01.png" width="1049" height="654" /></a></p>

<ul>
<li>符号断点(Symbolic breakpoint)</li>
</ul>


<p>符号断点可以中断某个函数的调用。</p>

<pre class="wp-code-highlight prettyprint linenums:1">- [UIViewController viewDidLoad]
- [__NSCFArray objectAtIndex:]</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-02.png"><img class="alignnone size-full wp-image-1498" alt="xcode-debug-02" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-02.png" width="1049" height="654" /></a></p>

<p>&nbsp;</p>

<p>2、打印到控制台</p>

<ul>
<li>使用NSLog打印字符串</li>
</ul>


<p>使用断点来替换NSLog代码(或者在运行时添加一个NSLog)——与代码写NSLog的效果相同。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-04.png"><img class="alignnone size-full wp-image-1499" alt="xcode-debug-04" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-04.png" width="1030" height="654" /></a></p>

<p>&nbsp;</p>

<ul>
<li>使用NSLog打印对象(po)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">NSLog(@"obj: %@", obj);</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-05.png"><img class="alignnone size-full wp-image-1500" alt="xcode-debug-05" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-05.png" width="1030" height="654" /></a></p>

<ul>
<li>带条件的打印</li>
</ul>


<p>例如：当aNumber大于10才打印出“str”的内容。</p>

<pre class="wp-code-highlight prettyprint linenums:1">expr (void)NSLog(@"Ok, print a log: %@", str)</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-07.png"><img class="alignnone size-full wp-image-1501" alt="xcode-debug-07" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-07.png" width="1030" height="681" /></a></p>

<p>&nbsp;</p>

<ul>
<li>在循环里面打印一些东西</li>
</ul>


<p>例如，在循环中希望i大于5才开始打印。</p>

<pre class="wp-code-highlight prettyprint linenums:1">for ( int i=0; i&lt;10; i++ )
{
[self self]; // something
}</pre>


<p>使用“ignore”值，并利用下面的代码进行打印：</p>

<pre class="wp-code-highlight prettyprint linenums:1">expr (void)NSLog(@"Ok, print a log: %@", str)</pre>


<p><img class="alignnone size-full wp-image-1502" alt="xcode-debug-08" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-08.png" width="1030" height="681" /></p>

<p>3、运行时设置断点</p>

<p>在运行的时候，根据条件设置断点有时候非常有用。</p>

<pre class="wp-code-highlight prettyprint linenums:1">breakpoint set -f APViewController.m -l 33</pre>


<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-09.png"><img class="alignnone size-full wp-image-1503" alt="xcode-debug-09" src="http://beyondvincent.com/wp-content/uploads/2013/07/xcode-debug-09.png" width="1030" height="681" /></a></p>

<p>4、调试中播放声音</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/07/Schermata-06-2456470-alle-15.43.13.png"><img class="alignnone size-full wp-image-1504" alt="Schermata-06-2456470-alle-15.43.13" src="http://beyondvincent.com/wp-content/uploads/2013/07/Schermata-06-2456470-alle-15.43.13.png" width="475" height="304" /></a></p>

<p>5、LLDB中有用的一些命令</p>

<p>当Xcode停留在某个断点时，我们可以通过控制台(console)与<strong><span style="color: #339966;">lldb</span></strong>进行交互。</p>

<ul>
<li>打印帮助</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) help</pre>


<ul>
<li>打印调用栈(bt)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) bt
* thread #1: tid = 0x1c03, 0x00003146 Debug`-[APViewController callMe:andANumber:](self=0x07187e50, _cmd=0x000038b9, str=0x0715aa40, aNum=38) + 230 at APViewController.m:33, stop reason = breakpoint 3.1
frame #0: 0x00003146 Debug`-[APViewController callMe:andANumber:](self=0x07187e50, _cmd=0x000038b9, str=0x0715aa40, aNum=38) + 230 at APViewController.m:33
frame #1: 0x0000304a Debug`-[APViewController viewDidLoad](self=0x07187e50, _cmd=0x005c5a77) + 122 at APViewController.m:16
frame #2: 0x000f41c7 UIKit`-[UIViewController loadViewIfRequired] + 536
frame #3: 0x000f4232 UIKit`-[UIViewController view] + 33
frame #4: 0x000433d5 UIKit`-[UIWindow addRootViewControllerViewIfPossible] + 66
frame #5: 0x0004376f UIKit`-[UIWindow _setHidden:forced:] + 368
frame #6: 0x00043905 UIKit`-[UIWindow _orderFrontWithoutMakingKey] + 49
frame #7: 0x0004c917 UIKit`-[UIWindow makeKeyAndVisible] + 65
frame #8: 0x00002e1b Debug`-[APAppDelegate application:didFinishLaunchingWithOptions:](self=0x07560750, _cmd=0x005a9c21, application=0x0716a640, launchOptions=0x00000000) + 571 at APAppDelegate.m:28
frame #9: 0x00010157 UIKit`-[UIApplication _handleDelegateCallbacksWithOptions:isSuspended:restoreState:] + 266
frame #10: 0x00010747 UIKit`-[UIApplication _callInitializationDelegatesForURL:payload:suspended:] + 1248
frame #11: 0x0001194b UIKit`-[UIApplication _runWithURL:payload:launchOrientation:statusBarStyle:statusBarHidden:] + 805
frame #12: 0x00022cb5 UIKit`-[UIApplication handleEvent:withNewEvent:] + 1022
frame #13: 0x00023beb UIKit`-[UIApplication sendEvent:] + 85
frame #14: 0x00015698 UIKit`_UIApplicationHandleEvent + 9874
frame #15: 0x01becdf9 GraphicsServices`_PurpleEventCallback + 339
frame #16: 0x01becad0 GraphicsServices`PurpleEventCallback + 46
frame #17: 0x01c06bf5 CoreFoundation`__CFRUNLOOP_IS_CALLING_OUT_TO_A_SOURCE1_PERFORM_FUNCTION__ + 53
frame #18: 0x01c06962 CoreFoundation`__CFRunLoopDoSource1 + 146
frame #19: 0x01c37bb6 CoreFoundation`__CFRunLoopRun + 2118
frame #20: 0x01c36f44 CoreFoundation`CFRunLoopRunSpecific + 276
frame #21: 0x01c36e1b CoreFoundation`CFRunLoopRunInMode + 123
frame #22: 0x0001117a UIKit`-[UIApplication _run] + 774
frame #23: 0x00012ffc UIKit`UIApplicationMain + 1211
frame #24: 0x00002b22 Debug`main(argc=1, argv=0xbffff3a4) + 130 at main.m:16
frame #25: 0x00002a55 Debug`start + 53
(lldb)</pre>


<ul>
<li>打印最基本的内容 (p)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) print anInt</pre>


<ul>
<li>打印对象(po)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) po anObj
(lldb) po 0x0715aa40</pre>


<ul>
<li>打印表达式(expr)</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) expr 5+2
(lldb) expr aString = @"aNewValue"</pre>


<ul>
<li>打印线程中的一些东西</li>
</ul>


<pre class="wp-code-highlight prettyprint linenums:1">(lldb) help frame</pre>



]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Xcode Code Snippets]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/17/xcode-code-snippets/"/>
    <updated>2014-04-17T13:18:02+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/17/xcode-code-snippets</id>
    <content type="html"><![CDATA[<p><strong>本文转载自<a href="http://beyondvincent.com">破船</a></strong></p>

<hr />

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/fend_off_rsi.jpg"><img class="alignnone size-full wp-image-734" alt="fend_off_rsi" src="http://beyondvincent.com/wp-content/uploads/2013/05/fend_off_rsi.jpg" width="1200" height="620" /></a></p>

<!--more-->


<p>在Double Encore，我们写的代码都是干净，可重用的——不过，有时候并不能完全做到。如在使用pragma mark的时候。下面就是一个示例：</p>

<pre class="wp-code-highlight prettyprint linenums:1">#pragma mark - UIViewController overrides</pre>


<p>通过pragma mark，可以让代码看起来既整洁又有组织。虽然这很重要，但是会带来额外的输入操作和时间。</p>

<p>此时，我们可以使用code snippets。</p>

<p>通过code snippets，我们可以创建一些可重用的代码块，并且在任何需要的地方很容易的就可以使用这些代码块。这可以节省输入需要的操作和时间。并且，一旦你学会使用code snippets，会发现你可以创建并扩充自己的code snippet library。</p>

<p>创建一个code snippet非常简单。首先，打开Xcode并在utilities panel中选择code snippet library。</p>

<p><a href="http://beyondvincent.com/wp-content/uploads/2013/05/1-1024x768.png"><img class="alignnone size-full wp-image-736" alt="1-1024x768" src="http://www.doubleencore.com/wp-content/uploads/2013/04/1-1024x768.png" width="1024" height="768" /></a></p>

<p>上图中，可以看到在code snippet library中已经有一些数据了。</p>

<p>接着，输入希望创建的code snippet。在这里，我为pragma mark创建一个code snippet。如下图所示，在代码编辑器中输入 “#pragma mark – UIViewController overrides”。</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/2-1024x768.png" width="1024" height="768" /></p>

<p>选中代码块，如下图所示：</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/3-1024x768.png" width="1024" height="768" /></p>

<p>然后单击并按住代码块，知道文本光标变为箭头光标。接着将代码块拖放到code snippet library中，然后松开鼠标。如下图所示</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/4-1024x768.png" width="1024" height="768" /></p>

<p>此时会弹出一个popover，通过该popover可以对新的code snippet进行编辑，如下图所示。</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/5-1024x768.png" width="1024" height="768" /></p>

<p>首先，是定snippet的名字。这里我指定为“Pragma Mark”</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/6-1024x768.png" width="1024" height="768" /></p>

<p>然后，指定该snippet的completion shortcut（可选项）。这里我指定为“pm”。这样设置以后，在Xcode的代码编辑器中只需要输入快捷方式（pm），就能简单的将这个snippet添加到代码中。非常有用！</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/7-1024x768.png" width="1024" height="768" /></p>

<p>接着，可以看到在上面的示例中，pragma mark的标题是“UIViewController overrides”，不过我们是希望对其修改一下，以能够很容易的输入任意标题。</p>

<p>我们可以简单的将code snippet包含的文本内容修改为“#pragma mark – “即可。不过，这里还有更好的一个办法——将文本块封装到“&lt;#” 和 “#>”中间，这样code snippet将指出我们可以插入自定义文本的完整范围。</p>

<p>下面，将“UIViewController overrides”替换…</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/8-1024x768.png" width="1024" height="768" /></p>

<p>&#8230;为“&lt;#Title#>”。</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/9-1024x768.png" width="1024" height="768" /></p>

<p>注意，completion scopes字段在这里并没有做修改，通过该字段可以指定completion shortcut的有效范围。</p>

<p>最后，点击edit按钮，以完成snippet的编辑。之后可以在这个popover画面中看到最终结果的一个预览效果。</p>

<p>&nbsp;</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/10-1024x768.png" width="1024" height="768" /></p>

<p>然后点击popover中的done按钮。下面，你可以将我们在代码编辑器中为创建snippet而写入的文本行删除掉。</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/11-1024x768.png" width="1024" height="768" /></p>

<p>现在来试用一下刚刚创建的snippet！有两种方法。第一种是在code snippet library中找到snippet，然后用鼠标将其拖拽到代码编辑器中&#8230;</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/12-1024x768.png" width="1024" height="768" /></p>

<p>&#8230;然后松开鼠标。</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/13-1024x768.png" width="1024" height="768" /></p>

<p>一旦将snippet拖放到代码编辑器之后，就可以通过点击键盘上的tab键在不同的completion字段间移动焦点。</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/14-1024x768.png" width="1024" height="768" /></p>

<p>第二种方法是在代码编辑器里简单的输入completion shortcut中设置的内容即可。我们这里是“pm”。</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/15-1024x768.png" width="1024" height="768" /></p>

<p>然后点击键盘中的return键，就可以将snippet插入到代码编辑器中。</p>

<p><img class="alignnone size-full wp-image-736" alt="" src="http://www.doubleencore.com/wp-content/uploads/2013/04/141-1024x768.png" width="1024" height="768" /></p>

<p>很简单吧！现在你已经知道如何创建自己的snippet了，你将发现这非常的有用。任何时候，你都遇到重复输入的相同代码块，都可以考虑将其添加到你的code snippets library中。</p>

<p>&nbsp;</p>

<p>下面是我经常使用到的一些snippet：</p>

<pre class="wp-code-highlight prettyprint linenums:1">Title: Animation Block
Completion Shortcut: ab
Completion Scopes: Function or Method
 
void (^&lt;#Title#&gt;)(void) = ^{ };
</pre>




<pre class="wp-code-highlight prettyprint linenums:1">Title: Animation Completion Block
Completion Shortcut: acb
Completion Scopes: Function or Method
 
void (^&lt;#Title#&gt;)(BOOL) = ^(BOOL finished) { };
</pre>




<pre class="wp-code-highlight prettyprint linenums:1">Title: Notification Add
Completion Shortcut: na
Completion Scopes: Function or Method
 
[[NSNotificationCenter defaultCenter] addObserver:&lt;#Observer#&gt; selector:&lt;#Selector#&gt; name:&lt;#Name#&gt; object:&lt;#Object#&gt;];
</pre>




<pre class="wp-code-highlight prettyprint linenums:1">Title: Notification Remove
Completion Shortcut: nr
Completion Scopes: Function or Method
 
[[NSNotificationCenter defaultCenter] removeObserver:&lt;#Observer#&gt; name:&lt;#Name#&gt; object:&lt;#Object#&gt;];
</pre>




<pre class="wp-code-highlight prettyprint linenums:1">Title: NSLog
Completion Shortcut: log
Completion Scopes: Function or Method
 
NSLog(@"&lt;#Log#&gt;");
</pre>




<pre class="wp-code-highlight prettyprint linenums:1">Title: Private Interface
Completion Shortcut: pi
Completion Scopes: Top Level
 
@interface &lt;#Title#&gt; ()

@end
</pre>




<pre class="wp-code-highlight prettyprint linenums:1">Title: Property Assign
Completion Shortcut: pa
Completion Scopes: All
 
@property (assign, nonatomic)
</pre>




<pre class="wp-code-highlight prettyprint linenums:1">Title: Property Strong
Completion Shortcut: ps
Completion Scopes: All
 
@property (strong, nonatomic)
</pre>




<pre class="wp-code-highlight prettyprint linenums:1">Title: Property Unsafe Unretained
Completion Shortcut: pu
Completion Scopes: All
 
@property (unsafe_unretained, nonatomic)
</pre>




<div style="text-align: left;">
</div>




<div style="text-align: left;">
</div>



]]></content>
  </entry>
  
</feed>
