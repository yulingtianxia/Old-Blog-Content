<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 设计模式 | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/she-ji-mo-shi/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-11-11T22:12:09+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C中的KVC和KVO]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/"/>
    <updated>2014-05-12T12:02:32+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo</id>
    <content type="html"><![CDATA[<p>本文讲述了使用Cocoa框架中的KVC和KVO，实现观察者模式</p>

<!--more-->


<h2>KVC</h2>

<p>键/值编码中的基本调用包括<code>-valueForKey:</code>和<code>-setValue:forKey:</code>。以字符串的形式向对象发送消息，这个字符串是我们关注的属性的关键。<br/>
<code>valueForKey:</code>首先查找以键<code>-key</code>或<code>-isKey   </code>命名的getter方法。如果不存在getter方法（假如我们没有通过<code>@synthesize</code>提供存取方法），它将在对象内部查找名为<code>_key</code>或<code>key</code>的实例变量。<br/>
对于KVC，Cocoa自动放入和取出标量值（int，float和struct）放入NSNumber或NSValue中；当使用<code>-setValue:ForKey:</code>时，它自动将标量值从这些对象中取出。仅KVC具有这种自动包装功能，常规方法调用和属性语法不具备该功能。<br/>
<code>-setValue:ForKey:</code>的工作方式和<code>-valueForKey:</code>相同。它首先查找名称的setter方法，如果不存在setter方法，它将在类中查找名为<code>_key</code>或<code>key</code>的实例变量。</p>

<p>使用KVC访问属性的代价比直接使用存取方法要大，所以只在需要的时候才用。</p>

<p>最简单的 KVC 能让我们通过以下的形式访问属性：</p>

<p><code>objc
@property (nonatomic, copy) NSString *name;
</code></p>

<p>取值：</p>

<p><code>
NSString *n = [object valueForKey:@"name"];
</code>
设定：</p>

<p><code>
[object setValue:@"Daniel" forKey:@"name"];
</code>
值得注意的是这个不仅可以访问作为对象属性，而且也能访问一些标量（例如 int 和 CGFloat）和 struct（例如 CGRect）。Foundation 框架会为我们自动封装它们。举例来说，如果有以下属性：</p>

<p><code>
@property (nonatomic) CGFloat height;
</code>
我们可以这样设置它：</p>

<p><code>
[object setValue:@(20) forKey:@"height"];
</code></p>

<p>有关KVC的更多用法，参看下面的文章：</p>

<p><a href="http://blog.csdn.net/omegayy/article/details/7381301  ">http://blog.csdn.net/omegayy/article/details/7381301  </a>
<a href="http://blog.csdn.net/wzzvictory/article/details/9674431  ">http://blog.csdn.net/wzzvictory/article/details/9674431  </a>
<a href="http://objccn.io/issue-7-3/">http://objccn.io/issue-7-3/</a></p>

<h2>KVO</h2>

<p>KVO是Cocoa提供的一种称为键－值观察的机制，对象可以通过它得到其他对象特性属性的变更通知。这种机制在MVC模式的场景中很重要，因为它让视图对象可以经由控制器层观察模型对象的变更。<br/>
这一机制基于NSKeyValueObserving非正式协议，Cocoa通过这个协议为所有遵守协议的对象提供了一种自动化的属性观察能力。要实现自动观察，参与KVO的对象需要符合KVC的要求和存取方法，也可以手动实现观察者通知，也可以两者都保留。</p>

<p>KVO是Cocoa框架使用<strong>观察者模式</strong>的一种途径。</p>

<p>设置一个属性的观察者需要三步，理解这些步骤可以更清楚的知道KVO的工作框图<br/>
1. 首先看看你当前的场景如果使用KVO是否更妥当，比如，当一个实例的某个具体属性有任何变更的时候，另一个实例需要被通知。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353389577.jpg" alt="" /></p>

<p>比如，BankObject中的accountBalance属性有任何变更时，某个PersonObject对象都要觉察到。<br/>
2. 这个PersonObject对象必须注册成为BankObject的accountBalance属性的观察者，可以通过发送<code>addObserver:forKeyPath:options:context:</code>消息来实现。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353389319.jpg" alt="" /></p>

<p>注意：<code>addObserver:forKeyPath:options:context:</code>方法在你指定的两个实例间建立联系，而不是在两个类之间。<br/>
3. 为了回应变更通知，观察者必须实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法。这个方法的实现决定了观察者如何回应变更通知。你可以在这个方法里自定义如何回应被观察属性的变更。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353388989.jpg" alt="" />  <br/>
4. 当一个被观察属性的值以符合KVO方式变更或者当它依赖的键变更时，<code>observeValueForKeyPath:ofObject:change:context:</code>方法会被自动执行。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353389524.jpg" alt="" /></p>

<h3>Registering for Key-Value Observing</h3>

<h4>注册成为观察者</h4>

<p>你可以通过发送<code>addObserver:forKeyPath:options:context:</code>消息来注册观察者</p>

<p>``` objc
&ndash; (void)registerAsObserver {</p>

<pre><code>/*
 Register 'inspector' to receive change notifications for the "openingBalance" property of
 the 'account' object and specify that both the old and new values of "openingBalance"
 should be provided in the observe… method.
 */
[account addObserver:inspector
         forKeyPath:@"openingBalance"
             options:(NSKeyValueObservingOptionNew |
                        NSKeyValueObservingOptionOld)
                context:NULL];
</code></pre>

<p>}
```</p>

<p>inspector注册成为了account的观察者，被观察属性的KeyPath是@&ldquo;openingBalance"，也就是account的openingBalance属性，NSKeyValueObservingOptionNew和NSKeyValueObservingOptionOld选项分别标识在观察者接收通知时change字典对应入口提供更改后的值和更改前的值。更简单的办法是用 NSKeyValueObservingOptionPrior 选项，随后我们就可以用以下方式提取出改变前后的值：(change是个字典，详细介绍请看下节)</p>

<p><code>
id oldValue = change[NSKeyValueChangeOldKey];
id newValue = change[NSKeyValueChangeNewKey];
</code></p>

<p>我们常常需要当一个值改变的时候更新 UI，但是我们也要在第一次运行代码的时候更新一次 UI。我们可以用 KVO 并添加 NSKeyValueObservingOptionInitial 的选项 来一箭双雕地做好这样的事情。这将会让 KVO 通知在调用 -addObserver:forKeyPath:&hellip; 到时候也被触发。<br/>
当我们注册 KVO 通知的时候，我们可以添加 NSKeyValueObservingOptionPrior 选项，这能使我们在键值改变之前被通知。这和-willChangeValueForKey:被触发的时间相对应。<br/>
如果我们注册通知的时候附加了 NSKeyValueObservingOptionPrior 选项，我们将会收到两个通知：一个在值变更前，另一个在变更之后。变更前的通知将会在 change 字典中有不同的键。</p>

<p>context是一个指针，当<code>observeValueForKeyPath:ofObject:change:context:</code>方法执行时context会提供给观察者。context可以使C指针或者一个对象引用，既可以当作一个唯一的标识来分辨被观察的变更，也可以向观察者提供数据。</p>

<h4>接收变更通知</h4>

<p>当被观察的属性变更时，观察者会接到<code>observeValueForKeyPath:ofObject:change:context:</code>消息，所有的观察者都必须实现这个方法。<br/>
观察者会被提供触发通知的对象和key path，一个包含变更详细信息的字典，还有一个注册观察者时提供的context指针。</p>

<p>```
&ndash; (void)observeValueForKeyPath:(NSString *)keyPath</p>

<pre><code>                  ofObject:(id)object
                    change:(NSDictionary *)change
                   context:(void *)context {

if ([keyPath isEqual:@"openingBalance"]) {
    [openingBalanceInspectorField setObjectValue:
        [change objectForKey:NSKeyValueChangeNewKey]];
}
/*
 Be sure to call the superclass's implementation *if it implements it*.
 NSObject does not implement the method.
 */
[super observeValueForKeyPath:keyPath
                     ofObject:object
                       change:change
                       context:context];
</code></pre>

<p>}
```
关于change参数，它是一个字典，有五个常量作为它的键：</p>

<p>NSString <em>const NSKeyValueChangeKindKey;<br/>
NSString </em>const NSKeyValueChangeNewKey;<br/>
NSString <em>const NSKeyValueChangeOldKey;<br/>
NSString </em>const NSKeyValueChangeIndexesKey;<br/>
NSString *const NSKeyValueChangeNotificationIsPriorKey;</p>

<p><strong>NSKeyValueChangeKindKey</strong><br/>
指明了变更的类型，值为“NSKeyValueChange”枚举中的某一个，类型为NSNumber。</p>

<p><code>
enum {
   NSKeyValueChangeSetting = 1,
   NSKeyValueChangeInsertion = 2,
   NSKeyValueChangeRemoval = 3,
   NSKeyValueChangeReplacement = 4
};
typedef NSUInteger NSKeyValueChange;
</code>
<strong>NSKeyValueChangeNewKey</strong><br/>
如果 NSKeyValueChangeKindKey的值为 NSKeyValueChangeSetting，并且 NSKeyValueObservingOptionNew选项在注册观察者时也指定了，那么这个键的值就是属性变更后的新值。<br/>
对于 NSKeyValueChangeInsertion或者NSKeyValueChangeReplacement，如果 NSKeyValueObservingOptionNew选项在注册观察者时也指定了，这个键的值是一个数组，其包含了插入或替换的对象。<br/>
<strong>NSKeyValueChangeOldKey</strong><br/>
如果 NSKeyValueChangeKindKey的值为 NSKeyValueChangeSetting，并且 NSKeyValueObservingOptionOld选项在注册观察者时也指定了，那么这个键的值就是属性变更前的旧值。<br/>
对于  NSKeyValueChangeRemoval 或者NSKeyValueChangeReplacement，如果 NSKeyValueObservingOptionOld选项在注册观察者时也指定了，这个键的值是一个数组，其包含了被移除或替换的对象。<br/>
<strong>NSKeyValueChangeIndexesKey</strong><br/>
如果 NSKeyValueChangeKindKey的值为NSKeyValueChangeInsertion, NSKeyValueChangeRemoval, 或者 NSKeyValueChangeReplacement，这个键的值是一个NSIndexSet对象，包含了增加，移除或者替换对象的index。<br/>
<strong>NSKeyValueChangeNotificationIsPriorKey</strong><br/>
如果注册观察者时NSKeyValueObservingOptionPrior选项被指明了，此通知会在变更发生前被发出。其类型为NSNumber，包含的值为YES。我们可以像以下这样区分通知是在改变之前还是之后被触发的：</p>

<p>```
if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) {</p>

<pre><code>// 改变之前
</code></pre>

<p>} else {</p>

<pre><code>// 改变之后
</code></pre>

<p>}
```</p>

<h4>移除观察者</h4>

<p>你可以通过发送<code>removeObserver:forKeyPath:</code>消息来移除观察者，你需要指明观察对象和路径。</p>

<p>```
&ndash; (void)unregisterForChangeNotification {</p>

<pre><code>[observedObject removeObserver:inspector forKeyPath:@"openingBalance"];
</code></pre>

<p>}
<code>``
上面的代码将openingBalance属性的观察者inspector移除，移除后观察者再也不会收到</code>observeValueForKeyPath:ofObject:change:context:`消息。<br/>
在移除观察者之前，如果context是一个对象的引用，那么必须保持对它的强引用直到观察者被移除。</p>

<h3>KVO Compliance（KVO兼容）</h3>

<p>有两种方法可以保证变更通知被发出。自动发送通知是NSObject提供的，并且一个类中的所有属性都默认支持，只要是符合KVO的。一般情况你使用自动变更通知，你不需要写任何代码。<br/>
人工变更通知需要些额外的代码，但也对通知发送提供了额外的控制。你可以通过重写子类<code>automaticallyNotifiesObserversForKey:</code>方法的方式控制子类一些属性的自动通知。</p>

<h4>Automatic Change Notification（自动通知）</h4>

<p>下面代码中的方法都能导致KVO变更消息发出</p>

<p>```
// Call the accessor method.
[account setName:@&ldquo;Savings&rdquo;];</p>

<p>// Use setValue:forKey:.
[account setValue:@&ldquo;Savings&rdquo; forKey:@&ldquo;name&rdquo;];</p>

<p>// Use a key path, where &lsquo;account&rsquo; is a kvc-compliant property of &lsquo;document&rsquo;.
[document setValue:@&ldquo;Savings&rdquo; forKeyPath:@&ldquo;account.name&rdquo;];</p>

<p>// Use mutableArrayValueForKey: to retrieve a relationship proxy object.
Transaction <em>newTransaction = &lt;#Create a new transaction for the account#>;
NSMutableArray </em>transactions = [account mutableArrayValueForKey:@&ldquo;transactions&rdquo;];
[transactions addObject:newTransaction];
```</p>

<h4>Manual Change Notification（手动通知）</h4>

<p>下面的代码为openingBalance属性开启了人工通知，并让父类决定其他属性的通知方式。</p>

<p>```
+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey {</p>

<pre><code>BOOL automatic = NO;
if ([theKey isEqualToString:@"openingBalance"]) {
    automatic = NO;
}
else {
    automatic = [super automaticallyNotifiesObserversForKey:theKey];
}
return automatic;
</code></pre>

<p>}
```</p>

<p>要实现人工观察者通知，你要执行在变更前执行<code>willChangeValueForKey:</code>方法，在变更后执行<code>didChangeValueForKey:</code>方法：</p>

<p>```
&ndash; (void)setOpeningBalance:(double)theBalance {</p>

<pre><code>[self willChangeValueForKey:@"openingBalance"];
_openingBalance = theBalance;
[self didChangeValueForKey:@"openingBalance"];
</code></pre>

<p>}
```
为了使不必要的通知最小化我们应该在变更前先检查一下值是否变了：</p>

<p>```
&ndash; (void)setOpeningBalance:(double)theBalance {</p>

<pre><code>if (theBalance != _openingBalance) {
    [self willChangeValueForKey:@"openingBalance"];
    _openingBalance = theBalance;
    [self didChangeValueForKey:@"openingBalance"];
}
</code></pre>

<p>}
```
如果一个操作导致了多个键的变化，你必须嵌套变更通知：</p>

<p>```
&ndash; (void)setOpeningBalance:(double)theBalance {</p>

<pre><code>[self willChangeValueForKey:@"openingBalance"];
[self willChangeValueForKey:@"itemChanged"];
_openingBalance = theBalance;
_itemChanged = _itemChanged+1;
[self didChangeValueForKey:@"itemChanged"];
[self didChangeValueForKey:@"openingBalance"];
</code></pre>

<p>}
```
在to-many关系操作的情形中，你不仅必须表明key是什么，还要表明变更类型和影响到的索引。变更类型是一个 NSKeyValueChange值，被影响对象的索引是一个 NSIndexSet对象。<br/>
下面的代码示范了在to-many关系transactions对象中的删除操作：</p>

<p>```
&ndash; (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes {</p>

<pre><code>[self willChange:NSKeyValueChangeRemoval
    valuesAtIndexes:indexes forKey:@"transactions"];

// Remove the transaction objects at the specified indexes.

[self didChange:NSKeyValueChangeRemoval
    valuesAtIndexes:indexes forKey:@"transactions"];
</code></pre>

<p>}
```</p>

<h3>Registering Dependent Keys（注册依赖的属性）</h3>

<p>有一些属性的值取决于一个或者多个其他对象的属性值，一旦某个被依赖的属性值变了，依赖它的属性的变化也需要被通知。</p>

<h4>To-one Relationships</h4>

<p>要自动触发 to-one关系，有两种方法：重写<code>keyPathsForValuesAffectingValueForKey:</code>方法或者定义名称为<code>keyPathsForValuesAffecting&lt;Key&gt;</code>的方法。</p>

<p>例如一个人的全名是由姓氏和名子组成的：</p>

<p>```
&ndash; (NSString *)fullName {</p>

<pre><code>return [NSString stringWithFormat:@"%@ %@",firstName, lastName];
</code></pre>

<p>}
```
一个观察fullName的程序在firstName或者lastName变化时也应该接收到通知。</p>

<p>一种解决方法是重写<code>keyPathsForValuesAffectingValueForKey:</code>方法来表明fullname属性是依赖于firstname和lastname的：</p>

<p>```
+ (NSSet <em>)keyPathsForValuesAffectingValueForKey:(NSString </em>)key {</p>

<pre><code>NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];

if ([key isEqualToString:@"fullName"]) {
    NSArray *affectingKeys = @[@"lastName", @"firstName"];
    keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];
}
return keyPaths;
</code></pre>

<p>}
```
相当于在影响fullName值的keypath中新加了两个key：lastName和firstName，很容易理解。</p>

<p>另一种实现同样结果的方法是实现一个遵循命名方式为<code>keyPathsForValuesAffecting&lt;Key&gt;</code>的类方法，<Key>是依赖于其他值的属性名（首字母大写），用上面代码的例子来重新实现一下：</p>

<p>```
+ (NSSet *)keyPathsForValuesAffectingFullName {</p>

<pre><code>return [NSSet setWithObjects:@"lastName", @"firstName", nil];
</code></pre>

<p>}
```</p>

<p>有时在类别中我们不能添加<code>keyPathsForValuesAffectingValueForKey:</code>方法，因为不能再类别中重写方法，所以这时可以实现<code>keyPathsForValuesAffecting&lt;Key&gt;</code>方法来代替。</p>

<p>注意：你不能在<code>keyPathsForValuesAffectingValueForKey:</code>方法中设立to-many关系的依赖，相反，你必须观察在to-many集合中的每一个对象中相关的属性并通过亲自更新他们的依赖来回应变更。下一节将会讲述对付此情形的策略。</p>

<h4>To-many Relationships</h4>

<p><code>keyPathsForValuesAffectingValueForKey:</code>方法不支持包含to-many关系的keypath。比如，假如你有一个Department类，它有一个针对Employee类的to-many关系（雇员），Employee类有salary属性。你希望Department类有一个totalSalary属性来计算所有员工的薪水，也就是在这个关系中Department的totalSalary依赖于所有Employee的salary属性。你不能通过实现<code>keyPathsForValuesAffectingTotalSalary</code>方法并返回<code>employees.salary</code>。</p>

<p>有两种解决方法：<br/>
1. 你可以用KVO将parent（比如Department）作为所有children（比如Employee）相关属性的观察者。你必须在把child添加或删除到parent时也把parent作为child的观察者添加或删除。在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中我们可以针对被依赖项的变更来更新依赖项的值：</p>

<p>```
&ndash; (void)observeValueForKeyPath:(NSString <em>)keyPath ofObject:(id)object change:(NSDictionary </em>)change context:(void *)context {</p>

<pre><code>if (context == totalSalaryContext) {
    [self updateTotalSalary];
}
else
// deal with other observations and/or invoke super...
</code></pre>

<p>}</p>

<ul>
<li><p>(void)updateTotalSalary {
  [self setTotalSalary:[self valueForKeyPath:@&ldquo;<a href="&#109;&#x61;&#105;&#x6c;&#x74;&#111;&#x3a;&#x65;&#x6d;&#x70;&#x6c;&#111;&#121;&#101;&#101;&#115;&#46;&#64;&#x73;&#117;&#109;&#x2e;&#x73;&#97;&#x6c;&#x61;&#114;&#x79;">&#101;&#109;&#x70;&#108;&#x6f;&#121;&#x65;&#101;&#115;&#x2e;&#x40;&#x73;&#117;&#109;&#46;&#115;&#x61;&#108;&#97;&#x72;&#121;</a>&rdquo;]];
}</p></li>
<li><p>(void)setTotalSalary:(NSNumber *)newTotalSalary {</p>

<p>  if (totalSalary != newTotalSalary) {
      [self willChangeValueForKey:@&ldquo;totalSalary&rdquo;];
      _totalSalary = newTotalSalary;
      [self didChangeValueForKey:@&ldquo;totalSalary&rdquo;];
  }
}</p></li>
<li><p>(NSNumber *)totalSalary {
  return _totalSalary;
}
```</p></li>
</ul>


<p>2.如果你在使用Core Data，你可以在应用的notification center中将parent注册为它的 managed object context的观察者，parent应该回应相应的变更通知，这些通知是children以类似KVO的形式发出的。</p>

<p>其实这也是Objective-C中利用Cocoa实现观察者模式的另一种途径：NSNotificationCenter</p>

<h3>调试KVO</h3>

<p>你可以在 lldb 里查看一个被观察对象的所有观察信息。</p>

<p><code>
(lldb) po [observedObject observationInfo]
</code>
这会打印出有关谁观察谁之类的很多信息。</p>

<p>这个信息的格式不是公开的，我们不能让任何东西依赖它，因为苹果随时都可以改变它。不过这是一个很强大的排错工具。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[装饰者模式]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi/"/>
    <updated>2014-05-10T09:47:05+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353405846.png" alt="" /></p>

<!--more-->


<ul>
<li>装饰者和被装饰对象有相同的超类型。</li>
<li>你可以用一个或多个装饰者包装一个对象。</li>
<li>既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合 ,可以用装饰过的对象代替它。</li>
<li><strong>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。</strong></li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰
对象。</li>
</ul>


<p><strong>类应该对扩展开放，对修改关闭。</strong></p>

<h2>用配置咖啡饮料做例子</h2>

<p>比如，现在有一个饮料类（Beverage），向饮料中添加不同的配料（蒸奶（Steamed Milk）、豆浆（Soy）、
摩卡（Mocha，也就是巧克力风味）或覆盖奶泡），就会配制出很多种不同的种类的饮料，其价格也随着添加的配料而变化，饮料店需要计算价格，如果用具体子类继承饮料类并考虑到所有组合的话，将是一个“类爆炸”：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353406269.png" alt="" /></p>

<p>更恶心的是，如果某种配料的价格有变化，就必须含有此配料相应的更改一些饮料子类的实现，记住：<strong>类应该对扩展开放，对修改关闭。</strong></p>

<p>应用装饰者模式，就像给对象穿衣服一样一层一层将拓展动态的添加上去，灵活多变有弹性</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353407109.png" alt="" /></p>

<p>下面用Java实现这个例子</p>

<p>Beverage是一个抽象类，有两个方法：getDescrip-tion()及cost（）</p>

<p><code>java
public abstract class Beverage {
String description = "Unknown Beverage";
public String getDescription() {
return description;
}
public abstract double cost();
}
</code>
Beverage很简单。让我们也来实现Condiment（配料）抽象类，也就是装饰者类吧：</p>

<p><code>
public abstract class CondimentDecorator extends Beverage {
public abstract String getDescription();
}
</code>
必须让Condiment Decorator能够取代Beverage，所以将CondimentDecorator扩展自 Beverage 类</p>

<p>现在，已经有了基类，让我们开始开始实现一些饮料吧！先从浓缩咖啡（Espresso）开始。别忘了，我们需要为具体的饮料设置描述，而且还必须实现cost()方法</p>

<p><code>
public class Espresso extends Beverage {
public Espresso() {
description = "Espresso";
}
public double cost() {
return 1.99;
}
}
</code></p>

<p>其他几种具体的饮料就不写了</p>

<p>如果你回头去看看装饰者模式的类图，将发现我们已经完成了抽象组件（Beverage），有了具体组件（HouseBlend），也有了抽象装饰者（CondimentDecorator）。现在，我们就来实现具体装饰者。先从摩卡下手：</p>

<p><code>
public class Mocha extends CondimentDecorator {
Beverage beverage;
public Mocha(Beverage beverage) {
this.beverage = beverage;
}
public String getDescription() {
return beverage.getDescription() + ", Mocha";
}
public double cost() {
return .20 + beverage.cost();
}
}
</code></p>

<p>你会发现在装饰者类中，完成了描述和价格的效果添加，也就是完成了拓展</p>

<p>其他几种配料代码就不写了</p>

<p>下面进行测试：</p>

<p><code>
public class StarbuzzCoffee {
public static void main(String args[]) {
Beverage beverage = new Espresso();
System.out.println(beverage.getDescription()
+ " $" + beverage.cost());
Beverage beverage2 = new DarkRoast();
beverage2 = new Mocha(beverage2);
beverage2 = new Mocha(beverage2);
beverage2 = new Whip(beverage2);
System.out.println(beverage2.getDescription()
+ " $" + beverage2.cost());
Beverage beverage3 = new HouseBlend();
beverage3 = new Soy(beverage3);
beverage3 = new Mocha(beverage3);
beverage3 = new Whip(beverage3);
System.out.println(beverage3.getDescription()
+ " $" + beverage3.cost());
}
}
</code></p>

<p>输出结果：</p>

<p>```
% java StarbuzzCoffee<br/>
Espresso $1.99<br/>
Dark Roast Coffee, Mocha, Mocha, Whip $1.49<br/>
House Blend Coffee, Soy, Mocha, Whip $1.34<br/>
%</p>

<p>```
果然是一层套一层吧：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353407345.png" alt="" /></p>

<h2>Java中的装饰者</h2>

<p>java.io包内的类太多了，简直是……“排山倒海”。你第一次（还有第二次和第三次）看到这些API发出“哇”的惊叹时，放心，你不是唯一受到惊吓的人。现在，你已经知道装饰者模式，这些I/O的相关类对你来说应该更有意义了，因为其中许多类都是装饰者。下面是一个典型的对象集合，用装饰者来将功能结合起来，以读取文件数据：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353408228.png" alt="" /></p>

<p><code>BufferedInputStream</code>及<code>LineNumberInputStream</code>都扩展自<code>FilterInputStream</code>，而<code>FilterInputStream</code>是一个抽象的装饰类。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353408237.png" alt="" /></p>

<p>你会发现“输出”流的设计方式也是一样的。你可能还会发现Reader/Writer流（作为基于字符数据的输入输出）和输入流/输出流的类相当类似（虽然有一些小差异和不一致之处，但是相当雷同，所以你应该可以了解这些类）。</p>

<p>但是JavaAI/O也引出装饰者模式的一个“缺点”：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。但是，现在你已经了解了装饰者的工作原理，以后当使用别人的大量装饰的API时，就可以很容易地辨别出他们的装饰者类是如何组织的，以方便用包装方式取得想要的行为。</p>

<h2>Objective-C类别与装饰模式</h2>

<p>Objective-C中也可以实现基于继承和接口的装饰者模式，但这里介绍的是另一种实现方法：类别</p>

<p>类别是一个Objective-C的语言功能，通过它可以向类添加行为（方法的接口与实现），而不必进行子类化。通过类别添加的方法对类原有的方法没有不良影响。类别中的方法成为了类的一部分，并可由其子类继承。</p>

<p>我们可以用类别来实现装饰模式，然而这不是一种严格的实现，它实现了模式的意图，但却是一种变体。由装饰器类别添加的行为是编译时绑定的，虽然Objective-C原本支持动态绑定（应该用方法的哪个实现）。而且装饰器类别实际上没有封装被扩展的类的实例。</p>

<p>尽管使用类别来实现这个模式跟原始风格有些偏离，但是实现少量的装饰器的时候，它比真正子类的方式更为轻量、更为容易。</p>

<p>这次我们来装饰一张照片，装饰的方法有很多，比如旋转位移变换，阴影。。。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353408757.png" alt="" /></p>

<p>工程代码可以在<a href="https://github.com/yulingtianxia/Decorator">这里</a>下载</p>

<p>这一方式中有三个类别：UIImage(BaseFilter),UIImage(Transform)和UIImage(Shadow)。从现在起，我把它们分别简称为BaseFilter、Transform和Shadow。BaseFilter定义了几个基本的二维绘图操作，使用当前绘图上下文绘制自己，其他滤镜类别可以使用同样的方法来绘制图像。Transform和Shadow没有继承BaseFilter，但他们属于同一类，因为他们都是UIImage的类别。BaseFilter中定义的方法也能在Transform和Shadow类别中使用，而不必像子类化那样进行继承。</p>

<p>UIImage(BaseFilter)中的方法定义，用户绘制图像，相当于装饰者抽象类，而UIImage则是被装饰的组件:</p>

<p>``` objc</p>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (BaseFilter)
&ndash; (CGContextRef) beginContext
{</p>

<pre><code>CGSize size = [self size];
UIGraphicsBeginImageContextWithOptions(size, NO, 0);
CGContextRef context = UIGraphicsGetCurrentContext();

return context;
</code></pre>

<p>}</p>

<ul>
<li><p>(UIImage *) getImageFromCurrentImageContext
{
  [self drawAtPoint:CGPointZero];</p>

<p>  // Retrieve the UIImage from the current context
  UIImage *imageOut = UIGraphicsGetImageFromCurrentImageContext();</p>

<p>  return imageOut;
}</p></li>
<li><p>(void) endContext
{
  UIGraphicsEndImageContext();
}
@end
```</p></li>
</ul>


<p>Transform类别定义了一个<code>imageWithTransform:transform</code>方法，接受一个转换引用，然后把应用于内部的图像引用，并让它把自己画出来，然后返回变换后的图像:</p>

<p>```</p>

<h1>import &ldquo;UIImage+Transform.h&rdquo;</h1>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (Transform)
&ndash; (UIImage *) imageWithTransform:(CGAffineTransform)transform
{</p>

<pre><code>CGContextRef context = [self beginContext];

// setup transformation
CGContextConcatCTM(context, transform);

// Draw the original image to the context
UIImage *imageOut = [self getImageFromCurrentImageContext];

[self endContext];

return imageOut;
</code></pre>

<p>}
@end
```</p>

<p>Shadow类别定义了一个<code>imageWithDropShadow</code>方法，向图像的内部引用添加阴影效果，并返回应用效果之后的最终图像。</p>

<p>```</p>

<h1>import &ldquo;UIImage+Shadow.h&rdquo;</h1>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (Shadow)
&ndash; (UIImage *) imageWithDropShadow
{</p>

<pre><code>CGContextRef context = [self beginContext];

// set up shadow
CGSize offset = CGSizeMake (-25,  15);
CGContextSetShadow(context, offset, 20.0);

// Draw the original image to the context
UIImage * imageOut = [self getImageFromCurrentImageContext];

[self endContext];

return imageOut;
</code></pre>

<p>}
@end
```
最后在ViewController中加载图像：</p>

<p>```
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.
UIImage *image = imageView.image;


// create a transformation
CGAffineTransform rotateTransform = CGAffineTransformMakeRotation(-M_PI / 4.0);
CGAffineTransform translateTransform = CGAffineTransformMakeTranslation(-image.size.width / 2.0,
                                                                        image.size.height / 8.0);
CGAffineTransform finalTransform = CGAffineTransformConcat(rotateTransform, translateTransform);
UIImage* finalImage = [[image imageWithTransform:finalTransform] imageWithDropShadow];
[imageView setImage:finalImage];
</code></pre>

<p>}
```</p>

<p>因为类别只能拓展方法，不能在原有类的基础上添加属性，但是我们依然可以通过下面的方式向类中动态添加属性，来弥补类别的不足：</p>

<p>给UIImage添加一个新的title属性<br/>
具体代码如下：<br/>
<code>UIImage+Title.h</code>:</p>

<p><code>
@interface UIImage(Title)
@property(nonatomic, copy) NSString *title;
@end
</code>
<code>UIImage+Title.m</code>:</p>

<p>```</p>

<h1>import &ldquo;UIImage+Title.h&rdquo;</h1>

<p>static char titleKey;</p>

<p>@implementation UIImage(Title)
&ndash; (NSString *)title
{</p>

<pre><code>return objc_getAssociatedObject(self, &amp;titleKey);
</code></pre>

<p>}</p>

<ul>
<li>(void)setTitle:(NSString *)title
{
  objc_setAssociatedObject(self, &amp;titleKey, title, OBJC_ASSOCIATION_COPY);
}
@end
```
可以看到关键是用到了runtime的两个函数：</li>
<li><code>id objc_getAssociatedObject(id object, void *key)</code></li>
<li><code>void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)</code></li>
</ul>


<p>该函数中第一个参数表示目标对象，第三个参数表示要添加的属性，第四个参数设置objc_AssociationPolicy,它有以下几个选项：<br/>
<a href="http://yulingtianxia.qiniudn.com/">http://yulingtianxia.qiniudn.com/</a><code>OBJC_ASSOCIATION_ASSIGN</code>，<code>OBJC_ASSOCIATION_RETAIN</code>，<code>OBJC_ASSOCIATION_COPY</code>，分别对应我们在声明属性时的<code>assign</code>,<code>retain</code>,<code>copy</code>。<br/>
关于第二个参数，key。因为一个对象可以关联多个新的对像，我们需要一个标志来区分他们。所以这个key就起这样的作用。这里的需要的key的地址，不关心它指向谁。</p>

<p>当我们第二次以新的value调用objc_setAssociatedObject时，如果policy是OBJC_ASSOCIATION_ASSIGN，新的value被关联，对原来旧的value没有任何影响。如果policy是OBJC_ASSOCIATION_RETAIN和OBJC_ASSOCIATION_COPY，新的value被关联，旧的value被release。如果想release原来的value又不关联新的value，，可以用objc_setAssociatedObject直接传一个nil做为value的值。</p>

<p>注意不要使用<code>objc_removeAssociatedObjects</code>，因为它用去掉所有的关联的对象。</p>

<p>参考资料：<br/>
1. 《iOS设计模式解析》<br/>
2. 《HeadFirst设计模式》<br/>
3. <a href="http://fanliugen.com/?p=460">http://fanliugen.com/?p=460</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Double Dispatch模式及其在iOS开发中实践]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/13/double-dispatchmo-shi-ji-qi-zai-ioskai-fa-zhong-shi-zhan/"/>
    <updated>2014-04-13T15:51:03+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/13/double-dispatchmo-shi-ji-qi-zai-ioskai-fa-zhong-shi-zhan</id>
    <content type="html"><![CDATA[<h2>引子</h2>

<p>在一个太空大战游戏中，导弹可以撞向飞船，也可能撞向行星，所以在碰撞检测的时候就需要判断碰撞的结果。假设游戏有四种物体：飞船，陨石，行星，导弹，那么就产生了<code>4*3/2+4</code>种<a href="http://yulingtianxia.qiniudn.com/%E6%83%85%E5%BD%A2%EF%BC%88%E4%B8%80%E6%9E%9A%E5%AF%BC%E5%BC%B9%E6%92%9E%E4%B8%8A%E5%8F%A6%E4%B8%80%E6%9E%9A%E5%AF%BC%E5%BC%B9%EF%BC%89%E3%80%82%E8%BF%99%E7%A7%8D%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E8%AE%A1%E7%AE%97%E5%87%BA%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BC%9A%E9%9A%8F%E7%9D%80%E7%89%A9%E4%BD%93%E7%A7%8D%E7%B1%BBN%E7%9A%84%E5%A2%9E%E5%A4%9A%E7%88%86%E7%82%B8%E6%80%A7%E5%A2%9E%E9%95%BF%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E8%BF%98%E7%94%A8%E4%B8%80%E5%A0%86if%EF%BC%8Delse%E6%9D%A5%E6%A3%80%E6%B5%8B%E7%A2%B0%E6%92%9E%EF%BC%8C%E9%82%A3%E7%9C%9F%E6%98%AF">http://yulingtianxia.qiniudn.com/%E6%83%85%E5%BD%A2%EF%BC%88%E4%B8%80%E6%9E%9A%E5%AF%BC%E5%BC%B9%E6%92%9E%E4%B8%8A%E5%8F%A6%E4%B8%80%E6%9E%9A%E5%AF%BC%E5%BC%B9%EF%BC%89%E3%80%82%E8%BF%99%E7%A7%8D%E6%8E%92%E5%88%97%E7%BB%84%E5%90%88%E8%AE%A1%E7%AE%97%E5%87%BA%E7%9A%84%E7%BB%93%E6%9E%9C%E4%BC%9A%E9%9A%8F%E7%9D%80%E7%89%A9%E4%BD%93%E7%A7%8D%E7%B1%BBN%E7%9A%84%E5%A2%9E%E5%A4%9A%E7%88%86%E7%82%B8%E6%80%A7%E5%A2%9E%E9%95%BF%EF%BC%8C%E5%A6%82%E6%9E%9C%E8%BF%99%E4%B8%AA%E6%97%B6%E5%80%99%E8%BF%98%E7%94%A8%E4%B8%80%E5%A0%86if%EF%BC%8Delse%E6%9D%A5%E6%A3%80%E6%B5%8B%E7%A2%B0%E6%92%9E%EF%BC%8C%E9%82%A3%E7%9C%9F%E6%98%AF</a><code>Naive</code>了。这时我们可以利用面向对象语言的多态性质来在程序运行时动态绑定，因为碰撞检测是一种“双向选择”，所以我们需要<code>double dispatch</code>（双分派），<code>Visitor</code>模式就是<code>double dispatch</code>的一种应用。<br/>
<img src="http://yulingtianxia.qiniudn.com/14035338896.jpg" alt="Visitor模式" /></p>

<p>DD模式适合于处理多个对象之间的相互作用。假如不用DD模式的话，那么每个对象跟别的对象发生关系时，就必须辛辛苦苦的进行if&hellip;else&hellip;枚举，因为它并不知道对方是何神圣。DD模式的引入解决了这个问题，其实说白了就是利用语言内置的虚函数机制来替你干活，把工作移交给编译器去做了。</p>

<h2>本文内容</h2>

<ul>
<li>C++中的Double Dispatch实例</li>
<li>Java中的Double Dispatch实例</li>
<li>Objective-C中实现碰撞检测用到的Visitor模式</li>
</ul>


<!-- more-->


<h2>C++中的Double Dispatch实例</h2>

<p>本节内容摘自<a href="http://www.cnblogs.com/west-link/archive/2011/07/26/2116887.html">这里</a><br/>
我们先从字面上去理解它吧，直观地说，它指的是两次dispatch。这里的dispatch指的是什么呢？举个例子：</p>

<p>``` cpp
class Event
   {</p>

<pre><code>   public:
       virtual void PrintName()
       {
            cout&lt;&lt;"我是通用事件"&lt;&lt;endl;           
       }
</code></pre>

<p>   }</p>

<p>   class KeyEvent:public Event
   {</p>

<pre><code>  public:
       virtual void PrintName()
       {
            cout&lt;&lt;"我是按键事件"&lt;&lt;endl;           
       }
</code></pre>

<p>   }</p>

<p>   class ClickEvent:public Event
   {</p>

<pre><code>   public:
       virtual void PrintName()
       {
            cout&lt;&lt;"我是单击事件"&lt;&lt;endl;           
       }
</code></pre>

<p>   }
```</p>

<p>多态性是动态的，被调用的方法由对象的真正类型确定，这个过程就被称之为dispatch。例如在C++中，每个对象都有一个虚函数表，当用基类的类型引用子类对象时，虚函数指针指向的是子类的虚函数表，调用的虚函数都是子类中的版本，所以下面代码输出的是：“我是按键事件”，这就算是一次dispatch的过程，即根据对象类型来动态确定调用哪个函数的过程。</p>

<p><code>
Event* pEvent = new KeyEvent();
pEvent-&gt;PrintName();
</code></p>

<p>什么时候会用到两次dispatch呢? 继续往下看：</p>

<p>```
class EventRecorder
   {</p>

<pre><code>   public:
       virtual void RecordEvent(Event* event)
       {
           cout&lt;&lt;"使用EventRecorder记录通用事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(KeyEvent* event)
       {
           cout&lt;&lt;"使用EventRecorder记录按键事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(ClickEvent* event)
       {
           cout&lt;&lt;"使用EventRecorder记录单击事件"&lt;&lt; endl;           
       }
</code></pre>

<p>   }</p>

<p>   class AdvanceEventRecorder:public EventRecorder
   {</p>

<pre><code>   public:
       virtual void RecordEvent(Event* event)
       {
           cout&lt;&lt;"使用高级EventRecorder记录通用事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(KeyEvent* event)
       {
           cout&lt;&lt;"使用高级EventRecorder记录按键事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(ClickEvent* event)
       {
           cout&lt;&lt;"使用高级EventRecorder记录单击事件"&lt;&lt; endl;           
       }
</code></pre>

<p>   }
```</p>

<p>这两个类中分别包含三个重载函数，多态是动态的，而函数重载则是静态的，它在编译时期就确定下来了，所以，下面代码片段的运行结果并不是我们所期望的:</p>

<p>```</p>

<pre><code>EventRecorder* pRecorder = new AdvanceEventRecorder();
Event* pEvent = new KeyEvent();
pRecorder-&gt;RecordEvent(pEvent);
</code></pre>

<p>```
输出内容为：使用高级EventRecorder记录通用事件<br/>
实际上，在这个场景中，我们期望调用的是：AdvanceEventRecorder::RecordEvent(KeyEvent* event)<br/>
下面我们使用Double Dispatch设计模式来达到上面的代码片段的目的，在所有Event对象中增加下面的函数：</p>

<p>```
   virtual void RecordEvent(EventRecorder* recorder)
   {</p>

<pre><code>  recorder-&gt;RecordEvent(this);
</code></pre>

<p>   }
```
下面的代码片段将输出：使用高级EventRecorder记录按键事件</p>

<p>```</p>

<pre><code>EventRecorder* pRecorder = new AdvanceEventRecorder();
Event* pEvent = new KeyEvent();
pEvent-&gt;RecordEvent(pRecorder);
</code></pre>

<p><code>``
可以看出，第一次dispatch正确地找到了</code>KeyEvent<code>的</code>RecordEvent(EventRecorder<em> recorder)<code>，第二次dispatch找到了</code>AdvanceEventRecorder<code>的</code>RecordEvent(KeyEvent</em> event)`。
   Visitor模式就是对Double Dispatch的应用，另外，在碰撞检测算法中也会经常用到。</p>

<h2>Java中的Double Dispatch实例</h2>

<p>本节参考自<a href="http://www.blogjava.net/chaocai/archive/2009/02/19/255640.html">这里</a>
相对于C++中使用继承来说，Java提供的接口和函数重载让Double Dispatch模式更容易实现</p>

<h3>1 根据对象来选择行为问题</h3>

<p><code>java
public interface Event {
}
public class BlueEvent implements Event {
}
public class RedEvent implements Event {
}
public class Handler {
public void handle(Event event){
System.out.println("It is event");
}
public void handle(RedEvent event){
System.out.println("It is RedEvent");
}
public void handle(BlueEvent event){
System.out.println("It is BlueEvent");
}
}
public class Main {
public static void main(String[] args) {
Event evt=new BlueEvent();
new Handler().handle(evt);
}
}
</code></p>

<p>你认为运行结果是什么呢？<br/>
结果：It is event<br/>
是不是有点出乎意料，不是It is BlueEvent，<strong>这是因为Overload并不支持在运行时根据参数的运行时类型来绑定方法</strong>，所以要执行哪个方法是在编译时就选定了的。</p>

<h3>2 Double Dispatch Pattern</h3>

<p>由于Java,C++及C#都具有上述局限，通常我们只能通过Switch或if结构来实现，当然这种实现方式既不优雅而且影响代码的可维护性。<br/>
通过以下的Double Dispatch Pattern便可以优雅的实现。</p>

<p><code>
public interface Event {
public void injectHandler(EventHandler v);
}
public class BlueEvent implements Event {
public void injectHandler(EventHandler v) {
v.handle(this);
}
}
public class RedEvent implements Event {
public void injectHandler(EventHandler v) {
v.handle(this);
}
}
public class EventHandler {
public void handle(BlueEvent e){
System.out.println("It is BlueEvent");
}
public void handle(RedEvent e){
System.out.println("It is RedEvent");
}
}
public class Main {
public static void main(String[] args) {
Event evt=new BlueEvent();
evt.injectHandler(new EventHandler());
}
}
</code></p>

<h2>Objective-C中实现碰撞检测用到的Visitor模式</h2>

<p>虽然OC不支持函数重载，但是我们可以老老实实的用方法名来区分类似<code>visitXXX</code>的访问方法，并利用OC其独有的SEL类型可以很好的在运行时判断该调用哪个方法</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353389425.jpg" alt="" /></p>

<p>感谢kouky提供的iOS上碰撞检测的<a href="https://github.com/kouky/iOS-SpriteKit-Pong">Demo</a>，这里他用到了Visitor模式<br/>
由于判断物体类型是用一个32位掩码来标记，所以这里不可避免的要用到if语句，这不代表它不是动态绑定，因为if语句是在初始化方法<code>+ (id)contactVisitorWithBody:(SKPhysicsBody *)body forContact:(SKPhysicsContact *)contact</code>中其作用的，只是为了判断物体类型，而不是判断碰撞两者的组合类型<br/>
可以参考我写的例子<a href="https://github.com/yulingtianxia/MyFirstGame/tree/master/ColorAtom">ColorAtom</a></p>

<p>首先新建一个访问者基本类<code>ContactVisitor</code>，其本质为对SKPhysicsBody和SKPhysicsContact对象的封装，而SKPhysicsContact在本例中虽未用到（因为碰撞检测后啥也没干，只输出了碰撞双方name），但其保存着碰撞坐标等信息，也很重要。两次dispatch都是在访问者基本类实现的，而碰撞后具体操作则卸载了访问者具体类（如AtomNodeContactVisitor）</p>

<p>``` objc</p>

<p>//  ContactVisitor.h
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;SpriteKit/SpriteKit.h></h1>

<p>@interface ContactVisitor : NSObject</p>

<p>@property (nonatomic,readonly, strong) SKPhysicsBody <em>body;
@property (nonatomic, readonly, strong) SKPhysicsContact </em>contact;</p>

<ul>
<li>(id)contactVisitorWithBody:(SKPhysicsBody <em>)body forContact:(SKPhysicsContact </em>)contact;</li>
<li>(void)visit:(SKPhysicsBody *)body;</li>
</ul>


<p>@end
```</p>

<p>属性body即为访问者的SKPhysicsBody，而方法<code>visit:</code>的参数为被访问者的SKPhysicsBody<br/>
<code>contactVisitorWithBody:forContact:</code>方法的作用是根据掩码类型初始化对应类型的访问者具体类</p>

<p>```
//
//  ContactVisitor.m
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;ContactVisitor.h&rdquo;</h1>

<h1>import &lt;objc/runtime.h></h1>

<h1>import &ldquo;NodeCategories.h&rdquo;</h1>

<h1>import &ldquo;AtomNodeContactVisitor.h&rdquo;</h1>

<h1>import &ldquo;PlayFieldSceneContactVisitor.h&rdquo;</h1>

<p>@implementation ContactVisitor
+ (id)contactVisitorWithBody:(SKPhysicsBody <em>)body forContact:(SKPhysicsContact </em>)contact
{</p>

<pre><code>//第一次dispatch，通过node类别返回对应的实例
if ((body.categoryBitMask&amp;AtomCategory)!=0) {
    return [[AtomNodeContactVisitor alloc] initWithBody:body forContact:contact];
}
if ((body.categoryBitMask&amp;PlayFieldCategory)!=0) {
    return [[PlayFieldSceneContactVisitor alloc] initWithBody:body forContact:contact];
}
else{
    return nil;
}
</code></pre>

<p>}</p>

<ul>
<li><p>(id)initWithBody:(SKPhysicsBody <em>)body forContact:(SKPhysicsContact </em>)contact
{
  self = [super init];
  if (self) {
      <em>contact = contact;
      </em>body = body;
  }
  return self;
}</p></li>
<li><p>(void)visit:(SKPhysicsBody <em>)body
{
  //第二次dispatch，通过构造方法名来执行对应方法
  // 生成node的名字，比如"AtomNode"
  NSString </em>bodyClassName = [NSString stringWithUTF8String:class_getName(body.node.class)];</p>

<p>  // 生成方法名，比如"visitAtomBody"
  NSMutableString *contactSelectorString = [NSMutableString stringWithFormat:@&ldquo;visit&rdquo;];
  [contactSelectorString appendString:bodyClassName];
  [contactSelectorString appendString:@&ldquo;:&rdquo;];</p>

<p>  SEL selector = NSSelectorFromString(contactSelectorString);
  //判断是否存在此方法
  if ([self respondsToSelector:selector]) {
      [self performSelector:selector withObject:body];
  }</p></li>
</ul>


<p>}</p>

<p>```</p>

<p>以访问者具体类以<code>AtomNodeContactVisitor</code>类为例，它继承自访问者基本类ContactVisitor</p>

<p>```</p>

<p>//
//  AtomNodeContactVisitor.h
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;ContactVisitor.h&rdquo;</h1>

<p>@interface AtomNodeContactVisitor : ContactVisitor</p>

<p>/<em>Atom访问了Atom，同类碰撞</em>/
&ndash;(void) visitAtomNode:(SKPhysicsBody<em>) anotherAtomBody;
/</em>Atom访问了边界，也就是球撞墙上了<em>/
&ndash;(void) visitPlayFieldScene:(SKPhysicsBody</em>) playfieldBody;
@end</p>

<p>```</p>

<p>在处理碰撞后的visitXXX方法中，我将碰撞双方的访问者和被访问者的关系输出</p>

<p>```
//
//  AtomNodeContactVisitor.m
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;AtomNodeContactVisitor.h&rdquo;</h1>

<h1>import &ldquo;AtomNode.h&rdquo;</h1>

<h1>import &ldquo;PlayFieldScene.h&rdquo;</h1>

<p>@implementation AtomNodeContactVisitor
&ndash;(void) visitAtomNode:(SKPhysicsBody*) anotherAtomBody
{</p>

<pre><code>AtomNode *thisAtom = (AtomNode*)self.body.node;
AtomNode *anotherAtom = (AtomNode*)anotherAtomBody.node;
//处理碰撞后的结果
NSLog(@"%@-&gt;%@",thisAtom.name,anotherAtom.name);
</code></pre>

<p>}
&ndash;(void) visitPlayFieldScene:(SKPhysicsBody*) playfieldBody
{</p>

<pre><code>AtomNode *atom = (AtomNode*)self.body.node;
PlayFieldScene *playfield = (PlayFieldScene*) playfieldBody.node;
NSLog(@"%@-&gt;%@",atom.name,playfield.name);
</code></pre>

<p>}
@end
```
下面建立被访问者类，其本质就是对SKPhysicsBody的封装，并接受Visitor的注入</p>

<p>```
//
//  VisitablePhysicsBody.h
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;ContactVisitor.h&rdquo;</h1>

<p>@interface VisitablePhysicsBody : NSObject
@property (nonatomic, readonly, strong) SKPhysicsBody *body;</p>

<ul>
<li>(id) initWithBody:(SKPhysicsBody *)body;</li>
<li>(void) acceptVisitor:(ContactVisitor *)visitor;</li>
</ul>


<p>@end
```</p>

<p>关键的一步：在<code>acceptVisitor:</code>方法中调用访问者的<code>visit:</code>方法</p>

<p>```
//
//  VisitablePhysicsBody.m
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;VisitablePhysicsBody.h&rdquo;</h1>

<p>@implementation VisitablePhysicsBody
&ndash; (id)initWithBody:(SKPhysicsBody *)body
{</p>

<pre><code>self = [super init];
if (self) {
    _body = body;
}
return self;
</code></pre>

<p>}</p>

<ul>
<li>(void)acceptVisitor:(ContactVisitor *)visitor
{
  [visitor visit:self.body];
}</li>
</ul>


<p>@end</p>

<p>```</p>

<p>可能有人会有疑问，<code>visit:</code>方法穿入的参数类型永远是<code>SKPhysicsBody</code>，这哪里是动态绑定啊，其实是由于本例的特殊性，碰撞检测时区分物体类型不是靠<code>SKPhysicsBody</code>子类化来区分和绑定，而是靠SKPhysicsBody类中的<code>categoryBitMask</code>属性来区分，这也就免不了需要在<code>ContactVisitor</code>初始化的时候通过if语句来判断具体初始化哪个子类<br/>
最后，在Scene实现SKPhysicsContactDelegate协议</p>

<p>```</p>

<h1>pragma mark SKPhysicsContactDelegate</h1>

<p>&ndash;(void)didBeginContact:(SKPhysicsContact *)contact
{</p>

<pre><code>//A-&gt;B
ContactVisitor *visitorA = [ContactVisitor contactVisitorWithBody:contact.bodyA forContact:contact];
VisitablePhysicsBody *visitableBodyB = [[VisitablePhysicsBody alloc] initWithBody:contact.bodyB];
[visitableBodyB acceptVisitor:visitorA];
//B-&gt;A
ContactVisitor *visitorB = [ContactVisitor contactVisitorWithBody:contact.bodyB forContact:contact];
VisitablePhysicsBody *visitableBodyA = [[VisitablePhysicsBody alloc] initWithBody:contact.bodyA];
[visitableBodyA acceptVisitor:visitorB];
</code></pre>

<p>}
```
物理老师总说力的作用时相互的，所以我们需要两次访问：A访问B和B访问A，但是这样会调用两次visitXXX方法，原则上这两个逻辑上对称的方法我们只需要实现其中一个就可以，但必须得像上面代码一样，A->B和B->A缺一不可，因为碰撞的时候我们不知道bodyA和bodyB的类型，也就无法判断visitXXX方法是A->B时能调用还是B->A时能调用到<br/>
当然，你也可以两个visit方法都实现，但只对visitor的node做操作，或只对visitable的node操作，总之仁者见仁智者见智啦</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS单例模式 or NSUserDefaults]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/07/iosdan-li-mo-shi-ornsuserdefaults/"/>
    <updated>2014-04-07T15:07:08+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/07/iosdan-li-mo-shi-ornsuserdefaults</id>
    <content type="html"><![CDATA[<p>本文内容：</p>

<ul>
<li>iOS的单例模式</li>
<li>NSUserDefaults的使用</li>
<li>总结：iOS单例模式 and NSUserDefaults</li>
</ul>


<!-- more-->


<h1>iOS的单例模式</h1>

<p>提起单例模式大家都不陌生，什么懒汉式，饿汉式，老汉式。。。扯远了</p>

<p>一开始觉得Objective－C中没有绝对的私有方法，该如何实现单例模式呢？后来觉得想多了，限制构造方法的使用式徒劳的，因为程序是人写的，既然是单例了，那就老老实实调用自己写的getInstance吧。Java笑了？一个反射打趴下！
在ARC诞生之前，可以通过重写<code>allocWithZone</code>方法等来实现，下面是苹果官方的单例写法：<br/>
``` objectivec
static MyGizmoClass <em>sharedGizmoManager = nil;
+ (MyGizmoClass</em>)sharedManager
{</p>

<pre><code>@synchronized(self) {
    if (sharedGizmoManager == nil) {
        [[self alloc] init]; // assignment not done here
    }
}
return sharedGizmoManager;
</code></pre>

<p>}</p>

<ul>
<li><p>(id)allocWithZone:(NSZone *)zone
{
  @synchronized(self) {
      if (sharedGizmoManager == nil) {
          sharedGizmoManager = [super allocWithZone:zone];
          return sharedGizmoManager;  // assignment and return on first allocation
      }
  }
  return nil; //on subsequent allocation attempts return nil
}</p></li>
<li><p>(id)copyWithZone:(NSZone *)zone
{
  return self;
}</p></li>
<li><p>(id)retain
{
  return self;
}</p></li>
<li><p>(unsigned)retainCount
{
  return UINT_MAX;  //denotes an object that cannot be released
}</p></li>
<li><p>(void)release
{
  //do nothing
}</p></li>
<li><p>(id)autorelease
{
  return self;
}</p></li>
</ul>


<p>```</p>

<p>在ARC时代，程序员不用费心计算static的实例被引用多少次，需要release巴拉巴拉。。。而自从有了GCD，iOS的单例模式变得超级简单了：</p>

<p>```
+ (Singleton *)sharedInstance{</p>

<pre><code>static id instance = nil;
static dispatch_once_t onceToken;
dispatch_once(&amp;onceToken, ^{
    instance = [[self alloc] init];
});
return instance;
</code></pre>

<p>}
<code>``
instance为将被实例化的对象，为了让instance只被实例化一次，用到了GCD(Grand Central Dispatch)中的</code>dispatch_once`方法。该方法有两个参数，第二个参数是一个block，只会被执行一次。而第一个参数是一个谓词，用于判断代码块（block）是否执行完，这个谓词只能是全局或静态变量，类型为dispatch_once_t，其实dispatch_once_t就是long类型。你可以理解为第一个参数是个标识位，能保证记录第二个参数block的执行情况，即使是在最复杂的多线程并发执行的情况下，也就是说，GCD的这个方法是线程安全的。如果你对block这种类型比较陌生，可以把它暂时当作函数指针，当然，它比函数指针还要强大。<br/>
你可以重写init方法来实现饿汉式单例，也可以自定义initwithXXX来在需要实例化的时候调用之，实现懒汉式单例。</p>

<h1>NSUserDefaults</h1>

<p>很多APP启动时需要读取上次运行保存的一些状态，如何保存呢？Core Data，SQlite和UIDocuments未免杀鸡用牛刀了，而<code>NSUserDefaults</code>很适用于快速读取小规模的数据</p>

<p><code>
NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];
</code>
写入数据</p>

<p><code>
NSString *string = @"hahaha";
[standardDefaults setObject:string forKey:@"myKey"];
[standardDefaults synchronize];//写完别忘了同步
</code>
读取数据</p>

<p><code>
NSString *value = [standardDefaults objectForKey:@"myKey"];  
</code>
<code>NSUserDefaults</code>可以很好地理解成键值对</p>

<p>有时在写数据之前，想判断下这个健是否已经设置过默认值</p>

<p><code>
NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];
if ([standardDefaults stringForKey:@"favoriteColor"] == nil) {
[standardDefaults setObject:@"Green" forKey:@"favoriteColor"];
[standardDefaults synchronize];
}
</code>
其实大可不必这么麻烦，摘自<a href="http://beyondvincent.com/blog/2013/04/20/13/">破船</a>推荐的方法<code>registerDefaults:</code></p>

<p><code>
NSUserDefaults *standardDefaults = [NSUserDefaults standardUserDefaults];
[standardDefaults registerDefaults:@{@"favoriteColor": @"Green"}];
[standardDefaults synchronize];
</code>
每次程序启动的时候调用<code>registerDefaults:</code> 方法都是安全的。完全可以将这个方法的调用放到<code>applicationDidFinishLaunching:</code>方法中. 这个方法永远都不会覆盖用户设置的值。<br/>
但是并不是所有类型的对象都能够直接放入NSUserDefaults，NSUserDefaults只支持： NSString, NSNumber, NSDate, NSArray, NSDictionary<br/>
解决方法：让这个自定义的类实现<NSCoding>协议，举个例子：</p>

<p>```
//SNShops.h</p>

<p>@interface SNShops : NSObject<NSCoding></p>

<p>@property (nonatomic,strong) NSString<em> sid;
@property (nonatomic,strong) NSString</em> name;</p>

<ul>
<li>(id) initWithCoder: (NSCoder *)coder;</li>
<li>(void) encodeWithCoder: (NSCoder *)coder;</li>
</ul>


<p>//SNShops.m
@implementation SNShops
&ndash; (id) initWithCoder: (NSCoder *)coder
{</p>

<pre><code>if (self = [super init])
{
    self.sid = [coder decodeObjectForKey:@"sid"];
    self.name = [coder decodeObjectForKey:@"name"];
}
return self;
</code></pre>

<p>}
&ndash; (void) encodeWithCoder: (NSCoder *)coder
{</p>

<pre><code>[coder encodeObject:self.sid forKey:@"sid"];
[coder encodeObject:self.name forKey:@"name"];
</code></pre>

<p>}</p>

<p>```</p>

<p>然后再存取时通过<code>NSData</code>做载体：<br/>
存入</p>

<p>```
NSUserDefaults <em>standardDefaults = [NSUserDefaults standardUserDefaults];
SNShops </em>shop = [[SNShops alloc]init];
NSData *shopData = [NSKeyedArchiver archivedDataWithRootObject:shop];
[standardDefaults setObject:shopData forKey:@&ldquo;myshop&rdquo;];
[standardDefaults synchronize];</p>

<p>```
读取</p>

<p><code>
NSData *newshopData = [standardDefaults objectForKey:"myshop"];
SNShops *newshop = [NSKeyedUnarchiver unarchiveObjectWithData:newshopData];
</code></p>

<h1>总结：iOS单例模式 and NSUserDefaults</h1>

<p>单例模式虽然能存入任何类型的对象，但是它会随着程序的挂起而消亡。而NSUserDefaults在读取自定义类型时有些繁琐，降低编码效率和可读性，好处是程序下次启动依然能读取到上次的状态。<br/>
笔者在实际应用中采取了二者结合的模式：让单例模式的类实现<NSCoding>协议，程序第一次启动的时候通过NSData做载体读取单例类的实例，并存入单例，程序运行中一直对单例做存储操作，当程序快要进入到后台挂起的时候，通过NSData做载体存入NSUserDefaults，一举两得。</p>
]]></content>
  </entry>
  
</feed>
