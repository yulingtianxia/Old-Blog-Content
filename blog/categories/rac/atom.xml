<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: RAC | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/rac/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-07-29T17:51:42+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ReactiveCocoa]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/29/reactivecocoa/"/>
    <updated>2014-07-29T14:15:57+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/29/reactivecocoa</id>
    <content type="html"><![CDATA[<p>几个月前看了一点RAC的介绍，感觉很强大但也很难入门，这次挖个坑，整理下RAC的资源。</p>

<!--more-->


<h2>官方介绍</h2>

<p>ReactiveCocoa 受<a href="http://blog.maybeapps.com/post/42894317939/input-and-output">函数响应式编程</a>激发。不同于使用可变的变量替换和就地修改，RAC提供Signals（被表示为<code>RACSignal</code>）来捕获当前值和将来值。</p>

<p>通过链接（chaining），组合（combining）和对Signals做出反应（reacting），我们不必频繁地观察并更新值，而是声明式编写软件。</p>

<p>比如，文本域可以绑定到最新的时间，当它变化时，不需用额外的代码来观察时间每秒钟更新文本域。它类似KVO，但是用blocks替代了重写 <code>-observeValueForKeyPath:ofObject:change:context:</code>。</p>

<p>Signals也可以表示异步操作，很像<a href="http://en.wikipedia.org/wiki/Futures_and_promises">futures and promises</a>。这极大地简化了异步编码，包括网络方面的代码。</p>

<p>RAC一个重要的优点就是它提供了单独的、统一的方法来处理异步行为，包括委托方法，回调blocks，target-action机制，通知和KVO。</p>

<p>这有一个简单的例子：</p>

<p>```objc
// When self.username changes, logs the new name to the console.
//
// RACObserve(self, username) creates a new RACSignal that sends the current
// value of self.username, then the new value whenever it changes.
// -subscribeNext: will execute the block whenever the signal sends a value.
[RACObserve(self, username) subscribeNext:^(NSString *newName) {</p>

<pre><code>NSLog(@"%@", newName);
</code></pre>

<p>}];
```</p>

<p>但是不同于KVO通知，signals可以链接在一起操作：</p>

<p>```objc
// Only logs names that starts with &ldquo;j&rdquo;.
//
// -filter returns a new RACSignal that only sends a new value when its block
// returns YES.
[[RACObserve(self, username)</p>

<pre><code>filter:^(NSString *newName) {
    return [newName hasPrefix:@"j"];
}]
subscribeNext:^(NSString *newName) {
    NSLog(@"%@", newName);
}];
</code></pre>

<p>```</p>

<p>Signals也可以被用于导出状态。不必观察属性然后设置其他属性来响应这个属性新的值，RAC可以依照signals和操作来表达属性：</p>

<p>```objc
// Creates a one-way binding so that self.createEnabled will be
// true whenever self.password and self.passwordConfirmation
// are equal.
//
// RAC() is a macro that makes the binding look nicer.
//
// +combineLatest:reduce: takes an array of signals, executes the block with the
// latest value from each signal whenever any of them changes, and returns a new
// RACSignal that sends the return value of that block as values.
RAC(self, createEnabled) = [RACSignal</p>

<pre><code>combineLatest:@[ RACObserve(self, password), RACObserve(self, passwordConfirmation) ] 
reduce:^(NSString *password, NSString *passwordConfirm) {
    return @([passwordConfirm isEqualToString:password]);
}];
</code></pre>

<p>```</p>

<p>Signals可以建立在任意值随时间的流动上，不仅仅是KVO。比如，它们也能表示按钮被按下：</p>

<p>```objc
// Logs a message whenever the button is pressed.
//
// RACCommand creates signals to represent UI actions. Each signal can
// represent a button press, for example, and have additional work associated
// with it.
//
// -rac_command is an addition to NSButton. The button will send itself on that
// command whenever it&rsquo;s pressed.
self.button.rac_command = [[RACCommand alloc] initWithSignalBlock:^(id _) {</p>

<pre><code>NSLog(@"button was pressed!");
return [RACSignal empty];
</code></pre>

<p>}];
```</p>

<p>或者异步网络操作：</p>

<p>```objc
// Hooks up a &ldquo;Log in&rdquo; button to log in over the network.
//
// This block will be run whenever the login command is executed, starting
// the login process.
self.loginCommand = [[RACCommand alloc] initWithSignalBlock:^(id sender) {</p>

<pre><code>// The hypothetical -logIn method returns a signal that sends a value when
// the network request finishes.
return [client logIn];
</code></pre>

<p>}];</p>

<p>// -executionSignals returns a signal that includes the signals returned from
// the above block, one for each time the command is executed.
[self.loginCommand.executionSignals subscribeNext:^(RACSignal *loginSignal) {</p>

<pre><code>// Log a message whenever we log in successfully.
[loginSignal subscribeCompleted:^{
    NSLog(@"Logged in successfully!");
}];
</code></pre>

<p>}];</p>

<p>// Executes the login command when the button is pressed.
self.loginButton.rac_command = self.loginCommand;
```</p>

<p>Signals也能表示定时器，其他UI事件，或者任何其他随时间而改变的东西。</p>

<p>通过链接和转换这些Signals，可以为异步操作建立更加复杂的行为。在一组操作完成后，后续工作能容易地被触发：</p>

<p>```objc
// Performs 2 network operations and logs a message to the console when they are
// both completed.
//
// +merge: takes an array of signals and returns a new RACSignal that passes
// through the values of all of the signals and completes when all of the
// signals complete.
//
// -subscribeCompleted: will execute the block when the signal completes.
[[RACSignal</p>

<pre><code>merge:@[ [client fetchUserRepos], [client fetchOrgRepos] ]] 
subscribeCompleted:^{
    NSLog(@"They're both done!");
}];
</code></pre>

<p>```</p>

<p>Signals可以被链接起来按顺序地执行异步操作，而不用嵌套回调blocks。这类似<a href="http://en.wikipedia.org/wiki/Futures_and_promises">futures and promises</a>是如何经常使用的：</p>

<p>```objc
// Logs in the user, then loads any cached messages, then fetches the remaining
// messages from the server. After that&rsquo;s all done, logs a message to the
// console.
//
// The hypothetical -logInUser methods returns a signal that completes after
// logging in.
//
// -flattenMap: will execute its block whenever the signal sends a value, and
// returns a new RACSignal that merges all of the signals returned from the block
// into a single signal.
[[[[client</p>

<pre><code>logInUser] 
flattenMap:^(User *user) {
    // Return a signal that loads cached messages for the user.
    return [client loadCachedMessagesForUser:user];
}]
flattenMap:^(NSArray *messages) {
    // Return a signal that fetches any remaining messages.
    return [client fetchMessagesAfterMessage:messages.lastObject];
}]
subscribeNext:^(NSArray *newMessages) {
    NSLog(@"New messages: %@", newMessages);
} completed:^{
    NSLog(@"Fetched all messages.");
}];
</code></pre>

<p>```</p>

<p>RAC甚至使绑定到异步操作结果更加容易：</p>

<p>```objc
// Creates a one-way binding so that self.imageView.image will be set the user&rsquo;s
// avatar as soon as it&rsquo;s downloaded.
//
// The hypothetical -fetchUserWithUsername: method returns a signal which sends
// the user.
//
// -deliverOn: creates new signals that will do their work on other queues. In
// this example, it&rsquo;s used to move work to a background queue and then back to the main thread.
//
// -map: calls its block with each user that&rsquo;s fetched and returns a new
// RACSignal that sends values returned from the block.
RAC(self.imageView, image) = [[[[client</p>

<pre><code>fetchUserWithUsername:@"joshaber"]
deliverOn:[RACScheduler scheduler]]
map:^(User *user) {
    // Download the avatar (this is done on a background queue).
    return [[NSImage alloc] initWithContentsOfURL:user.avatarURL];
}]
// Now the assignment will be done on the main thread.
deliverOn:RACScheduler.mainThreadScheduler];
</code></pre>

<p>```</p>

<p>上面示范了RAC能做什么，但它没示范RAC为何这么强大。用README的篇幅的例子很难赞美RAC，但是它让编程有更加简化的状态，更少的饮用，更好的代码位置和更好的表达意图。</p>

<p>更多的例子，参见 <a href="https://github.com/AshFurrow/C-41">C-41</a> 或 <a href="https://github.com/jspahrsummers/GroceryList">GroceryList</a>, 都是用ReactiveCocoa写的真实的iOS应用
. 关于 RAC 更多的详细信息可以在<a href="https://github.com/ReactiveCocoa/ReactiveCocoa/tree/master/Documentation">Documentation</a> 文件夹中找到.</p>

<h2>优秀文章</h2>

<p><a href="http://nshipster.cn/reactivecocoa/">nshipster-Reactive​Cocoa</a><br/>
<a href="http://limboy.me/ios/2013/06/19/frp-reactivecocoa.html">ReactiveCocoa与Functional Reactive Programming</a><br/>
<a href="http://limboy.me/ios/2013/12/27/reactivecocoa-2.html">说说ReactiveCocoa 2</a><br/>
<a href="http://blog.csdn.net/xdrt81y/article/details/30624469">使用ReactiveCocoa实现iOS平台响应式编程</a><br/>
<a href="http://limboy.me/tech/2014/06/06/deep-into-reactivecocoa2.html">ReactiveCocoa2实战</a><br/>
<a href="http://www.raywenderlich.com/62699/reactivecocoa-tutorial-pt1">ReactiveCocoa Tutorial – The Definitive Introduction: Part &frac12;</a><br/>
<a href="http://www.raywenderlich.com/62796/reactivecocoa-tutorial-pt2">ReactiveCocoa Tutorial – The Definitive Introduction: Part 2/2</a><br/>
<a href="http://www.raywenderlich.com/74106/mvvm-tutorial-with-reactivecocoa-part-1">MVVM Tutorial with ReactiveCocoa: Part &frac12;</a><br/>
<a href="http://www.raywenderlich.com/74131/mvvm-tutorial-with-reactivecocoa-part-2">MVVM Tutorial with ReactiveCocoa: Part 2/2</a></p>

<h2>视频</h2>

<iframe height=498 width=510 src="http://player.youku.com/embed/XNzQ3OTAxNzYw" frameborder=0 allowfullscreen></iframe>



]]></content>
  </entry>
  
</feed>
