<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-12-08T13:01:50+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Objective-C Runtime]]></title>
    <link href="http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime/"/>
    <updated>2014-11-05T17:28:27+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/11/05/objective-c-runtime</id>
    <content type="html"><![CDATA[<p>本文详细整理了 Cocoa 的 Runtime 系统的知识，它使得 Objective-C 如虎添翼，具备了灵活的动态特性，使这门古老的语言焕发生机。主要内容如下：</p>

<ul>
<li>引言</li>
<li>简介</li>
<li>与Runtime交互</li>
<li>Runtime术语</li>
<li>消息</li>
<li>动态方法解析</li>
<li>消息转发</li>
<li>健壮的实例变量(Non Fragile ivars)</li>
<li>Objective-C Associated Objects</li>
<li>Method Swizzling</li>
<li>总结</li>
</ul>


<!--more-->


<p></p>

<h2>引言</h2>

<p>曾经觉得Objc特别方便上手，面对着 Cocoa 中大量 API，只知道简单的查文档和调用。还记得初学 Objective-C 时把<code>[receiver message]</code>当成简单的方法调用，而无视了<strong>“发送消息”</strong>这句话的深刻含义。于是<code>[receiver message]</code>会被编译器转化为：<br/>
<code>objc
objc_msgSend(receiver, selector)
</code>
如果消息含有参数，则为：<br/>
<code>
objc_msgSend(receiver, selector, arg1, arg2, ...)
</code>
如果消息的接收者能够找到对应的<code>selector</code>，那么就相当于直接执行了接收者这个对象的特定方法；否则，消息要么被转发，或是临时向接收者动态添加这个<code>selector</code>对应的实现内容，要么就干脆玩完崩溃掉。</p>

<p>现在可以看出<code>[receiver message]</code>真的不是一个简简单单的方法调用。因为这只是在编译阶段确定了要向接收者发送<code>message</code>这条消息，而<code>receive</code>将要如何响应这条消息，那就要看运行时发生的情况来决定了。</p>

<p>Objective-C 的 Runtime 铸就了它动态语言的特性，这些深层次的知识虽然平时写代码用的少一些，但是却是每个 Objc 程序员需要了解的。</p>

<h2>简介</h2>

<p>因为Objc是一门动态语言，所以它总是想办法把一些决定工作从编译连接推迟到运行时。也就是说只有编译器是不够的，还需要一个运行时系统 (runtime system) 来执行编译后的代码。这就是 Objective-C Runtime 系统存在的意义，它是整个Objc运行框架的一块基石。</p>

<p>Runtime其实有两个版本:“modern”和 “legacy”。我们现在用的 Objective-C 2.0 采用的是现行(Modern)版的Runtime系统，只能运行在 iOS 和 OS X 10.5 之后的64位程序中。而OS X较老的32位程序仍采用 Objective-C 1中的（早期）Legacy 版本的 Runtime 系统。这两个版本最大的区别在于当你更改一个类的实例变量的布局时，在早期版本中你需要重新编译它的子类，而现行版就不需要。</p>

<p>Runtime基本是用C和汇编写的，可见苹果为了动态系统的高效而作出的努力。你可以在<a href="http://www.opensource.apple.com/source/objc4/">这里</a>下到苹果维护的开源代码。苹果和GNU各自维护一个开源的runtime版本，这两个版本之间都在努力的保持一致。</p>

<h2>与Runtime交互</h2>

<p>Objc 从三种不同的层级上与 Runtime 系统进行交互，分别是通过 Objective-C 源代码，通过 Foundation 框架的<code>NSObject</code>类定义的方法，通过对 runtime 函数的直接调用。</p>

<h3>Objective-C源代码</h3>

<p>大部分情况下你就只管写你的Objc代码就行，runtime 系统自动在幕后辛勤劳作着。<br/>
还记得引言中举的例子吧，消息的执行会使用到一些编译器为实现动态语言特性而创建的数据结构和函数，Objc中的类、方法和协议等在 runtime 中都由一些数据结构来定义，这些内容在后面会讲到。（比如<code>objc_msgSend</code>函数及其参数列表中的<code>id</code>和<code>SEL</code>都是啥）</p>

<h3>NSObject的方法</h3>

<p>Cocoa 中大多数类都继承于<code>NSObject</code>类，也就自然继承了它的方法。最特殊的例外是<code>NSProxy</code>，它是个抽象超类，它实现了一些消息转发有关的方法，可以通过继承它来实现一个其他类的替身类或是虚拟出一个不存在的类，说白了就是领导把自己展现给大家风光无限，但是把活儿都交给幕后小弟去干。</p>

<p>有的<code>NSObject</code>中的方法起到了抽象接口的作用，比如<code>description</code>方法需要你重载它并为你定义的类提供描述内容。<code>NSObject</code>还有些方法能在运行时获得类的信息，并检查一些特性，比如<code>class</code>返回对象的类；<code>isKindOfClass:</code>和<code>isMemberOfClass:</code>则检查对象是否在指定的类继承体系中；<code>respondsToSelector:</code>检查对象能否响应指定的消息；<code>conformsToProtocol:</code>检查对象是否实现了指定协议类的方法；<code>methodForSelector:</code>则返回指定方法实现的地址。</p>

<h3>Runtime的函数</h3>

<p>Runtime 系统是一个由一系列函数和数据结构组成，具有公共接口的动态共享库。头文件存放于<code>/usr/include/objc</code>目录下。许多函数允许你用纯C代码来重复实现 Objc 中同样的功能。虽然有一些方法构成了<code>NSObject</code>类的基础，但是你在写 Objc 代码时一般不会直接用到这些函数的，除非是写一些 Objc 与其他语言的桥接或是底层的debug工作。在<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Reference/ObjCRuntimeRef/index.html">Objective-C Runtime Reference</a>中有对 Runtime 函数的详细文档。</p>

<h2>Runtime术语</h2>

<p>还记得引言中的<code>objc_msgSend:</code>方法吧，它的真身是这样的：<br/>
<code>objc
id objc_msgSend ( id self, SEL op, ... );
</code>
下面将会逐渐展开介绍一些术语，其实它们都对应着数据结构。</p>

<h3>SEL</h3>

<p><code>objc_msgSend</code>函数第二个参数类型为<code>SEL</code>，它是<code>selector</code>在Objc中的表示类型（Swift中是Selector类）。<code>selector</code>是方法选择器，可以理解为区分方法的 ID，而这个 ID 的数据结构是<code>SEL</code>:<br/>
<code>
typedef struct objc_selector *SEL;
</code>
其实它就是个映射到方法的C字符串，你可以用 Objc 编译器命令<code>@selector()</code>或者 Runtime 系统的<code>
sel_registerName</code>函数来获得一个<code>SEL</code>类型的方法选择器。</p>

<p>不同类中相同名字的方法所对应的方法选择器是相同的，即使方法名字相同而变量类型不同也会导致它们具有相同的方法选择器，于是 Objc 中方法命名有时会带上参数类型(<code>NSNumber</code>一堆抽象工厂方法拿走不谢)，Cocoa 中有好多长长的方法哦。</p>

<h3>id</h3>

<p><code>objc_msgSend</code>第一个参数类型为<code>id</code>，大家对它都不陌生，它是一个指向类实例的指针：<br/>
<code>
typedef struct objc_object *id;
</code>
那<code>objc_object</code>又是啥呢：<br/>
<code>
struct objc_object { Class isa; };
</code>
<code>objc_object</code>结构体包含一个<code>isa</code>指针，根据<code>isa</code>指针就可以顺藤摸瓜找到对象所属的类。</p>

<h3>Class</h3>

<p>之所以说<code>isa</code>是指针是因为<code>Class</code>其实是一个指向<code>objc_class</code>结构体的指针：<br/>
<code>
typedef struct objc_class *Class;
</code>
而<code>objc_class</code>就是我们摸到的那个瓜，里面的东西多着呢：<br/>
```
struct objc_class {</p>

<pre><code>Class isa  OBJC_ISA_AVAILABILITY;
</code></pre>

<h1>if !<strong>OBJC2</strong></h1>

<pre><code>Class super_class                                        OBJC2_UNAVAILABLE;
const char *name                                         OBJC2_UNAVAILABLE;
long version                                             OBJC2_UNAVAILABLE;
long info                                                OBJC2_UNAVAILABLE;
long instance_size                                       OBJC2_UNAVAILABLE;
struct objc_ivar_list *ivars                             OBJC2_UNAVAILABLE;
struct objc_method_list **methodLists                    OBJC2_UNAVAILABLE;
struct objc_cache *cache                                 OBJC2_UNAVAILABLE;
struct objc_protocol_list *protocols                     OBJC2_UNAVAILABLE;
</code></pre>

<h1>endif</h1>

<p>} OBJC2_UNAVAILABLE;
<code>
可以看到运行时一个类还关联了它的超类指针，类名，成员变量，方法，缓存，还有附属的协议。   
其中`objc_ivar_list`和`objc_method_list`分别是成员变量列表和方法列表：  
</code>
struct objc_ivar_list {</p>

<pre><code>int ivar_count                                           OBJC2_UNAVAILABLE;
</code></pre>

<h1>ifdef <strong>LP64</strong></h1>

<pre><code>int space                                                OBJC2_UNAVAILABLE;
</code></pre>

<h1>endif</h1>

<pre><code>/* variable length structure */
struct objc_ivar ivar_list[1]                            OBJC2_UNAVAILABLE;
</code></pre>

<p>}                                                            OBJC2_UNAVAILABLE;</p>

<p>struct objc_method_list {</p>

<pre><code>struct objc_method_list *obsolete                        OBJC2_UNAVAILABLE;

int method_count                                         OBJC2_UNAVAILABLE;
</code></pre>

<h1>ifdef <strong>LP64</strong></h1>

<pre><code>int space                                                OBJC2_UNAVAILABLE;
</code></pre>

<h1>endif</h1>

<pre><code>/* variable length structure */
struct objc_method method_list[1]                        OBJC2_UNAVAILABLE;
</code></pre>

<p>}
<code>``
如果你C语言不是特别好，可以直接理解为</code>objc_ivar_list<code>结构体存储着</code>objc_ivar<code>数组列表，而</code>objc_ivar<code>结构体存储了类的单个成员变量的信息；同理</code>objc_method_list<code>结构体存储着</code>objc_method<code>数组列表，而</code>objc_method`结构体存储了类的某个方法的信息。</p>

<p>最后要提到的还有一个<code>objc_cache</code>，顾名思义它是缓存，它在<code>objc_class</code>的作用很重要，在后面会讲到。</p>

<p>不知道你是否注意到了<code>objc_class</code>中也有一个<code>isa</code>对象，这是因为一个 ObjC 类本身同时也是一个对象，为了处理类和对象的关系，runtime 库创建了一种叫做元类 (Meta Class) 的东西，类对象所属类型就叫做元类，它用来表述类对象本身所具备的元数据。类方法就定义于此处，因为这些方法可以理解成类对象的实例方法每个类仅有一个类对象，而每个类对象仅有一个与之相关的元类。当你发出一个类似<code>[NSObject alloc]</code>的消息时，你事实上是把这个消息发给了一个类对象 (Class Object) ，这个类对象必须是一个元类的实例，而这个元类同时也是一个根元类 (root meta class) 的实例。你会说 <code>NSObject</code> 的子类时，你的类就会指向 <code>NSObject</code> 做为其超类。但是所有的元类最终都指向根元类为其超类。所有的元类的方法列表都有能够响应消息的类方法。所以当 <code>[NSObject alloc]</code> 这条消息发给类对象的时候，<code>objc_msgSend()</code>会去它的元类里面去查找能够响应消息的方法，如果找到了，然后对这个类对象执行方法调用。</p>

<p><img src="http://cn.cocos2d-x.org/uploads/20141018/1413628797629491.png" alt="" /></p>

<p>上图实线是 <code>super_class</code> 指针，虚线是<code>isa</code>指针。 有趣的是根元类的超类是<code>NSObject</code>，而<code>isa</code>指向了自己，而<code>NSObject</code>的超类为<code>nil</code>，也就是它没有超类。</p>

<h4>Method</h4>

<p><code>Method</code>是一种代表类中的某个方法的类型。<br/>
<code>
typedef struct objc_method *Method;
</code>
而<code>objc_method</code>在上面的方法列表中提到过，它存储了方法名，方法类型和方法实现：<br/>
```
struct objc_method {</p>

<pre><code>SEL method_name                                          OBJC2_UNAVAILABLE;
char *method_types                                       OBJC2_UNAVAILABLE;
IMP method_imp                                           OBJC2_UNAVAILABLE;
</code></pre>

<p>}                                                            OBJC2_UNAVAILABLE;
<code>``
- 方法名类型为</code>SEL<code>，前面提到过相同名字的方法即使在不同类中定义，它们的方法选择器也相同。  
- 方法类型</code>method_types<code>是个</code>char<code>指针，其实存储着方法的参数类型和返回值类型。
-</code>method_imp`指向了方法的实现，本质上是一个函数指针，后面会详细讲到。</p>

<h4>Ivar</h4>

<p><code>Ivar</code>是一种代表类中实例变量的类型。<br/>
<code>
typedef struct objc_ivar *Ivar;
</code>
而<code>objc_ivar</code>在上面的成员变量列表中也提到过：<br/>
```
struct objc_ivar {</p>

<pre><code>char *ivar_name                                          OBJC2_UNAVAILABLE;
char *ivar_type                                          OBJC2_UNAVAILABLE;
int ivar_offset                                          OBJC2_UNAVAILABLE;
</code></pre>

<h1>ifdef <strong>LP64</strong></h1>

<pre><code>int space                                                OBJC2_UNAVAILABLE;
</code></pre>

<h1>endif</h1>

<p>}                                                            OBJC2_UNAVAILABLE;
```</p>

<p>PS:<code>OBJC2_UNAVAILABLE</code>之类的宏定义是苹果在  Objc  中对系统运行版本进行约束的黑魔法，有兴趣的可以查看源代码。</p>

<h3>IMP</h3>

<p><code>IMP</code>在<code>objc.h</code>中的定义是：<br/>
<code>
typedef id (*IMP)(id, SEL, ...);
</code>
它就是一个<a href="http://yulingtianxia.com/blog/2014/04/17/han-shu-zhi-zhen-yu-zhi-zhen-han-shu/">函数指针</a>，这是由编译器生成的。当你发起一个 ObjC 消息之后，最终它会执行的那段代码，就是由这个函数指针指定的。而 <code>IMP</code> 这个函数指针就指向了这个方法的实现。既然得到了执行某个实例某个方法的入口，我们就可以绕开消息传递阶段，直接执行方法，这在后面会提到。</p>

<p>你会发现<code>IMP</code>指向的方法与<code>objc_msgSend</code>函数类型相同，参数都包含<code>id</code>和<code>SEL</code>类型。每个方法名都对应一个<code>SEL</code>类型的方法选择器，而每个实例对象中的<code>SEL</code>对应的方法实现肯定是唯一的，通过一组<code>id</code>和<code>SEL</code>参数就能确定唯一的方法实现地址；反之亦然。</p>

<h3>Cache</h3>

<p>在<code>runtime.h</code>中Cache的定义如下：<br/>
<code>
typedef struct objc_cache *Cache
</code>
还记得之前<code>objc_class</code>结构体中有一个<code>struct objc_cache *cache</code>吧，它到底是缓存啥的呢，先看看<code>objc_cache</code>的实现：<br/>
```
struct objc_cache {</p>

<pre><code>unsigned int mask /* total = mask + 1 */                 OBJC2_UNAVAILABLE;
unsigned int occupied                                    OBJC2_UNAVAILABLE;
Method buckets[1]                                        OBJC2_UNAVAILABLE;
</code></pre>

<p>};
<code>``
</code>Cache<code>为方法调用的性能进行优化，通俗地讲，每当实例对象接收到一个消息时，它不会直接在</code>isa<code>指向的类的方法列表中遍历查找能够响应消息的方法，因为这样效率太低了，而是优先在</code>Cache<code>中查找。Runtime 系统会把被调用的方法存到</code>Cache<code>中（理论上讲一个方法如果被调用，那么它有可能今后还会被调用），下次查找的时候效率更高。这根计算机组成原理中学过的 CPU 绕过主存先访问</code>Cache<code>的道理挺像，而我猜苹果为提高</code>Cache`命中率应该也做了努力吧。</p>

<h3>Property</h3>

<p><code>@property</code>标记了类中的属性，这个不必多说大家都很熟悉，它是一个指向<code>objc_property</code>结构体的指针：<br/>
<code>
typedef struct objc_property *Property;
typedef struct objc_property *objc_property_t;//这个更常用
</code>
可以通过<code>class_copyPropertyList</code> 和 <code>protocol_copyPropertyList</code>方法来获取类和协议中的属性：<br/>
<code>
objc_property_t *class_copyPropertyList(Class cls, unsigned int *outCount)
objc_property_t *protocol_copyPropertyList(Protocol *proto, unsigned int *outCount)
</code>
返回类型为指向指针的指针，哈哈，因为属性列表是个数组，每个元素内容都是一个<code>objc_property_t</code>指针，而这两个函数返回的值是指向这个数组的指针。</p>

<p>举个栗子，先声明一个类：<br/>
```
@interface Lender : NSObject {</p>

<pre><code>float alone;
</code></pre>

<p>}
@property float alone;
@end
<code>
你可以用下面的代码获取属性列表：  
</code>
id LenderClass = objc_getClass(&ldquo;Lender&rdquo;);
unsigned int outCount;
objc_property_t <em>properties = class_copyPropertyList(LenderClass, &amp;outCount);
<code>
你可以用`property_getName`函数来查找属性名称：
</code>
const char </em>property_getName(objc_property_t property)
<code>
你可以用`class_getProperty` 和 `protocol_getProperty`通过给出的名称来在类和协议中获取属性的引用：  
</code>
objc_property_t class_getProperty(Class cls, const char <em>name)
objc_property_t protocol_getProperty(Protocol </em>proto, const char <em>name, BOOL isRequiredProperty, BOOL isInstanceProperty)
<code>
你可以用`property_getAttributes`函数来发掘属性的名称和`@encode`类型字符串：  
</code>
const char </em>property_getAttributes(objc_property_t property)
<code>
把上面的代码放一起，你就能从一个类中获取它的属性啦：  
</code>
id LenderClass = objc_getClass(&ldquo;Lender&rdquo;);
unsigned int outCount, i;
objc_property_t *properties = class_copyPropertyList(LenderClass, &amp;outCount);
for (i = 0; i &lt; outCount; i++) {</p>

<pre><code>objc_property_t property = properties[i];
fprintf(stdout, "%s %s\n", property_getName(property), property_getAttributes(property));
</code></pre>

<p>}
```</p>

<h2>消息</h2>

<p>前面做了这么多铺垫，现在终于说到了消息了。Objc 中发送消息是用中括号（<code>[]</code>）把接收者和消息括起来，而直到运行时才会把消息与方法实现绑定。</p>

<h3>objc_msgSend函数</h3>

<p>在引言中已经对<code>objc_msgSend</code>进行了一点介绍，看起来像是<code>objc_msgSend</code>返回了数据，其实<code>objc_msgSend</code>从不返回数据而是你的方法被调用后返回了数据。下面详细叙述下消息发送步骤：</p>

<ol>
<li>检测这个 <code>selector</code> 是不是要忽略的。比如 Mac OS X 开发，有了垃圾回收就不理会 <code>retain</code>, <code>release</code> 这些函数了。</li>
<li>检测这个 target 是不是 <code>nil</code> 对象。ObjC 的特性是允许对一个 <code>nil</code> 对象执行任何一个方法不会 Crash，因为会被忽略掉。</li>
<li>如果上面两个都过了，那就开始查找这个类的 <code>IMP</code>，先从 <code>cache</code> 里面找，完了找得到就跳到对应的函数去执行。</li>
<li>如果 <code>cache</code> 找不到就找一下方法分发表。</li>
<li>如果分发表找不到就到超类的分发表去找，一直找，直到找到<code>NSObject</code>类为止。</li>
<li>如果还找不到就要开始进入<strong>动态方法</strong>解析了，后面会提到。</li>
</ol>


<p>PS:这里说的分发表其实就是<code>Class</code>中的方法列表，它将方法选择器和方法实现地质联系起来。</p>

<p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/messaging1.gif" alt="" /></p>

<p>其实编译器会根据情况在<code>objc_msgSend</code>, <code>objc_msgSend_stret</code>, <code>objc_msgSendSuper</code>, 或 <code>objc_msgSendSuper_stret</code>四个方法中选择一个来调用。如果消息是传递给超类，那么会调用名字带有"Super"的函数；如果消息返回值是数据结构而不是简单值时，那么会调用名字带有"stret"的函数。排列组合正好四个方法。</p>

<p>值得一提的是在 i386 平台处理返回类型为浮点数的消息时，需要用到<code>objc_msgSend_fpret</code>函数来进行处理，这是因为返回类型为浮点数的函数对应的 ABI(Application Binary Interface) 与返回整型的函数的 ABI 不兼容。此时<code>objc_msgSend</code>不再适用，于是<code>objc_msgSend_fpret</code>被派上用场，它会对浮点数寄存器做特殊处理。不过在 PPC 或 PPC64 平台是不需要麻烦它的。</p>

<p>PS：有木有发现这些函数的命名规律哦？带“Super”的是消息传递给超类；“stret”可分为“st”+“ret”两部分，分别代表“struct”和“return”；“fpret”就是“fp”+“ret”，分别代表“floating-point”和“return”。</p>

<h3>方法中的隐藏参数</h3>

<p>我们经常在方法中使用<code>self</code>关键字来引用实例本身，但从没有想过为什么<code>self</code>就能取到调用当前方法的对象吧。其实<code>self</code>的内容是在方法运行时被偷偷的动态传入的。</p>

<p>当<code>objc_msgSend</code>找到方法对应的实现时，它将直接调用该方法实现，并将消息中所有的参数都传递给方法实现,同时,它还将传递两个隐藏的参数:<br/>
&ndash; 接收消息的对象（也就是<code>self</code>指向的内容）
&ndash; 方法选择器（<code>_cmd</code>指向的内容）
之所以说它们是隐藏的是因为在源代码方法的定义中并没有声明这两个参数。它们是在代码被编译时被插入实现中的。尽管这些参数没有被明确声明，在源代码中我们仍然可以引用它们。在下面的例子中，<code>self</code>引用了接收者对象，而<code>_cmd</code>引用了方法本身的选择器：<br/>
```
&ndash; strange
{</p>

<pre><code>id  target = getTheReceiver();
SEL method = getTheMethod();

if ( target == self || method == _cmd )
    return nil;
return [target performSelector:method];
</code></pre>

<p>}
<code>``
在这两个参数中，</code>self` 更有用。实际上,它是在方法实现中访问消息接收者对象的实例变量的途径。</p>

<p>而当方法中的<code>super</code>关键字接收到消息时，编译器会创建一个<code>objc_super</code>结构体：<br/>
<code>
struct objc_super { id receiver; Class class; };
</code>
这个结构体指明了消息应该被传递给特定超类的定义。但<code>receiver</code>仍然是<code>self</code>本身，这点需要注意，因为当我们想通过<code>[super class]</code>获取超类时，编译器只是将指向<code>self</code>的<code>id</code>指针和<code>class</code>的SEL传递给了<code>objc_msgSendSuper</code>函数，因为只有在<code>NSObject</code>类找到<code>class</code>方法，然后<code>class</code>方法调用<code>object_getClass()</code>，接着调用<code>objc_msgSend(objc_super-&gt;receiver, @selector(class))</code>，传入的第一个参数是指向<code>self</code>的<code>id</code>指针，与调用<code>[self class]</code>相同，所以我们得到的永远都是<code>self</code>的类型。</p>

<h3>获取方法地址</h3>

<p>在<code>IMP</code>那节提到过可以避开消息绑定而直接获取方法的地址并调用方法。这种做法很少用，除非是需要持续大量重复调用某方法的极端情况，避开消息发送泛滥而直接调用该方法会更高效。</p>

<p><code>NSObject</code>类中有个<code>methodForSelector:</code>实例方法，你可以用它来获取某个方法选择器对应的<code>IMP</code>，举个栗子：<br/>
```
void (*setter)(id, SEL, BOOL);
int i;</p>

<p>setter = (void (*)(id, SEL, BOOL))[target</p>

<pre><code>methodForSelector:@selector(setFilled:)];
</code></pre>

<p>for ( i = 0 ; i &lt; 1000 ; i++ )</p>

<pre><code>setter(targetList[i], @selector(setFilled:), YES);
</code></pre>

<p><code>``
当方法被当做函数调用时，上节提到的两个隐藏参数就需要我们明确给出了。上面的例子调用了1000次函数，你可以试试直接给</code>target<code>发送1000次</code>setFilled:`消息会花多久。</p>

<p>PS：<code>methodForSelector:</code>方法是由 Cocoa 的 Runtime 系统提供的，而不是 Objc 自身的特性。</p>

<h2>动态方法解析</h2>

<p>你可以动态地提供一个方法的实现。例如我们可以用<code>@dynamic</code>关键字在类的实现文件中修饰一个属性：<br/>
<code>
@dynamic propertyName;
</code>
这表明我们会为这个属性动态提供存取方法，也就是说编译器不会再默认为我们生成<code>setPropertyName:</code>和<code>propertyName</code>方法，而需要我们动态提供。我们可以通过分别重载<code>resolveInstanceMethod:</code>和<code>resolveClassMethod:</code>方法分别添加实例方法实现和类方法实现。因为当 Runtime 系统在<code>Cache</code>和方法分发表中（包括超类）找不到要执行的方法时，Runtime会调用<code>resolveInstanceMethod:</code>或<code>resolveClassMethod:</code>来给程序员一次动态添加方法实现的机会。我们需要用<code>class_addMethod</code>函数完成向特定类添加特定方法实现的操作：
```
void dynamicMethodIMP(id self, SEL _cmd) {</p>

<pre><code>// implementation ....
</code></pre>

<p>}
@implementation MyClass
+ (BOOL)resolveInstanceMethod:(SEL)aSEL
{</p>

<pre><code>if (aSEL == @selector(resolveThisMethodDynamically)) {
      class_addMethod([self class], aSEL, (IMP) dynamicMethodIMP, "v@:");
      return YES;
}
return [super resolveInstanceMethod:aSEL];
</code></pre>

<p>}
@end
<code>``
上面的例子为</code>resolveThisMethodDynamically<code>方法添加了实现内容，也就是</code>dynamicMethodIMP<code>方法中的代码。其中 “</code>v@:`” 表示返回值和参数，这个符号涉及 <a href="https://developer.apple.com/library/mac/DOCUMENTATION/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtTypeEncodings.html">Type Encoding</a></p>

<p>PS：动态方法解析会在消息转发机制浸入前执行。如果 <code>respondsToSelector:</code> 或 <code>instancesRespondToSelector:</code>方法被执行，动态方法解析器将会被首先给予一个提供该方法选择器对应的<code>IMP</code>的机会。如果你想让该方法选择器被传送到转发机制，那么就让<code>resolveInstanceMethod:</code>返回<code>NO</code>。</p>

<h2>消息转发</h2>

<p><img src="http://yulingtianxia.qiniudn.com/QQ20141113-1@2x.png" alt="" /></p>

<h3>重定向</h3>

<p>在消息转发机制执行前，Runtime 系统会再给我们一次偷梁换柱的机会，即通过重载<code>- (id)forwardingTargetForSelector:(SEL)aSelector</code>方法替换消息的接受者为其他对象：<br/>
```
&ndash; (id)forwardingTargetForSelector:(SEL)aSelector
{</p>

<pre><code>if(aSelector == @selector(mysteriousMethod:)){
    return alternateObject;
}
return [super forwardingTargetForSelector:aSelector];
</code></pre>

<p>}
<code>``
毕竟消息转发要耗费更多时间，抓住这次机会将消息重定向给别人是个不错的选择，不过千万别返回</code>self`，因为那样会死循环。</p>

<h3>转发</h3>

<p>当动态方法解析不作处理返回<code>NO</code>时，消息转发机制会被触发。在这时<code>forwardInvocation:</code>方法会被执行，我们可以重写这个方法来定义我们的转发逻辑：<br/>
```
&ndash; (void)forwardInvocation:(NSInvocation *)anInvocation
{</p>

<pre><code>if ([someOtherObject respondsToSelector:
        [anInvocation selector]])
    [anInvocation invokeWithTarget:someOtherObject];
else
    [super forwardInvocation:anInvocation];
</code></pre>

<p>}
<code>``
该消息的唯一参数是个</code>NSInvocation<code>类型的对象——该对象封装了原始的消息和消息的参数。我们可以实现</code>forwardInvocation:`方法来对不能处理的消息做一些默认的处理，也可以将消息转发给其他对象来处理，而不抛出错误。</p>

<p>这里需要注意的是参数<code>anInvocation</code>是从哪的来的呢？其实在<code>forwardInvocation:</code>消息发送前，Runtime系统会向对象发送<code>methodSignatureForSelector:</code>消息，并取到返回的方法签名用于生成<code>NSInvocation</code>对象。所以我们在重写<code>forwardInvocation:</code>的同时也要重写<code>methodSignatureForSelector:</code>方法，否则会抛异常。</p>

<p>当一个对象由于没有相应的方法实现而无法响应某消息时，运行时系统将通过<code>forwardInvocation:</code>消息通知该对象。每个对象都从<code>NSObject</code>类中继承了<code>forwardInvocation:</code>方法。然而，NSObject中的方法实现只是简单地调用了<code>doesNotRecognizeSelector:</code>。通过实现我们自己的<code>forwardInvocation:</code>方法，我们可以在该方法实现中将消息转发给其它对象。</p>

<p><code>forwardInvocation:</code>方法就像一个不能识别的消息的分发中心，将这些消息转发给不同接收对象。或者它也可以象一个运输站将所有的消息都发送给同一个接收对象。它可以将一个消息翻译成另外一个消息，或者简单的"吃掉“某些消息，因此没有响应也没有错误。<code>forwardInvocation:</code>方法也可以对不同的消息提供同样的响应，这一切都取决于方法的具体实现。该方法所提供是将不同的对象链接到消息链的能力。</p>

<p>注意： <code>forwardInvocation:</code>方法只有在消息接收对象中无法正常响应消息时才会被调用。 所以，如果我们希望一个对象将<code>negotiate</code>消息转发给其它对象，则这个对象不能有<code>negotiate</code>方法。否则，<code>forwardInvocation:</code>将不可能会被调用。</p>

<h3>转发和多继承</h3>

<p>转发和继承相似，可以用于为Objc编程添加一些多继承的效果。就像下图那样，一个对象把消息转发出去，就好似它把另一个对象中的方法借过来或是“继承”过来一样。</p>

<p><img src="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Art/forwarding.gif" alt="" /></p>

<p>这使得不同继承体系分支下的两个类可以“继承”对方的方法，在上图中<code>Warrior</code>和<code>Diplomat</code>没有继承关系，但是<code>Warrior</code>将<code>negotiate</code>消息转发给了<code>Diplomat</code>后，就好似<code>Diplomat</code>是<code>Warrior</code>的超类一样。</p>

<p>消息转发弥补了 Objc 不支持多继承的性质，也避免了因为多继承导致单个类变得臃肿复杂。它将问题分解得很细，只针对想要借鉴的方法才转发，而且转发机制是透明的。</p>

<h3>替代者对象(Surrogate Objects)</h3>

<p>转发不仅能模拟多继承，也能使轻量级对象代表重量级对象。弱小的女人背后是强大的男人，毕竟女人遇到难题都把它们转发给男人来做了。这里有一些适用案例，可以参看<a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Articles/ocrtForwarding.html#//apple_ref/doc/uid/TP40008048-CH105-SW11">官方文档</a>。</p>

<h3>转发与继承</h3>

<p>尽管转发很像继承，但是<code>NSObject</code>类不会将两者混淆。像<code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>这类方法只会考虑继承体系，不会考虑转发链。比如上图中一个<code>Warrior</code>对象如果被问到是否能响应<code>negotiate</code>消息：<br/>
```
if ( [aWarrior respondsToSelector:@selector(negotiate)] )</p>

<pre><code>...
</code></pre>

<p><code>``
结果是</code>NO<code>，尽管它能够接受</code>negotiate<code>消息而不报错，因为它靠转发消息给</code>Diplomat`类来响应消息。</p>

<p>如果你为了某些意图偏要“弄虚作假”让别人以为<code>Warrior</code>继承到了<code>Diplomat</code>的<code>negotiate</code>方法，你得重新实现 <code>respondsToSelector:</code> 和 <code>isKindOfClass:</code>来加入你的转发算法：<br/>
```
&ndash; (BOOL)respondsToSelector:(SEL)aSelector
{</p>

<pre><code>if ( [super respondsToSelector:aSelector] )
    return YES;
else {
    /* Here, test whether the aSelector message can     *
     * be forwarded to another object and whether that  *
     * object can respond to it. Return YES if it can.  */
}
return NO;
</code></pre>

<p>}
<code>
除了`respondsToSelector:` 和 `isKindOfClass:`之外，`instancesRespondToSelector:`中也应该写一份转发算法。如果使用了协议，`conformsToProtocol:`同样也要加入到这一行列中。类似地，如果一个对象转发它接受的任何远程消息，它得给出一个`methodSignatureForSelector:`来返回准确的方法描述，这个方法会最终响应被转发的消息。比如一个对象能给它的替代者对象转发消息，它需要像下面这样实现`methodSignatureForSelector:`：  
</code>
&ndash; (NSMethodSignature*)methodSignatureForSelector:(SEL)selector
{</p>

<pre><code>NSMethodSignature* signature = [super methodSignatureForSelector:selector];
if (!signature) {
   signature = [surrogate methodSignatureForSelector:selector];
}
return signature;
</code></pre>

<p>}
```</p>

<h2>健壮的实例变量(Non Fragile ivars)</h2>

<p>在 Runtime 的现行版本中，最大的特点就是健壮的实例变量。当一个类被编译时，实例变量的布局也就形成了，它表明访问类的实例变量的位置。从对象头部开始，实例变量依次根据自己所占空间而产生位移：</p>

<p><img src="http://lh6.ggpht.com/_bMMRN3vt0x0/S1eCgoEotAI/AAAAAAAAAxg/mnW4VTLQOnk/nf1.png?imgmax=800" alt="" /></p>

<p>上图左边是<code>NSObject</code>类的实例变量布局，右边是我们写的类的布局，也就是在超类后面加上我们自己类的实例变量，看起来不错。但试想如果那天苹果更新了<code>NSObject</code>类，发布新版本的系统的话，那就悲剧了：</p>

<p><img src="http://lh5.ggpht.com/_bMMRN3vt0x0/S1eCmurL90I/AAAAAAAAAxk/LfEs0PxKwX8/nf2.png?imgmax=800" alt="" /></p>

<p>我们自定义的类被划了两道线，那是因为那块区域跟超类重叠了。唯有苹果将超类改为以前的布局才能拯救我们，但这样也导致它们不能再拓展它们的框架了，因为成员变量布局被死死地固定了。在脆弱的实例变量(Fragile ivars) 环境下我们需要重新编译继承自 Apple 的类来恢复兼容性。那么在健壮的实例变量下回发生什么呢？</p>

<p><img src="http://lh4.ggpht.com/_bMMRN3vt0x0/S1eCrkwWDII/AAAAAAAAAxo/lKC8NQl6rQE/nf3.png?imgmax=800" alt="" /></p>

<p>在健壮的实例变量下编译器生成的实例变量布局跟以前一样，但是当 runtime 系统检测到与超类有部分重叠时它会调整你新添加的实例变量的位移，那样你在子类中新添加的成员就被保护起来了。</p>

<p>需要注意的是在健壮的实例变量下，不要使用<code>sizeof(SomeClass)</code>，而是用<code>class_getInstanceSize([SomeClass class])</code>代替；也不要使用<code>offsetof(SomeClass, SomeIvar)</code>，而要用<code>ivar_getOffset(class_getInstanceVariable([SomeClass class], "SomeIvar"))</code>来代替。</p>

<h2>Objective-C Associated Objects</h2>

<p>在 OS X 10.6 之后，Runtime系统让Objc支持向对象动态添加变量。涉及到的函数有以下三个：<br/>
<code>
void objc_setAssociatedObject ( id object, const void *key, id value, objc_AssociationPolicy policy );
id objc_getAssociatedObject ( id object, const void *key );
void objc_removeAssociatedObjects ( id object );
</code>
这些方法以键值对的形式动态地向对象添加、获取或删除关联值。其中关联政策是一组枚举常量：<br/>
<code>
enum {
   OBJC_ASSOCIATION_ASSIGN  = 0,
   OBJC_ASSOCIATION_RETAIN_NONATOMIC  = 1,
   OBJC_ASSOCIATION_COPY_NONATOMIC  = 3,
   OBJC_ASSOCIATION_RETAIN  = 01401,
   OBJC_ASSOCIATION_COPY  = 01403
};
</code>
这些常量对应着引用关联值的政策，也就是 Objc 内存管理的引用计数机制。</p>

<h2>Method Swizzling</h2>

<p>之前所说的消息转发虽然功能强大，但需要我们了解并且能更改对应类的源代码，因为我们需要实现自己的转发逻辑。当我们无法触碰到某个类的源代码，却想更改这个类某个方法的实现时，该怎么办呢？可能继承类并重写方法是一种想法，但是有时无法达到目的。这里介绍的是 Method Swizzling ，它通过重新映射方法对应的实现来达到“偷天换日”的目的。跟消息转发相比，Method Swizzling 的做法更为隐蔽，甚至有些冒险，也增大了debug的难度。</p>

<p>这里摘抄一个 NSHipster 的例子：<br/>
```</p>

<h1>import &lt;objc/runtime.h></h1>

<p>@implementation UIViewController (Tracking)</p>

<ul>
<li><p>(void)load {
  static dispatch_once_t onceToken;
  dispatch_once(&amp;onceToken, ^{
      Class class = [self class];</p>

<pre><code>  // When swizzling a class method, use the following: 
  // Class class = object_getClass((id)self); 

  SEL originalSelector = @selector(viewWillAppear:); 
  SEL swizzledSelector = @selector(xxx_viewWillAppear:); 

  Method originalMethod = class_getInstanceMethod(class, originalSelector); 
  Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); 

  BOOL didAddMethod = 
      class_addMethod(class, 
          originalSelector, 
          method_getImplementation(swizzledMethod), 
          method_getTypeEncoding(swizzledMethod)); 

  if (didAddMethod) { 
      class_replaceMethod(class, 
          swizzledSelector, 
          method_getImplementation(originalMethod), 
          method_getTypeEncoding(originalMethod)); 
  } else { 
      method_exchangeImplementations(originalMethod, swizzledMethod); 
  } 
</code></pre>

<p>  });
}</p></li>
</ul>


<h1>pragma mark &ndash; Method Swizzling</h1>

<ul>
<li>(void)xxx_viewWillAppear:(BOOL)animated {
  [self xxx_viewWillAppear:animated];
  NSLog(@&ldquo;viewWillAppear: %@&rdquo;, self);
}</li>
</ul>


<p>@end
<code>``
上面的代码通过添加一个</code>Tracking<code>类别到</code>UIViewController<code>类中，将</code>UIViewController <code>类的</code>viewWillAppear:<code>方法和</code>Tracking<code>类别中</code>xxx_viewWillAppear:<code>方法的实现相互调换。Swizzling 应该在</code>+load<code>方法中实现，因为</code>+load<code>是在一个类最开始加载时调用。</code>dispatch_once`是GCD中的一个方法，它保证了代码块只执行一次，并让其为一个原子操作，线程安全是很重要的。</p>

<p>先用<code>class_addMethod</code>和<code>class_replaceMethod</code>函数将两个方法的实现进行调换，如果类中已经有了<code>viewWillAppear:</code>方法的实现，那么就调用<code>method_exchangeImplementations</code>函数交换了两个方法的 <code>IMP</code>，这是苹果提供给我们用于实现 Method Swizzling 的便捷方法。</p>

<p>最后<code>xxx_viewWillAppear:</code>方法的定义看似是递归调用引发死循环，其实不会的。因为<code>[self xxx_viewWillAppear:animated]</code>消息会动态找到<code>xxx_viewWillAppear:</code>方法的实现，而它的实现已经被我们与<code>viewWillAppear:</code>方法实现进行了互换，所以这段代码不仅不会死循环，如果你把<code>[self xxx_viewWillAppear:animated]</code>换成<code>[self viewWillAppear:animated]</code>反而会引发死循环。</p>

<p>看到有人说<code>+load</code>方法本身就是线程安全的，因为它在程序刚开始就被调用，很少会碰到并发问题，于是 stackoverflow 上也有大神给出了另一个 Method Swizzling 的实现：<br/>
```
&ndash; (void)replacementReceiveMessage:(const struct BInstantMessage *)arg1 {</p>

<pre><code>NSLog(@"arg1 is %@", arg1);
[self replacementReceiveMessage:arg1];
</code></pre>

<p>}
+ (void)load {</p>

<pre><code>SEL originalSelector = @selector(ReceiveMessage:);
SEL overrideSelector = @selector(replacementReceiveMessage:);
Method originalMethod = class_getInstanceMethod(self, originalSelector);
Method overrideMethod = class_getInstanceMethod(self, overrideSelector);
if (class_addMethod(self, originalSelector, method_getImplementation(overrideMethod), method_getTypeEncoding(overrideMethod))) {
        class_replaceMethod(self, overrideSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod));
} else {
        method_exchangeImplementations(originalMethod, overrideMethod);
}
</code></pre>

<p>}
<code>``
上面的代码同样要添加在某个类的类别中，相比第一个种实现，只是去掉了</code>dispatch_once`部分。<br/>
Method Swizzling 的确是一个值得深入研究的话题，Method Swizzling 的最佳实现是什么呢？小弟才疏学浅理解的不深刻，找了几篇不错的资源推荐给大家：<br/>
&ndash; <a href="http://blog.csdn.net/yiyaaixuexi/article/details/9374411">Objective-C的hook方案（一）:  Method Swizzling</a>
&ndash; <a href="http://nshipster.com/method-swizzling/">Method Swizzling</a><br/>
&ndash; <a href="http://stackoverflow.com/questions/5371601/how-do-i-implement-method-swizzling">How do I implement method swizzling?</a>
&ndash; <a href="http://stackoverflow.com/questions/5339276/what-are-the-dangers-of-method-swizzling-in-objective-c">What are the Dangers of Method Swizzling in Objective C?</a>
&ndash; <a href="https://github.com/rentzsch/jrswizzle">JRSwizzle</a></p>

<h2>总结</h2>

<p>我们之所以让自己的类继承<code>NSObject</code>不仅仅因为苹果帮我们完成了复杂的内存分配问题，更是因为这使得我们能够用上 Runtime 系统带来的便利。可能我们平时写代码时可能很少会考虑一句简单的<code>[receiver message]</code>背后发生了什么，而只是当做方法或函数调用。深入理解 Runtime 系统的细节更有利于我们利用消息机制写出功能更强大的代码，比如 Method Swizzling 等。</p>

<p>参考链接：<br/>
&ndash; <a href="https://developer.apple.com/library/mac/documentation/Cocoa/Conceptual/ObjCRuntimeGuide/Introduction/Introduction.html#//apple_ref/doc/uid/TP40008048">Objective-C Runtime Programming Guide</a><br/>
&ndash; <a href="http://blog.csdn.net/wzzvictory/article/details/8615569">Objective-C runtime之运行时的基本特点</a><br/>
&ndash; <a href="http://cocoasamurai.blogspot.jp/2010/01/understanding-objective-c-runtime.html">Understanding the Objective-C Runtime</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[NSPredicate]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/17/nspredicate/"/>
    <updated>2014-05-17T20:42:11+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/17/nspredicate</id>
    <content type="html"><![CDATA[<p>本文转载自<a href="http://nshipster.cn/nspredicate/">http://nshipster.cn/nspredicate/</a></p>

<p>NSPredicate是一个Foundation类，它指定数据被获取或者过滤的方式。它的查询语言就像SQL的WHERE和正则表达式的交叉一样，提供了具有表现力的，自然语言界面来定义一个集合被搜寻的逻辑条件。</p>

<!--more-->


<p>相比较抽象的谈论它，展示NSPredicate的使用方法更加容易，所以我们来重新审视<a href="http://nshipster.com/nssortdescriptor/">NSSortDescriptor</a>中使用的示例数据集吧：</p>

<table>
<thead>
<tr>
<th>索引 </th>
<th> 0 </th>
<th> 1 </th>
<th> 2 </th>
<th> 3 </th>
</tr>
</thead>
<tbody>
<tr>
<td>名 </td>
<td> Alice </td>
<td> Bob   </td>
<td> Charlie </td>
<td>  Quentin</td>
</tr>
<tr>
<td>姓 </td>
<td> Smith </td>
<td> Jones </td>
<td> Smith </td>
<td> Alberts</td>
</tr>
<tr>
<td>年龄  </td>
<td> 24    </td>
<td> 27    </td>
<td> 33    </td>
<td> 31</td>
</tr>
</tbody>
</table>


<p>``` objc</p>

<p>@interface Person : NSObject
@property NSString <em>firstName;
@property NSString </em>lastName;
@property NSNumber *age;
@end</p>

<p>@implementation Person</p>

<ul>
<li>(NSString *)description {
  return [NSString stringWithFormat:@&ldquo;%@ %@&rdquo;, self.firstName, self.lastName];
}</li>
</ul>


<p>@end</p>

<h1>pragma mark &ndash;</h1>

<p>NSArray <em>firstNames = @[ @&ldquo;Alice&rdquo;, @&ldquo;Bob&rdquo;, @&ldquo;Charlie&rdquo;, @&ldquo;Quentin&rdquo; ];
NSArray </em>lastNames = @[ @&ldquo;Smith&rdquo;, @&ldquo;Jones&rdquo;, @&ldquo;Smith&rdquo;, @&ldquo;Alberts&rdquo; ];
NSArray *ages = @[ @24, @27, @33, @31 ];</p>

<p>NSMutableArray <em>people = [NSMutableArray array];
[firstNames enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL </em>stop) {</p>

<pre><code>Person *person = [[Person alloc] init];
person.firstName = firstNames[idx];
person.lastName = lastNames[idx];
person.age = ages[idx];
[people addObject:person];
</code></pre>

<p>}];</p>

<p>NSPredicate <em>bobPredicate = [NSPredicate predicateWithFormat:@&ldquo;firstName = &lsquo;Bob&rsquo;&rdquo;];
NSPredicate </em>smithPredicate = [NSPredicate predicateWithFormat:@&ldquo;lastName = %@&rdquo;, @&ldquo;Smith&rdquo;];
NSPredicate *thirtiesPredicate = [NSPredicate predicateWithFormat:@&ldquo;age >= 30&rdquo;];</p>

<p>// [&ldquo;Bob Jones&rdquo;]
NSLog(@&ldquo;Bobs: %@&rdquo;, [people filteredArrayUsingPredicate:bobPredicate]);</p>

<p>// [&ldquo;Alice Smith&rdquo;, &ldquo;Charlie Smith&rdquo;]
NSLog(@&ldquo;Smiths: %@&rdquo;, [people filteredArrayUsingPredicate:smithPredicate]);</p>

<p>// [&ldquo;Charlie Smith&rdquo;, &ldquo;Quentin Alberts&rdquo;]
NSLog(@&ldquo;30&rsquo;s: %@&rdquo;, [people filteredArrayUsingPredicate:thirtiesPredicate]);
```</p>

<h2>集合中使用NSPredicate</h2>

<p>Foundation提供使用谓词（predicate）来过滤NSArray／NSMutableArray&amp;NSSet／NSMutableSet的方法。</p>

<p>不可变的集合，NSArray&amp;NSSet，有可以通过评估接收到的predicate来返回一个不可变集合的方法<code>filteredArrayUsingPredicate:</code>和<code>filteredSetUsingPredicate:</code>。</p>

<p>可变集合，NSMutableArray&amp;NSMutableSet，可以使用方法<code>filterUsingPredicate:</code>，它可以通过运行接收到的谓词来移除评估结果为FALSE的对象。</p>

<p>NSDictionary可以用谓词来过滤它的键和值（两者都为NSArray对象）。NSOrderedSet可以由过滤的NSArray或NSSet生成一个新的有序的集，或者NSMutableSet可以简单的<code>removeObjectsInArray:</code>，来传递通过<em>否定</em>predicate过滤的对象。</p>

<h2>Core Data中使用NSPredicate</h2>

<p>NSFetchRequest有一个predicate属性，它可以指定管理对象应该被获取的逻辑条件。谓词的使用规则在这里同样适用，唯一的区别在于，在管理对象环境中，谓词由持久化存储助理（persistent store coordinator）评估，而不像集合那样在内存中被过滤。</p>

<h2>谓词语法</h2>

<h3>替换</h3>

<ul>
<li>%@是对值为字符串，数字或者日期的对象的替换值。</li>
<li>%K是key path的替换值。</li>
</ul>


<p>```
NSPredicate *ageIs33Predicate = [NSPredicate predicateWithFormat:@&ldquo;%K = %@&rdquo;, @&ldquo;age&rdquo;, @33];</p>

<p>// [&ldquo;Charlie Smith&rdquo;]
NSLog(@&ldquo;Age 33: %@&rdquo;, [people filteredArrayUsingPredicate:ageIs33Predicate]);
<code>``
- $VARIABLE_NAME是可以被</code>NSPredicate -predicateWithSubstitutionVariables:`替换的值。</p>

<p>```
NSPredicate *namesBeginningWithLetterPredicate = [NSPredicate predicateWithFormat:@&ldquo;(firstName BEGINSWITH[cd] $letter) OR (lastName BEGINSWITH[cd] $letter)&rdquo;];</p>

<p>// [&ldquo;Alice Smith&rdquo;, &ldquo;Quentin Alberts&rdquo;]
NSLog(@&ldquo;&lsquo;A&rsquo; Names: %@&rdquo;, [people filteredArrayUsingPredicate:[namesBeginningWithLetterPredicate predicateWithSubstitutionVariables:@{@&ldquo;letter&rdquo;: @&ldquo;A&rdquo;}]]);
```</p>

<h3>基本比较</h3>

<ul>
<li>=, ==：左边的表达式和右边的表达式相等。</li>
<li>>=, =>：左边的表达式大于或者等于右边的表达式。</li>
<li>&lt;=, =&lt;：左边的表达式小于等于右边的表达式。</li>
<li>>：左边的表达式大于右边的表达式。</li>
<li>&lt;：左边的表达式小于右边的表达式。</li>
<li>!=, &lt;>：左边的表达式不等于右边的表达式。</li>
<li>BETWEEN：左边的表达式等于右边的表达式的值或者介于它们之间。右边是一个有两个指定上限和下限的数值的数列（指定顺序的数列）。比如，1 BETWEEN { 0 , 33 }，或者$INPUT BETWEEN { $LOWER, $UPPER }。</li>
</ul>


<h3>基本复合谓词</h3>

<ul>
<li>AND, &amp;&amp;：逻辑与.</li>
<li>OR, ||：逻辑或.</li>
<li>NOT, !：逻辑非.</li>
</ul>


<h3>字符串比较</h3>

<p><em>字符串比较在默认的情况下是区分大小写和音调的。你可以在方括号中用关键字符c和d来修改操作符以相应的指定不区分大小写和变音符号，比如firstname BEGINSWITH[cd] $FIRST_NAME。</em></p>

<ul>
<li>BEGINSWITH：左边的表达式以右边的表达式作为开始。</li>
<li>CONTAINS：左边的表达式包含右边的表达式。</li>
<li>ENDSWITH：左边的表达式以右边的表达式作为结束。</li>
<li>LIKE：左边的表达式等于右边的表达式：?和<em>可作为通配符，其中?匹配1个字符，</em>匹配0个或者多个字符。</li>
<li>MATCHES：左边的表达式根据ICU v3（更多内容请查看<a href="http://userguide.icu-project.org/strings/regexp">ICU User Guide for Regular Expressions</a>）的regex风格比较，等于右边的表达式。</li>
</ul>


<h3>合计操作</h3>

<h4>关系操作</h4>

<ul>
<li>ANY，SOME：指定下列表达式中的任意元素。比如，ANY children.age &lt; 18。</li>
<li>ALL：指定下列表达式中的所有元素。比如，ALL children.age &lt; 18。</li>
<li>NONE：指定下列表达式中没有的元素。比如，NONE children.age &lt; 18。它在逻辑上等于NOT (ANY &hellip;)。</li>
<li>IN：等于SQL的IN操作，左边的表达必须出现在右边指定的集合中。比如，name IN { &lsquo;Ben&rsquo;, &lsquo;Melissa&rsquo;, &lsquo;Nick&rsquo; }。</li>
</ul>


<h4>数组操作</h4>

<ul>
<li>array[index]：指定数组中特定索引处的元素。</li>
<li>array[FIRST]：指定数组中的第一个元素。</li>
<li>array[LAST]：指定数组中的最后一个元素。</li>
<li>array[SIZE]：指定数组的大小。</li>
</ul>


<h3>布尔值谓词</h3>

<ul>
<li>TRUEPREDICATE：结果始终为真的谓词。</li>
<li>FALSEPREDICATE：结果始终为假的谓词。</li>
</ul>


<h2>NSCompoundPredicate</h2>

<p>我们见过与&amp;或被用在谓词格式字符串中以创建复合谓词。然而，我们也可以用NSCompoundPredicate来完成同样的工作。</p>

<p>例如，下列谓词是相等的：</p>

<p>```
[NSCompoundPredicate andPredicateWithSubpredicates:@[[NSPredicate predicateWithFormat:@&ldquo;age > 25&rdquo;], [NSPredicate predicateWithFormat:@&ldquo;firstName = %@&rdquo;, @&ldquo;Quentin&rdquo;]]];</p>

<p>[NSPredicate predicateWithFormat:@&ldquo;(age > 25) AND (firstName = %@)&rdquo;, @&ldquo;Quentin&rdquo;];
```</p>

<p>虽然语法字符串文字更加容易输入，但是在有的时候，你需要结合现有的谓词。在那些情况下，你可以使用<code>NSCompoundPredicate -andPredicateWithSubpredicates:</code>&amp;<code>-orPredicateWithSubpredicates:</code>。</p>

<h2>NSComparisonPredicate</h2>

<p>同样的，如果你在读过<a href="http://nshipster.com/nsexpression/">上周的文章</a>之后发现你使用了太多的NSExpression的话，NSComparisonPredicate可以帮助你解决这个问题。</p>

<p>就像NSCompoundPredicate一样，NSComparisonPredicate从子部件构建了一个NSPredicate－－在这种情况下，左侧和右侧都是NSExpression。 分析它的类的构造函数可以让我们一窥NSPredicate的格式字符串是如何解析的：</p>

<p>```
+ (NSPredicate <em>)predicateWithLeftExpression:(NSExpression </em>)lhs</p>

<pre><code>                         rightExpression:(NSExpression *)rhs
                                modifier:(NSComparisonPredicateModifier)modifier
                                    type:(NSPredicateOperatorType)type
                                 options:(NSUInteger)options
</code></pre>

<p>```</p>

<h4>参数</h4>

<ul>
<li>lhs：左边的表达式。</li>
<li>rhs：右边的表达式。</li>
<li>modifier：应用的修改符。（ANY或者ALL）</li>
<li>type：谓词运算符类型。</li>
<li>options：要应用的选项。没有选项的话则为0。</li>
</ul>


<h3>NSComparisonPredicate类型</h3>

<p><code>
enum {
   NSLessThanPredicateOperatorType = 0,
   NSLessThanOrEqualToPredicateOperatorType,
   NSGreaterThanPredicateOperatorType,
   NSGreaterThanOrEqualToPredicateOperatorType,
   NSEqualToPredicateOperatorType,
   NSNotEqualToPredicateOperatorType,
   NSMatchesPredicateOperatorType,
   NSLikePredicateOperatorType,
   NSBeginsWithPredicateOperatorType,
   NSEndsWithPredicateOperatorType,
   NSInPredicateOperatorType,
   NSCustomSelectorPredicateOperatorType,
   NSContainsPredicateOperatorType,
   NSBetweenPredicateOperatorType
};
typedef NSUInteger NSPredicateOperatorType;
</code></p>

<h3>NSComparisonPredicate选项</h3>

<ul>
<li>NSCaseInsensitivePredicateOption：不区分大小写的谓词。你通过在谓词格式字符串中加入后面带有[c]的字符串操作（比如，"NeXT" like[c] &ldquo;next"）来表达这一选项。</li>
<li>NSDiacriticInsensitivePredicateOption：忽视发音符号的谓词。你通过在谓词格式字符串中加入后面带有[d]的字符串操作（比如，"naïve" like[d] &ldquo;naive"）来表达这一选项。</li>
<li>NSNormalizedPredicateOption：表示待比较的字符串已经被预处理了。这一选项取代了NSCaseInsensitivePredicateOption和NSDiacriticInsensitivePredicateOption，旨在用作性能优化的选项。你可以通过在谓词格式字符串中加入后面带有[n]的字符串（比如，"WXYZlan" matches[n] &ldquo;.lan"）来表达这一选项。</li>
<li>NSLocaleSensitivePredicateOption：表明要使用&lt;，&lt;=，=，=>，> 作为比较的字符串应该使用区域识别的方式处理。你可以通过在&lt;，&lt;=，=，=>，>其中之一的操作符后加入[l]（比如，"straße" >[l] &ldquo;strasse"）以便在谓词格式字符串表达这一选项。</li>
</ul>


<h2>Block谓词</h2>

<p>最后，如果你实在不愿意学习NSPredicate的格式语法，你也可以学学NSPredicate +predicateWithBlock:。</p>

<p>```
NSPredicate <em>shortNamePredicate = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary </em>bindings) {</p>

<pre><code>        return [[evaluatedObject firstName] length] &lt;= 5;
    }];
</code></pre>

<p>// [&ldquo;Alice Smith&rdquo;, &ldquo;Bob Jones&rdquo;]
NSLog(@&ldquo;Short Names: %@&rdquo;, [people filteredArrayUsingPredicate:shortNamePredicate]);
<code>``
...好吧，虽然使用</code>predicateWithBlock:`是懒人的做法，但它也并不是一无是处。</p>

<p>事实上，因为block可以封装任意的计算，所以有一个查询类是无法以NSPredicate格式字符串形式来表达的（比如对运行时被动态计算的值的评估）。而且当同一件事情可以用NSExpression结合自定义选择器来完成时，block为完成工作提供了一个方便的接口。</p>

<p>重要提示：<strong>由<code>predicateWithBlock:</code>生成的NSPredicate不能用于由SQLite存储库支持的Core Data数据的提取要求。</strong></p>

<p>我知道我已经说过很多次了，可是NSPredicate真的是Cocoa的优势之一。其他语言的第三方库如果能有它一半的能力就已经很幸运了－－更别提标准库了。对于我们这些应用和框架开发者来说，有它作为标准组件使得我们在处理数据时有了很大的优势。</p>

<p>和NSExpression一样，NSPredicate一直在提醒我们Foundation有多么好：它不仅仅十分有用，它精致的构架和设计也是我们写代码时灵感的来源。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C中的KVC和KVO]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/"/>
    <updated>2014-05-12T12:02:32+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo</id>
    <content type="html"><![CDATA[<p>本文讲述了使用Cocoa框架中的KVC和KVO，实现观察者模式</p>

<!--more-->


<h2>KVC</h2>

<p>键/值编码中的基本调用包括<code>-valueForKey:</code>和<code>-setValue:forKey:</code>。以字符串的形式向对象发送消息，这个字符串是我们关注的属性的关键。<br/>
<code>valueForKey:</code>首先查找以键<code>-key</code>或<code>-isKey   </code>命名的getter方法。如果不存在getter方法（假如我们没有通过<code>@synthesize</code>提供存取方法），它将在对象内部查找名为<code>_key</code>或<code>key</code>的实例变量。<br/>
对于KVC，Cocoa自动放入和取出标量值（int，float和struct）放入NSNumber或NSValue中；当使用<code>-setValue:ForKey:</code>时，它自动将标量值从这些对象中取出。仅KVC具有这种自动包装功能，常规方法调用和属性语法不具备该功能。<br/>
<code>-setValue:ForKey:</code>的工作方式和<code>-valueForKey:</code>相同。它首先查找名称的setter方法，如果不存在setter方法，它将在类中查找名为<code>_key</code>或<code>key</code>的实例变量。</p>

<p>使用KVC访问属性的代价比直接使用存取方法要大，所以只在需要的时候才用。</p>

<p>最简单的 KVC 能让我们通过以下的形式访问属性：</p>

<p><code>objc
@property (nonatomic, copy) NSString *name;
</code></p>

<p>取值：</p>

<p><code>
NSString *n = [object valueForKey:@"name"];
</code>
设定：</p>

<p><code>
[object setValue:@"Daniel" forKey:@"name"];
</code>
值得注意的是这个不仅可以访问作为对象属性，而且也能访问一些标量（例如 int 和 CGFloat）和 struct（例如 CGRect）。Foundation 框架会为我们自动封装它们。举例来说，如果有以下属性：</p>

<p><code>
@property (nonatomic) CGFloat height;
</code>
我们可以这样设置它：</p>

<p><code>
[object setValue:@(20) forKey:@"height"];
</code></p>

<p>有关KVC的更多用法，参看下面的文章：</p>

<p><a href="http://blog.csdn.net/omegayy/article/details/7381301  ">http://blog.csdn.net/omegayy/article/details/7381301  </a>
<a href="http://blog.csdn.net/wzzvictory/article/details/9674431  ">http://blog.csdn.net/wzzvictory/article/details/9674431  </a>
<a href="http://objccn.io/issue-7-3/">http://objccn.io/issue-7-3/</a></p>

<h2>KVO</h2>

<p>KVO是Cocoa提供的一种称为键－值观察的机制，对象可以通过它得到其他对象特性属性的变更通知。这种机制在MVC模式的场景中很重要，因为它让视图对象可以经由控制器层观察模型对象的变更。<br/>
这一机制基于NSKeyValueObserving非正式协议，Cocoa通过这个协议为所有遵守协议的对象提供了一种自动化的属性观察能力。要实现自动观察，参与KVO的对象需要符合KVC的要求和存取方法，也可以手动实现观察者通知，也可以两者都保留。</p>

<p>KVO是Cocoa框架使用<strong>观察者模式</strong>的一种途径。</p>

<p>设置一个属性的观察者需要三步，理解这些步骤可以更清楚的知道KVO的工作框图<br/>
1. 首先看看你当前的场景如果使用KVO是否更妥当，比如，当一个实例的某个具体属性有任何变更的时候，另一个实例需要被通知。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353389577.jpg" alt="" /></p>

<p>比如，BankObject中的accountBalance属性有任何变更时，某个PersonObject对象都要觉察到。<br/>
2. 这个PersonObject对象必须注册成为BankObject的accountBalance属性的观察者，可以通过发送<code>addObserver:forKeyPath:options:context:</code>消息来实现。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353389319.jpg" alt="" /></p>

<p>注意：<code>addObserver:forKeyPath:options:context:</code>方法在你指定的两个实例间建立联系，而不是在两个类之间。<br/>
3. 为了回应变更通知，观察者必须实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法。这个方法的实现决定了观察者如何回应变更通知。你可以在这个方法里自定义如何回应被观察属性的变更。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353388989.jpg" alt="" />  <br/>
4. 当一个被观察属性的值以符合KVO方式变更或者当它依赖的键变更时，<code>observeValueForKeyPath:ofObject:change:context:</code>方法会被自动执行。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353389524.jpg" alt="" /></p>

<h3>Registering for Key-Value Observing</h3>

<h4>注册成为观察者</h4>

<p>你可以通过发送<code>addObserver:forKeyPath:options:context:</code>消息来注册观察者</p>

<p>``` objc
&ndash; (void)registerAsObserver {</p>

<pre><code>/*
 Register 'inspector' to receive change notifications for the "openingBalance" property of
 the 'account' object and specify that both the old and new values of "openingBalance"
 should be provided in the observe… method.
 */
[account addObserver:inspector
         forKeyPath:@"openingBalance"
             options:(NSKeyValueObservingOptionNew |
                        NSKeyValueObservingOptionOld)
                context:NULL];
</code></pre>

<p>}
```</p>

<p>inspector注册成为了account的观察者，被观察属性的KeyPath是@&ldquo;openingBalance"，也就是account的openingBalance属性，NSKeyValueObservingOptionNew和NSKeyValueObservingOptionOld选项分别标识在观察者接收通知时change字典对应入口提供更改后的值和更改前的值。更简单的办法是用 NSKeyValueObservingOptionPrior 选项，随后我们就可以用以下方式提取出改变前后的值：(change是个字典，详细介绍请看下节)</p>

<p><code>
id oldValue = change[NSKeyValueChangeOldKey];
id newValue = change[NSKeyValueChangeNewKey];
</code></p>

<p>我们常常需要当一个值改变的时候更新 UI，但是我们也要在第一次运行代码的时候更新一次 UI。我们可以用 KVO 并添加 NSKeyValueObservingOptionInitial 的选项 来一箭双雕地做好这样的事情。这将会让 KVO 通知在调用 -addObserver:forKeyPath:&hellip; 到时候也被触发。<br/>
当我们注册 KVO 通知的时候，我们可以添加 NSKeyValueObservingOptionPrior 选项，这能使我们在键值改变之前被通知。这和-willChangeValueForKey:被触发的时间相对应。<br/>
如果我们注册通知的时候附加了 NSKeyValueObservingOptionPrior 选项，我们将会收到两个通知：一个在值变更前，另一个在变更之后。变更前的通知将会在 change 字典中有不同的键。</p>

<p>context是一个指针，当<code>observeValueForKeyPath:ofObject:change:context:</code>方法执行时context会提供给观察者。context可以使C指针或者一个对象引用，既可以当作一个唯一的标识来分辨被观察的变更，也可以向观察者提供数据。</p>

<h4>接收变更通知</h4>

<p>当被观察的属性变更时，观察者会接到<code>observeValueForKeyPath:ofObject:change:context:</code>消息，所有的观察者都必须实现这个方法。<br/>
观察者会被提供触发通知的对象和key path，一个包含变更详细信息的字典，还有一个注册观察者时提供的context指针。</p>

<p>```
&ndash; (void)observeValueForKeyPath:(NSString *)keyPath</p>

<pre><code>                  ofObject:(id)object
                    change:(NSDictionary *)change
                   context:(void *)context {

if ([keyPath isEqual:@"openingBalance"]) {
    [openingBalanceInspectorField setObjectValue:
        [change objectForKey:NSKeyValueChangeNewKey]];
}
/*
 Be sure to call the superclass's implementation *if it implements it*.
 NSObject does not implement the method.
 */
[super observeValueForKeyPath:keyPath
                     ofObject:object
                       change:change
                       context:context];
</code></pre>

<p>}
```
关于change参数，它是一个字典，有五个常量作为它的键：</p>

<p>NSString <em>const NSKeyValueChangeKindKey;<br/>
NSString </em>const NSKeyValueChangeNewKey;<br/>
NSString <em>const NSKeyValueChangeOldKey;<br/>
NSString </em>const NSKeyValueChangeIndexesKey;<br/>
NSString *const NSKeyValueChangeNotificationIsPriorKey;</p>

<p><strong>NSKeyValueChangeKindKey</strong><br/>
指明了变更的类型，值为“NSKeyValueChange”枚举中的某一个，类型为NSNumber。</p>

<p><code>
enum {
   NSKeyValueChangeSetting = 1,
   NSKeyValueChangeInsertion = 2,
   NSKeyValueChangeRemoval = 3,
   NSKeyValueChangeReplacement = 4
};
typedef NSUInteger NSKeyValueChange;
</code>
<strong>NSKeyValueChangeNewKey</strong><br/>
如果 NSKeyValueChangeKindKey的值为 NSKeyValueChangeSetting，并且 NSKeyValueObservingOptionNew选项在注册观察者时也指定了，那么这个键的值就是属性变更后的新值。<br/>
对于 NSKeyValueChangeInsertion或者NSKeyValueChangeReplacement，如果 NSKeyValueObservingOptionNew选项在注册观察者时也指定了，这个键的值是一个数组，其包含了插入或替换的对象。<br/>
<strong>NSKeyValueChangeOldKey</strong><br/>
如果 NSKeyValueChangeKindKey的值为 NSKeyValueChangeSetting，并且 NSKeyValueObservingOptionOld选项在注册观察者时也指定了，那么这个键的值就是属性变更前的旧值。<br/>
对于  NSKeyValueChangeRemoval 或者NSKeyValueChangeReplacement，如果 NSKeyValueObservingOptionOld选项在注册观察者时也指定了，这个键的值是一个数组，其包含了被移除或替换的对象。<br/>
<strong>NSKeyValueChangeIndexesKey</strong><br/>
如果 NSKeyValueChangeKindKey的值为NSKeyValueChangeInsertion, NSKeyValueChangeRemoval, 或者 NSKeyValueChangeReplacement，这个键的值是一个NSIndexSet对象，包含了增加，移除或者替换对象的index。<br/>
<strong>NSKeyValueChangeNotificationIsPriorKey</strong><br/>
如果注册观察者时NSKeyValueObservingOptionPrior选项被指明了，此通知会在变更发生前被发出。其类型为NSNumber，包含的值为YES。我们可以像以下这样区分通知是在改变之前还是之后被触发的：</p>

<p>```
if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) {</p>

<pre><code>// 改变之前
</code></pre>

<p>} else {</p>

<pre><code>// 改变之后
</code></pre>

<p>}
```</p>

<h4>移除观察者</h4>

<p>你可以通过发送<code>removeObserver:forKeyPath:</code>消息来移除观察者，你需要指明观察对象和路径。</p>

<p>```
&ndash; (void)unregisterForChangeNotification {</p>

<pre><code>[observedObject removeObserver:inspector forKeyPath:@"openingBalance"];
</code></pre>

<p>}
<code>``
上面的代码将openingBalance属性的观察者inspector移除，移除后观察者再也不会收到</code>observeValueForKeyPath:ofObject:change:context:`消息。<br/>
在移除观察者之前，如果context是一个对象的引用，那么必须保持对它的强引用直到观察者被移除。</p>

<h3>KVO Compliance（KVO兼容）</h3>

<p>有两种方法可以保证变更通知被发出。自动发送通知是NSObject提供的，并且一个类中的所有属性都默认支持，只要是符合KVO的。一般情况你使用自动变更通知，你不需要写任何代码。<br/>
人工变更通知需要些额外的代码，但也对通知发送提供了额外的控制。你可以通过重写子类<code>automaticallyNotifiesObserversForKey:</code>方法的方式控制子类一些属性的自动通知。</p>

<h4>Automatic Change Notification（自动通知）</h4>

<p>下面代码中的方法都能导致KVO变更消息发出</p>

<p>```
// Call the accessor method.
[account setName:@&ldquo;Savings&rdquo;];</p>

<p>// Use setValue:forKey:.
[account setValue:@&ldquo;Savings&rdquo; forKey:@&ldquo;name&rdquo;];</p>

<p>// Use a key path, where &lsquo;account&rsquo; is a kvc-compliant property of &lsquo;document&rsquo;.
[document setValue:@&ldquo;Savings&rdquo; forKeyPath:@&ldquo;account.name&rdquo;];</p>

<p>// Use mutableArrayValueForKey: to retrieve a relationship proxy object.
Transaction <em>newTransaction = &lt;#Create a new transaction for the account#>;
NSMutableArray </em>transactions = [account mutableArrayValueForKey:@&ldquo;transactions&rdquo;];
[transactions addObject:newTransaction];
```</p>

<h4>Manual Change Notification（手动通知）</h4>

<p>下面的代码为openingBalance属性开启了人工通知，并让父类决定其他属性的通知方式。</p>

<p>```
+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey {</p>

<pre><code>BOOL automatic = NO;
if ([theKey isEqualToString:@"openingBalance"]) {
    automatic = NO;
}
else {
    automatic = [super automaticallyNotifiesObserversForKey:theKey];
}
return automatic;
</code></pre>

<p>}
```</p>

<p>要实现人工观察者通知，你要执行在变更前执行<code>willChangeValueForKey:</code>方法，在变更后执行<code>didChangeValueForKey:</code>方法：</p>

<p>```
&ndash; (void)setOpeningBalance:(double)theBalance {</p>

<pre><code>[self willChangeValueForKey:@"openingBalance"];
_openingBalance = theBalance;
[self didChangeValueForKey:@"openingBalance"];
</code></pre>

<p>}
```
为了使不必要的通知最小化我们应该在变更前先检查一下值是否变了：</p>

<p>```
&ndash; (void)setOpeningBalance:(double)theBalance {</p>

<pre><code>if (theBalance != _openingBalance) {
    [self willChangeValueForKey:@"openingBalance"];
    _openingBalance = theBalance;
    [self didChangeValueForKey:@"openingBalance"];
}
</code></pre>

<p>}
```
如果一个操作导致了多个键的变化，你必须嵌套变更通知：</p>

<p>```
&ndash; (void)setOpeningBalance:(double)theBalance {</p>

<pre><code>[self willChangeValueForKey:@"openingBalance"];
[self willChangeValueForKey:@"itemChanged"];
_openingBalance = theBalance;
_itemChanged = _itemChanged+1;
[self didChangeValueForKey:@"itemChanged"];
[self didChangeValueForKey:@"openingBalance"];
</code></pre>

<p>}
```
在to-many关系操作的情形中，你不仅必须表明key是什么，还要表明变更类型和影响到的索引。变更类型是一个 NSKeyValueChange值，被影响对象的索引是一个 NSIndexSet对象。<br/>
下面的代码示范了在to-many关系transactions对象中的删除操作：</p>

<p>```
&ndash; (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes {</p>

<pre><code>[self willChange:NSKeyValueChangeRemoval
    valuesAtIndexes:indexes forKey:@"transactions"];

// Remove the transaction objects at the specified indexes.

[self didChange:NSKeyValueChangeRemoval
    valuesAtIndexes:indexes forKey:@"transactions"];
</code></pre>

<p>}
```</p>

<h3>Registering Dependent Keys（注册依赖的属性）</h3>

<p>有一些属性的值取决于一个或者多个其他对象的属性值，一旦某个被依赖的属性值变了，依赖它的属性的变化也需要被通知。</p>

<h4>To-one Relationships</h4>

<p>要自动触发 to-one关系，有两种方法：重写<code>keyPathsForValuesAffectingValueForKey:</code>方法或者定义名称为<code>keyPathsForValuesAffecting&lt;Key&gt;</code>的方法。</p>

<p>例如一个人的全名是由姓氏和名子组成的：</p>

<p>```
&ndash; (NSString *)fullName {</p>

<pre><code>return [NSString stringWithFormat:@"%@ %@",firstName, lastName];
</code></pre>

<p>}
```
一个观察fullName的程序在firstName或者lastName变化时也应该接收到通知。</p>

<p>一种解决方法是重写<code>keyPathsForValuesAffectingValueForKey:</code>方法来表明fullname属性是依赖于firstname和lastname的：</p>

<p>```
+ (NSSet <em>)keyPathsForValuesAffectingValueForKey:(NSString </em>)key {</p>

<pre><code>NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];

if ([key isEqualToString:@"fullName"]) {
    NSArray *affectingKeys = @[@"lastName", @"firstName"];
    keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];
}
return keyPaths;
</code></pre>

<p>}
```
相当于在影响fullName值的keypath中新加了两个key：lastName和firstName，很容易理解。</p>

<p>另一种实现同样结果的方法是实现一个遵循命名方式为<code>keyPathsForValuesAffecting&lt;Key&gt;</code>的类方法，<Key>是依赖于其他值的属性名（首字母大写），用上面代码的例子来重新实现一下：</p>

<p>```
+ (NSSet *)keyPathsForValuesAffectingFullName {</p>

<pre><code>return [NSSet setWithObjects:@"lastName", @"firstName", nil];
</code></pre>

<p>}
```</p>

<p>有时在类别中我们不能添加<code>keyPathsForValuesAffectingValueForKey:</code>方法，因为不能再类别中重写方法，所以这时可以实现<code>keyPathsForValuesAffecting&lt;Key&gt;</code>方法来代替。</p>

<p>注意：你不能在<code>keyPathsForValuesAffectingValueForKey:</code>方法中设立to-many关系的依赖，相反，你必须观察在to-many集合中的每一个对象中相关的属性并通过亲自更新他们的依赖来回应变更。下一节将会讲述对付此情形的策略。</p>

<h4>To-many Relationships</h4>

<p><code>keyPathsForValuesAffectingValueForKey:</code>方法不支持包含to-many关系的keypath。比如，假如你有一个Department类，它有一个针对Employee类的to-many关系（雇员），Employee类有salary属性。你希望Department类有一个totalSalary属性来计算所有员工的薪水，也就是在这个关系中Department的totalSalary依赖于所有Employee的salary属性。你不能通过实现<code>keyPathsForValuesAffectingTotalSalary</code>方法并返回<code>employees.salary</code>。</p>

<p>有两种解决方法：<br/>
1. 你可以用KVO将parent（比如Department）作为所有children（比如Employee）相关属性的观察者。你必须在把child添加或删除到parent时也把parent作为child的观察者添加或删除。在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中我们可以针对被依赖项的变更来更新依赖项的值：</p>

<p>```
&ndash; (void)observeValueForKeyPath:(NSString <em>)keyPath ofObject:(id)object change:(NSDictionary </em>)change context:(void *)context {</p>

<pre><code>if (context == totalSalaryContext) {
    [self updateTotalSalary];
}
else
// deal with other observations and/or invoke super...
</code></pre>

<p>}</p>

<ul>
<li><p>(void)updateTotalSalary {
  [self setTotalSalary:[self valueForKeyPath:@&ldquo;<a href="&#109;&#x61;&#x69;&#108;&#116;&#111;&#x3a;&#x65;&#x6d;&#112;&#x6c;&#111;&#121;&#101;&#x65;&#115;&#x2e;&#x40;&#115;&#x75;&#109;&#x2e;&#115;&#x61;&#108;&#x61;&#x72;&#x79;">&#x65;&#109;&#x70;&#x6c;&#x6f;&#x79;&#x65;&#x65;&#x73;&#46;&#x40;&#115;&#117;&#109;&#46;&#115;&#97;&#x6c;&#97;&#x72;&#x79;</a>&rdquo;]];
}</p></li>
<li><p>(void)setTotalSalary:(NSNumber *)newTotalSalary {</p>

<p>  if (totalSalary != newTotalSalary) {
      [self willChangeValueForKey:@&ldquo;totalSalary&rdquo;];
      _totalSalary = newTotalSalary;
      [self didChangeValueForKey:@&ldquo;totalSalary&rdquo;];
  }
}</p></li>
<li><p>(NSNumber *)totalSalary {
  return _totalSalary;
}
```</p></li>
</ul>


<p>2.如果你在使用Core Data，你可以在应用的notification center中将parent注册为它的 managed object context的观察者，parent应该回应相应的变更通知，这些通知是children以类似KVO的形式发出的。</p>

<p>其实这也是Objective-C中利用Cocoa实现观察者模式的另一种途径：NSNotificationCenter</p>

<h3>调试KVO</h3>

<p>你可以在 lldb 里查看一个被观察对象的所有观察信息。</p>

<p><code>
(lldb) po [observedObject observationInfo]
</code>
这会打印出有关谁观察谁之类的很多信息。</p>

<p>这个信息的格式不是公开的，我们不能让任何东西依赖它，因为苹果随时都可以改变它。不过这是一个很强大的排错工具。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[装饰者模式]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi/"/>
    <updated>2014-05-10T09:47:05+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353405846.png" alt="" /></p>

<!--more-->


<ul>
<li>装饰者和被装饰对象有相同的超类型。</li>
<li>你可以用一个或多个装饰者包装一个对象。</li>
<li>既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合 ,可以用装饰过的对象代替它。</li>
<li><strong>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。</strong></li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰
对象。</li>
</ul>


<p><strong>类应该对扩展开放，对修改关闭。</strong></p>

<h2>用配置咖啡饮料做例子</h2>

<p>比如，现在有一个饮料类（Beverage），向饮料中添加不同的配料（蒸奶（Steamed Milk）、豆浆（Soy）、
摩卡（Mocha，也就是巧克力风味）或覆盖奶泡），就会配制出很多种不同的种类的饮料，其价格也随着添加的配料而变化，饮料店需要计算价格，如果用具体子类继承饮料类并考虑到所有组合的话，将是一个“类爆炸”：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353406269.png" alt="" /></p>

<p>更恶心的是，如果某种配料的价格有变化，就必须含有此配料相应的更改一些饮料子类的实现，记住：<strong>类应该对扩展开放，对修改关闭。</strong></p>

<p>应用装饰者模式，就像给对象穿衣服一样一层一层将拓展动态的添加上去，灵活多变有弹性</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353407109.png" alt="" /></p>

<p>下面用Java实现这个例子</p>

<p>Beverage是一个抽象类，有两个方法：getDescrip-tion()及cost（）</p>

<p><code>java
public abstract class Beverage {
String description = "Unknown Beverage";
public String getDescription() {
return description;
}
public abstract double cost();
}
</code>
Beverage很简单。让我们也来实现Condiment（配料）抽象类，也就是装饰者类吧：</p>

<p><code>
public abstract class CondimentDecorator extends Beverage {
public abstract String getDescription();
}
</code>
必须让Condiment Decorator能够取代Beverage，所以将CondimentDecorator扩展自 Beverage 类</p>

<p>现在，已经有了基类，让我们开始开始实现一些饮料吧！先从浓缩咖啡（Espresso）开始。别忘了，我们需要为具体的饮料设置描述，而且还必须实现cost()方法</p>

<p><code>
public class Espresso extends Beverage {
public Espresso() {
description = "Espresso";
}
public double cost() {
return 1.99;
}
}
</code></p>

<p>其他几种具体的饮料就不写了</p>

<p>如果你回头去看看装饰者模式的类图，将发现我们已经完成了抽象组件（Beverage），有了具体组件（HouseBlend），也有了抽象装饰者（CondimentDecorator）。现在，我们就来实现具体装饰者。先从摩卡下手：</p>

<p><code>
public class Mocha extends CondimentDecorator {
Beverage beverage;
public Mocha(Beverage beverage) {
this.beverage = beverage;
}
public String getDescription() {
return beverage.getDescription() + ", Mocha";
}
public double cost() {
return .20 + beverage.cost();
}
}
</code></p>

<p>你会发现在装饰者类中，完成了描述和价格的效果添加，也就是完成了拓展</p>

<p>其他几种配料代码就不写了</p>

<p>下面进行测试：</p>

<p><code>
public class StarbuzzCoffee {
public static void main(String args[]) {
Beverage beverage = new Espresso();
System.out.println(beverage.getDescription()
+ " $" + beverage.cost());
Beverage beverage2 = new DarkRoast();
beverage2 = new Mocha(beverage2);
beverage2 = new Mocha(beverage2);
beverage2 = new Whip(beverage2);
System.out.println(beverage2.getDescription()
+ " $" + beverage2.cost());
Beverage beverage3 = new HouseBlend();
beverage3 = new Soy(beverage3);
beverage3 = new Mocha(beverage3);
beverage3 = new Whip(beverage3);
System.out.println(beverage3.getDescription()
+ " $" + beverage3.cost());
}
}
</code></p>

<p>输出结果：</p>

<p>```
% java StarbuzzCoffee<br/>
Espresso $1.99<br/>
Dark Roast Coffee, Mocha, Mocha, Whip $1.49<br/>
House Blend Coffee, Soy, Mocha, Whip $1.34<br/>
%</p>

<p>```
果然是一层套一层吧：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353407345.png" alt="" /></p>

<h2>Java中的装饰者</h2>

<p>java.io包内的类太多了，简直是……“排山倒海”。你第一次（还有第二次和第三次）看到这些API发出“哇”的惊叹时，放心，你不是唯一受到惊吓的人。现在，你已经知道装饰者模式，这些I/O的相关类对你来说应该更有意义了，因为其中许多类都是装饰者。下面是一个典型的对象集合，用装饰者来将功能结合起来，以读取文件数据：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353408228.png" alt="" /></p>

<p><code>BufferedInputStream</code>及<code>LineNumberInputStream</code>都扩展自<code>FilterInputStream</code>，而<code>FilterInputStream</code>是一个抽象的装饰类。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353408237.png" alt="" /></p>

<p>你会发现“输出”流的设计方式也是一样的。你可能还会发现Reader/Writer流（作为基于字符数据的输入输出）和输入流/输出流的类相当类似（虽然有一些小差异和不一致之处，但是相当雷同，所以你应该可以了解这些类）。</p>

<p>但是JavaAI/O也引出装饰者模式的一个“缺点”：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。但是，现在你已经了解了装饰者的工作原理，以后当使用别人的大量装饰的API时，就可以很容易地辨别出他们的装饰者类是如何组织的，以方便用包装方式取得想要的行为。</p>

<h2>Objective-C类别与装饰模式</h2>

<p>Objective-C中也可以实现基于继承和接口的装饰者模式，但这里介绍的是另一种实现方法：类别</p>

<p>类别是一个Objective-C的语言功能，通过它可以向类添加行为（方法的接口与实现），而不必进行子类化。通过类别添加的方法对类原有的方法没有不良影响。类别中的方法成为了类的一部分，并可由其子类继承。</p>

<p>我们可以用类别来实现装饰模式，然而这不是一种严格的实现，它实现了模式的意图，但却是一种变体。由装饰器类别添加的行为是编译时绑定的，虽然Objective-C原本支持动态绑定（应该用方法的哪个实现）。而且装饰器类别实际上没有封装被扩展的类的实例。</p>

<p>尽管使用类别来实现这个模式跟原始风格有些偏离，但是实现少量的装饰器的时候，它比真正子类的方式更为轻量、更为容易。</p>

<p>这次我们来装饰一张照片，装饰的方法有很多，比如旋转位移变换，阴影。。。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353408757.png" alt="" /></p>

<p>工程代码可以在<a href="https://github.com/yulingtianxia/Decorator">这里</a>下载</p>

<p>这一方式中有三个类别：UIImage(BaseFilter),UIImage(Transform)和UIImage(Shadow)。从现在起，我把它们分别简称为BaseFilter、Transform和Shadow。BaseFilter定义了几个基本的二维绘图操作，使用当前绘图上下文绘制自己，其他滤镜类别可以使用同样的方法来绘制图像。Transform和Shadow没有继承BaseFilter，但他们属于同一类，因为他们都是UIImage的类别。BaseFilter中定义的方法也能在Transform和Shadow类别中使用，而不必像子类化那样进行继承。</p>

<p>UIImage(BaseFilter)中的方法定义，用户绘制图像，相当于装饰者抽象类，而UIImage则是被装饰的组件:</p>

<p>``` objc</p>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (BaseFilter)
&ndash; (CGContextRef) beginContext
{</p>

<pre><code>CGSize size = [self size];
UIGraphicsBeginImageContextWithOptions(size, NO, 0);
CGContextRef context = UIGraphicsGetCurrentContext();

return context;
</code></pre>

<p>}</p>

<ul>
<li><p>(UIImage *) getImageFromCurrentImageContext
{
  [self drawAtPoint:CGPointZero];</p>

<p>  // Retrieve the UIImage from the current context
  UIImage *imageOut = UIGraphicsGetImageFromCurrentImageContext();</p>

<p>  return imageOut;
}</p></li>
<li><p>(void) endContext
{
  UIGraphicsEndImageContext();
}
@end
```</p></li>
</ul>


<p>Transform类别定义了一个<code>imageWithTransform:transform</code>方法，接受一个转换引用，然后把应用于内部的图像引用，并让它把自己画出来，然后返回变换后的图像:</p>

<p>```</p>

<h1>import &ldquo;UIImage+Transform.h&rdquo;</h1>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (Transform)
&ndash; (UIImage *) imageWithTransform:(CGAffineTransform)transform
{</p>

<pre><code>CGContextRef context = [self beginContext];

// setup transformation
CGContextConcatCTM(context, transform);

// Draw the original image to the context
UIImage *imageOut = [self getImageFromCurrentImageContext];

[self endContext];

return imageOut;
</code></pre>

<p>}
@end
```</p>

<p>Shadow类别定义了一个<code>imageWithDropShadow</code>方法，向图像的内部引用添加阴影效果，并返回应用效果之后的最终图像。</p>

<p>```</p>

<h1>import &ldquo;UIImage+Shadow.h&rdquo;</h1>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (Shadow)
&ndash; (UIImage *) imageWithDropShadow
{</p>

<pre><code>CGContextRef context = [self beginContext];

// set up shadow
CGSize offset = CGSizeMake (-25,  15);
CGContextSetShadow(context, offset, 20.0);

// Draw the original image to the context
UIImage * imageOut = [self getImageFromCurrentImageContext];

[self endContext];

return imageOut;
</code></pre>

<p>}
@end
```
最后在ViewController中加载图像：</p>

<p>```
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.
UIImage *image = imageView.image;


// create a transformation
CGAffineTransform rotateTransform = CGAffineTransformMakeRotation(-M_PI / 4.0);
CGAffineTransform translateTransform = CGAffineTransformMakeTranslation(-image.size.width / 2.0,
                                                                        image.size.height / 8.0);
CGAffineTransform finalTransform = CGAffineTransformConcat(rotateTransform, translateTransform);
UIImage* finalImage = [[image imageWithTransform:finalTransform] imageWithDropShadow];
[imageView setImage:finalImage];
</code></pre>

<p>}
```</p>

<p>因为类别只能拓展方法，不能在原有类的基础上添加属性，但是我们依然可以通过下面的方式向类中动态添加属性，来弥补类别的不足：</p>

<p>给UIImage添加一个新的title属性<br/>
具体代码如下：<br/>
<code>UIImage+Title.h</code>:</p>

<p><code>
@interface UIImage(Title)
@property(nonatomic, copy) NSString *title;
@end
</code>
<code>UIImage+Title.m</code>:</p>

<p>```</p>

<h1>import &ldquo;UIImage+Title.h&rdquo;</h1>

<p>static char titleKey;</p>

<p>@implementation UIImage(Title)
&ndash; (NSString *)title
{</p>

<pre><code>return objc_getAssociatedObject(self, &amp;titleKey);
</code></pre>

<p>}</p>

<ul>
<li>(void)setTitle:(NSString *)title
{
  objc_setAssociatedObject(self, &amp;titleKey, title, OBJC_ASSOCIATION_COPY);
}
@end
```
可以看到关键是用到了runtime的两个函数：</li>
<li><code>id objc_getAssociatedObject(id object, void *key)</code></li>
<li><code>void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)</code></li>
</ul>


<p>该函数中第一个参数表示目标对象，第三个参数表示要添加的属性，第四个参数设置objc_AssociationPolicy,它有以下几个选项：<br/>
<a href="http://yulingtianxia.qiniudn.com/">http://yulingtianxia.qiniudn.com/</a><code>OBJC_ASSOCIATION_ASSIGN</code>，<code>OBJC_ASSOCIATION_RETAIN</code>，<code>OBJC_ASSOCIATION_COPY</code>，分别对应我们在声明属性时的<code>assign</code>,<code>retain</code>,<code>copy</code>。<br/>
关于第二个参数，key。因为一个对象可以关联多个新的对像，我们需要一个标志来区分他们。所以这个key就起这样的作用。这里的需要的key的地址，不关心它指向谁。</p>

<p>当我们第二次以新的value调用objc_setAssociatedObject时，如果policy是OBJC_ASSOCIATION_ASSIGN，新的value被关联，对原来旧的value没有任何影响。如果policy是OBJC_ASSOCIATION_RETAIN和OBJC_ASSOCIATION_COPY，新的value被关联，旧的value被release。如果想release原来的value又不关联新的value，，可以用objc_setAssociatedObject直接传一个nil做为value的值。</p>

<p>注意不要使用<code>objc_removeAssociatedObjects</code>，因为它用去掉所有的关联的对象。</p>

<p>参考资料：<br/>
1. 《iOS设计模式解析》<br/>
2. 《HeadFirst设计模式》<br/>
3. <a href="http://fanliugen.com/?p=460">http://fanliugen.com/?p=460</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Core Data(2)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/"/>
    <updated>2014-05-02T20:17:04+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2</id>
    <content type="html"><![CDATA[<p>本文内容：</p>

<ul>
<li>自定义NSManagedObject</li>
<li>使用数据模型设计器</li>
<li>探究Core Data在SQLite中的实现</li>
</ul>


<p>推荐先阅读上一篇文章：<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a></p>

<p><strong>文章所使用的项目代码可以到<a href="https://github.com/yulingtianxia/MyCDDemo">这里</a>下载</strong></p>

<p>在<a href="http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3/">下一篇文章</a>里，我将会通过教程的方式，讲述如何用Swift结合CoreData的NSFetchedResultsController写一个小Demo-<a href="http://hardchoice.yulingtianxia.com">HardChoice</a></p>

<!--more-->


<h2>自定义NSManagedObject</h2>

<p>在上一篇教程中我们每条数据都是通过<code>NSManagedObject</code>对象装载，通过KVC方式使用<code>valueForKey：</code>方法访问对象属性，但是使用KVC要比使用访问器效率低一点。 只在必要时使用KVC，比如你需要动态选择key或keyPath。</p>

<p><code>objc
[newEmployee setValue:@”Stig” forKey:firstName];
[aDepartment setValue:@1000 forKeyPath:manager.salary];
</code></p>

<p>下面我们将自定义<code>NSManagedObject</code>类，通过对它的继承拓展，使得我们有自己的Event类，并通过访问器方法代替KVC方式来访问对象的属性。<br/>
按CMD+N或者在可视化建模工具下选择菜单中Editor->Create NSManagedObject Subclass：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353399425.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353399917.png" alt="" /></p>

<p>选中需要子类化的Entity（当然我们只有一个Event，自动勾选了）：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353400261.png" alt="" /></p>

<p>最后点击Create，于是Event类就创建好了，可以看到属性timeStamp已经自动生成了，并且实现为<code>@dynamic</code></p>

<p>熟悉Objective-C语法的都知道<code>@synthesize</code>实际的意义就是自动生成属性的setter和getter方法。</p>

<p><code>@dynamic</code>就是要告诉编译器，代码中用<code>@dynamic</code>修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译。其主要的作用就是用在<code>NSManagerObject</code>对象的属性声明上，由于此类对象的属性一般是从Core Data的属性中生成的，Core Data框架会在程序运行的时候为此类属性生成getter和setter方法。</p>

<p>好的，下面我们改写以前的代码，这次我们将使用Event类的对象完成以前的任务：</p>

<p>在MasterViewController.m文件中加入<code>#import "Event.h"</code>，然后将<code>insertNewObject:</code>方法替换如下</p>

<p>```
&ndash; (void)insertNewObject:(id)sender
{</p>

<pre><code>NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
NSEntityDescription *entity = [[self.fetchedResultsController fetchRequest] entity];
Event *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];

// If appropriate, configure the new managed object.
// Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
</code></pre>

<p>//    [newManagedObject setValue:[NSDate date] forKey:@&ldquo;timeStamp&rdquo;];</p>

<pre><code>newManagedObject.timeStamp = [NSDate date];
// Save the context.
NSError *error = nil;
if (![context save:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}
</code></pre>

<p>}
<code>``
嗯，英文注释还告诉我们通常你应该用访问器方法呢，还说但是现在在这用KVC就避免了向模板添加自定义类的需求，真逗啊  
依此类推，更改</code>prepareForSegue: sender:`方法：</p>

<p>```
&ndash; (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{</p>

<pre><code>if ([[segue identifier] isEqualToString:@"showDetail"]) {
    NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
    Event *object = [[self fetchedResultsController] objectAtIndexPath:indexPath];
    [[segue destinationViewController] setDetailItem:object];
}
</code></pre>

<p>}
```</p>

<p>还有<code>configureCell: atIndexPath:</code>方法：</p>

<p>```
&ndash; (void)configureCell:(UITableViewCell <em>)cell atIndexPath:(NSIndexPath </em>)indexPath
{</p>

<pre><code>Event *object = [self.fetchedResultsController objectAtIndexPath:indexPath];
</code></pre>

<p>//    cell.textLabel.text = [[object valueForKey:@&ldquo;timeStamp&rdquo;] description];</p>

<pre><code>cell.textLabel.text = [object.timeStamp description];
</code></pre>

<p>}
<code>``
相应地我们也可以针对</code>DetailViewController`进行改造：</p>

<p>DetailViewController.h:</p>

<p>```</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@class Event;
@interface DetailViewController : UIViewController</p>

<p>@property (strong, nonatomic) Event *detailItem;</p>

<p>@property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;
@end
```</p>

<p>DetailViewController.m:</p>

<p>```</p>

<h1>import &ldquo;DetailViewController.h&rdquo;</h1>

<h1>import &ldquo;Event.h&rdquo;</h1>

<p>@interface DetailViewController ()
&ndash; (void)configureView;
@end</p>

<p>@implementation DetailViewController</p>

<h1>pragma mark &ndash; Managing the detail item</h1>

<ul>
<li><p>(void)setDetailItem:(Event *)newDetailItem
{
  if (<em>detailItem != newDetailItem) {
      </em>detailItem = newDetailItem;</p>

<pre><code>  // Update the view.
  [self configureView];
</code></pre>

<p>  }
}</p></li>
<li><p>(void)configureView
{
  // Update the user interface for the detail item.</p>

<p>  if (self.detailItem) {
//        self.detailDescriptionLabel.text = [[self.detailItem valueForKey:@&ldquo;timeStamp&rdquo;] description];
      self.detailDescriptionLabel.text = [self.detailItem.timeStamp description];
  }
}</p></li>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];
  // Do any additional setup after loading the view, typically from a nib.
  [self configureView];
}</p></li>
<li><p>(void)didReceiveMemoryWarning
{
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}</p></li>
</ul>


<p>@end
```
这部分比较简单，就不详细解释了，运行程序，跟以前一样（不截图了）</p>

<p>如果想复用<code>MasterViewController</code>里面那些代码，需要做些大改动，具体可以参看<a href="http://objccn.io/issue-1-1/">更轻量的 View Controllers</a>这篇文章</p>

<h2>使用数据模型设计器</h2>

<p>点击MyCDDemo.xcdatamodeld文件进入数据模型设计器，点击下方的加号（Add Enity），添加一个Enity，将其名字改为Person。然后添加name和sex属性，类型为string，需要注意的是属性名需要首字母小写，而且我们无需像往常给数据库建表一样为其添加ID字段，因为Core Data中你不需要任何类型的唯一标识Id，也不需要处理表连接。Core Data将在后台自动处理。你所需要做的就是定义对象间的关系。Core Data框架将在后台决定如何生成最佳的底层机制。</p>

<p>与实体名一样，属性的命名也有很多的要求和约定。属性名不能以大写字母开头，不能包含空格，一般都是单数。对于Boolean类型属性，你应该遵循Objective-C实例变量的约定,比如指定一个CustomerOrder对象是否已经发货，那么应该命名属性为shipped，而不是isShipped、hasShipped等。</p>

<p>关于Core Data属性类型，我从网上摘抄了一段比较全面的解释：</p>

<ul>
<li><p>Undefined选项值是新创建的属性的默认类型；如果属性类型为undefined，项目将无法通过编译。</p></li>
<li><p>Integer 16/32/64只表示整数，没有小数点。所以如果10除以3，你将会得到3，而余数1会丢失。Integer 16/32/64之间唯一的区别是所表示的数值范围不同。因为Core Data使用符号数，所以起始范围是负数，而不是0。</p>

<ul>
<li><p>Integer 16 数值范围：-32768~32767；</p></li>
<li><p>Integer 32 数值范围：-2147483648~2147483647；</p></li>
<li><p>Integer 64 数值范围：–9223372036854775808~9223372036854775807。</p></li>
</ul>


<p>  标准整型数的最大值和最小值可以在stdint.h中找到。在任何类文件中输入INT32_MAX,选中右击，然后选择Jump To Definition，你将看到许多最大值最小值定义。<strong>实体的属性的类型是Integer 16/32/64，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSNumber</strong>。</p></li>
<li><p>Double和Float可以认为是有小数部分的整数。它们都是基于二进制数值系统，在CPU运算时很可能会发生舍入误差。比如1/5，如果使用十进制数值系统，可以精确表示为0.2.但在二进制数值系统中，只能表示一个大概，在小数部分你会得到大量数字。<strong>所以不要使用Integer、Double、Float表示货币值。</strong>计算精度越高则越加趋于准确值，但内存占用也会越大。一个Float数使用32bit进行存储，一个Double数使用64bit。它们都使用科学计数法进行存储，所以一个数包含尾数和指数部分。</p>

<p>  在iOS中，最大的Float值是340282346638528859811704183484516925440.000000，最小的Float值是340282346638528859811704183484516925440.000000Double和Float都有一个符号位。而Double比Float的数值范围更大。</p>

<p>  当你决定该选择Float还是Double时，想一下你的属性是否真的需要超过Float提供的7位精度，如果不是，你应该选择Float，因为它更加匹配64bit的iPhone 5S底层处理器。除此之外，如果你想增加浮点数的计算速度而精度并没有严格要求，Float也是最佳选择。<strong>实体的属性的类型是Float或Double，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSNumber。</strong></p></li>
<li><p><strong>Decimal（十进制）是处理货币值和其他需要十进制场合下最佳选择</strong>，Decimal提供了优秀的计算精度，也消除了计算过程中的舍入误差。因为CPU的本地数制是二进制，所以CPU在处理十进制数时，开销会多一点。<strong>实体的属性的类型是Decimal，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSDecimalNumber。</strong>当你使用NSDecimalNumber执行计算时(如加减乘除计算)，为了保证计算精度，你只能使用它提供的内建方法。更多关于NSDecimalNumber可参见这里。</p></li>
<li><p>String类型和Objective-C中的NSString类似，用于保存字符数组。当生成实体对应的NSManagedObject子类时，String属性被表示为NSString。</p></li>
<li><p>Boolean数据类型被用于表示YES/NO值。当生成实体对应的NSManagedObject子类时，Boolean数据类型会被表示为NSNumber。所以为了获取布尔值，你需要想NSNumber对象发送boolValue消息。</p></li>
<li><p>Date类型是自解释类型。用来存储日期和时间。<strong>当生成实体对应的NSManagedObject子类时，Date类型会被表示为NSDate。</strong></p></li>
<li><p>Binary Data用来表示照片，音频，或一些BLOB类型数据(&ldquo;Binary Large OBjects&rdquo; such as image and sound data)。<strong>当生成实体对应的NSManagedObject子类时，Binary Data数据类型会被表示为NSData。</strong></p></li>
<li><p>Transformable属性类型用于存储一个Objective-C对象。该属性类型允许你存储任何类的实例，比如你使用Transformable属性表示UIColor。<strong>当生成NSManagedObject子类时，Transformable类型会被表示为id。</strong>对于id对象的保存和解档需要使用一个NSValueTransformer的实例或子类的实例。由该类负责属性值与NSData之间的转换。但这也相当的简单，尤其是当属性值的类型已经实现了NSCoding协议，此时系统会自动提供一个默认的NSValueTransformer实例来完成归档和解档。</p></li>
</ul>


<p><img src="http://yulingtianxia.qiniudn.com/140353400282.png" alt="" /></p>

<p>选择一个属性，在右侧的Data Model Inspector中可以对属性进行更为详细的设置，而且这些设置项会根据你所设置的属性类型不同而不同，大致分为以下几类：</p>

<ul>
<li>Transient（瞬时）选项表示属性不会存储到持久化存储文件中。Transient通常用在属性的值是由其他属性计算或合成而来（比如fullName属性是根据Persion类实例的firstName和lastName拼接而来）。</li>
<li>Optional（可选）选项表示当前属性的值允许为空。如果将属性指定为Optional，那么即使属性的值为空，实体的NSManagedObject实例也可被保存。如果该值是必选的（不选中Optional则为必选），如果属性值为空，NSManagedObject对象上下文将拒绝保存这个属性值不完整的NSManagedObject对象（当你尝试并保存上下文，你将接收到一个NSError对象）。所有的属性最初的状态都是Optinal。</li>
<li>Indexed选项表示底层的持久化存储文件应该为该属性生成一个索引；如果你使用基于多个属性的查询条件来提取对象，指定此类属性为Indexed，可以大幅提高提取速度。</li>
<li>Reg.Ex是Regular Expression的缩写，主要是用来验证属性值是否匹配特定的模式。此选项只对String类型有效。</li>
<li>Validation可以保证非法数据不被保存进持久化存储文件中。数值属性类型（Integer 16/32/64、Float、Double、Decimal）都有maximum和minimum最大值最小值设定。你也可以对String类型设置最大长度和最小长度。或对Date类型设置日期范围。不过最好的做法是当用户向UITextField中输入数据时就开始验证数据，而非等到向上下文发送save消息才验证数据。</li>
<li>除了Transformable和Binary Data类型以外，Default适用于所有属性类型。它被用来配置属性的默认值。</li>
<li>Allows External Storage允许大尺寸的二进制数据可以保存在持久化存储文件的外部。当你保存如照片，音频或视频时，建议是选中该选项， 这样Core Data就会对大于1MB的数据保存在持久化存储文件的外部。</li>
</ul>


<p>如果你细心的话，会发现无论是属性还是实体等选项，右侧的Data Model Inspector经常会出现User Info一栏。<br/>
在managed object model中很多元素，比如entities, attributes,和 relationships，有一个相关联的用户信息字典。你可以在用户信息字典中以键值对的形式放入你想要的任何信息。这里常用的信息有实体的版本详情，还有fetched property中谓词（predicate）用到的值。</p>

<p>说了一大堆，再添加两个实体吧：Teacher和Student，都继承自Person：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353400755.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353401739.png" alt="" /></p>

<p>点击右下方的Editor Style切换到Graph模式：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353401953.png" alt="" /></p>

<p>选中Teacher，长按Add Attribute会弹出所有的选项（同样你也可以试试长按Add Enity），选择Add Relationship，添加一个关系，命名为students，Type为To Many，目标为Student（一个老师教很多学生）：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353402308.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/14035340227.png" alt="" /></p>

<p>我们再尝试一种添加关系的新方法：把以前在Teacher中建立的students删除，选中Student，按住Ctrl，鼠标拖至Teacher，这样一个双向的关系就建立起来了：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353402879.png" alt="" /></p>

<p>分别编辑双方的关系，Tpye都是To Many：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353402596.png" alt="" /></p>

<p>用上一节中提到的方法，建立这三个新建的Entity的<code>NSManagedObject</code>子类：</p>

<p><img src="http://yulingtianxia.qiniudn.com/14035340286.png" alt="" /></p>

<p>因为创建顺序的问题，当Student创建的时候还不知道有<code>Teacher</code>类，于是其生成的一些方法将Teacher默认为<code>NSManagedObject</code>类：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<p>@interface Student : NSManagedObject</p>

<p>@property (nonatomic, retain) NSNumber * grade;
@property (nonatomic, retain) NSSet *teachers;
@end</p>

<p>@interface Student (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addTeachersObject:(NSManagedObject *)value;</li>
<li>(void)removeTeachersObject:(NSManagedObject *)value;</li>
<li>(void)addTeachers:(NSSet *)values;</li>
<li>(void)removeTeachers:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>而Teacher类创建的时候已经有了<code>Student</code>类，就不会出现上面的问题：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<p>@class Student;</p>

<p>@interface Teacher : NSManagedObject</p>

<p>@property (nonatomic, retain) NSString * course;
@property (nonatomic, retain) NSSet *students;
@end</p>

<p>@interface Teacher (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addStudentsObject:(Student *)value;</li>
<li>(void)removeStudentsObject:(Student *)value;</li>
<li>(void)addStudents:(NSSet *)values;</li>
<li>(void)removeStudents:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>虽然<code>Teacher</code>类认识<code>Student</code>类，因为它已经创建了，但是此时Persion类还没有创建，于是此时<code>Student</code>类和<code>Teacher</code>类继承的依然是<code>NSManagedObject</code>，这不是我们想要的结果。<br/>
解决方法是重新生成下这三个Entity对应的<code>NSManagedObject</code>子类，并覆盖原有的文件：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<h1>import &ldquo;Person.h&rdquo;</h1>

<p>@class Teacher;</p>

<p>@interface Student : Person</p>

<p>@property (nonatomic, retain) NSNumber * grade;
@property (nonatomic, retain) NSSet *teachers;
@end</p>

<p>@interface Student (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addTeachersObject:(Teacher *)value;</li>
<li>(void)removeTeachersObject:(Teacher *)value;</li>
<li>(void)addTeachers:(NSSet *)values;</li>
<li>(void)removeTeachers:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>你会发现多了一个<code>CoreDataGeneratedAccessors</code>类别，这个类别中的方法是Core Data框架根据你在数据模式编辑器中设置的实体关系自动生成的，你不需要实现它们，Core Data会在运行时实现这些方法<br/>
如果你偏要想看看其实现机理，在右下方的代码片段库中选择“Core Data To-Many Relationship Accessors”并拖拽到代码中</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353403195.png" alt="" /></p>

<p>生成的代码如下：</p>

<p>```
&ndash; (void)add&lt;#CapitalizedRelationshipName#>Object:(&lt;#relationship destination class#> *)value
{</p>

<pre><code>NSSet *changedObjects = [NSSet setWithObject:value];
[self willChangeValueForKey:@"&lt;#relationshipName#&gt;" withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects];
[[self primitiveValueForKey:@"&lt;#relationshipName#&gt;"] addObject:value];
[self didChangeValueForKey:@"&lt;#relationshipName#&gt;" withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)remove&lt;#CapitalizedRelationshipName#>Object:(&lt;#relationship destination class#> <em>)value
{
  NSSet </em>changedObjects = [NSSet setWithObject:value];
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] removeObject:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects];
}</p></li>
<li><p>(void)add&lt;#CapitalizedRelationshipName#>:(NSSet *)value
{  <br/>
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueUnionSetMutation usingObjects:value];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] unionSet:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueUnionSetMutation usingObjects:value];
}</p></li>
<li><p>(void)remove&lt;#CapitalizedRelationshipName#>:(NSSet *)value
{
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:value];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] minusSet:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:value];
}
```</p></li>
</ul>


<p>我们需要将&lt;#Capitalized relationship name#>, &lt;#Relationship destination class#> 和 &lt;#Relationship name#>替换为我们定义的连接名，对照下前面<code>CoreDataGeneratedAccessors</code>类别中的方法名，你就会明白了</p>

<p>同样以前标记为<code>@dynamic</code>的属性，其实现原理如下：</p>

<p>```
&ndash; (&lt;#propertyObjectType#> *)&lt;#propertyName#>
{</p>

<pre><code>[self willAccessValueForKey:@"&lt;#propertyName#&gt;"];
&lt;#propertyObjectType#&gt; *value = [self primitiveValueForKey:@"&lt;#propertyName#&gt;"];
[self didAccessValueForKey:@"&lt;#propertyName#&gt;"];
return value;
</code></pre>

<p>}</p>

<ul>
<li>(void)set&lt;#CapitalizedPropertyName#>:(&lt;#propertyObjectType#> *)value
{
  [self willChangeValueForKey:@&ldquo;&lt;#propertyName#>&rdquo;];
  [self setPrimitiveValue:value forKey:@&ldquo;&lt;#propertyName#>&rdquo;];
  [self didChangeValueForKey:@&ldquo;&lt;#propertyName#>&rdquo;];
}
```
现在，我们并不需要知道他们的实现方法是如何被动态生成的，估计是用到了block或者delegate。</li>
</ul>


<h2>探究Core Data在SQLite中的实现</h2>

<p>在上一节中我们创建了<code>Person</code>，<code>Teacher</code>和<code>Student</code>三个Entity和对应的<code>NSManagedObject</code>子类，下面我们需要在代码中对其进行“实战部署”，并观察它们是如何在SQLite数据库中保存的，这样更有利于理解Core Data机制。</p>

<p>为了简单测试，我直接在MasterViewController.m文件中的<code>insertNewObject:</code>方法中加入测试代码（其实关于测试应该利用好Xcode自带的单元测试工具<a href="http://yulingtianxia.com/blog/2014/04/28/iosdan-yuan-ce-shi-%5Bnil%5Dxctest/">XCTest</a>，我这里为了方便操作，用了以前添加数据的<code>insertNewObject:</code>方法，关于工程初始代码的讲解，请看我之前的一篇<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">教程</a>）</p>

<p>```
&ndash; (void)insertNewObject:(id)sender
{</p>

<pre><code>NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
NSEntityDescription *entity = [[self.fetchedResultsController fetchRequest] entity];
Event *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];

// If appropriate, configure the new managed object.
// Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
</code></pre>

<p>//    [newManagedObject setValue:[NSDate date] forKey:@&ldquo;timeStamp&rdquo;];</p>

<pre><code>newManagedObject.timeStamp = [NSDate date];
//新加的测试代码
Student *aStudent = [NSEntityDescription insertNewObjectForEntityForName:@"Student" inManagedObjectContext:context];
aStudent.name = @"LiLei";
aStudent.sex = @"male";
aStudent.grade = @1;
Teacher *aTeacher = [NSEntityDescription insertNewObjectForEntityForName:@"Teacher" inManagedObjectContext:context];
aTeacher.name = @"MissGao";
aTeacher.sex = @"female";
aTeacher.course = @"English";
[aTeacher addStudentsObject:aStudent];


// Save the context.
NSError *error = nil;
if (![context save:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}
</code></pre>

<p>}
```</p>

<p>我们建立了一名叫LiLei的一年级男生和一名叫MissGao的教英语的女教师，并将LiLei同学添加到高老师的学生名单中。</p>

<p>运行程序，打开MyCDDemo.sqlite文件，查看表结构：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353403982.png" alt="" /></p>

<p>你会发现虽然Student和Teacher继承Person，但是Person表里面竟然也有grade和course字段</p>

<p>点击程序中的加号来添加一条数据：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353403912.png" alt="" /></p>

<p>查看ZPERSON，Z_3TEACHERS，Z_PRIMARYKEY表内容：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353404264.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353404745.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353405697.png" alt="" /></p>

<p>这次一目了然了：</p>

<p>ZPERSON表存储了子类所有字段数据，其Z_ENT字段标志着这条数据的类型，Z_ENT与类型名Z_NAME的映射关系储存在Z_PRIMARYKEY表中，而Z_3TEACHERS存储的则是ZPERSON表中数据项之间的关系，也就是之前我们建立的学生和老师的对应关系，其原理是将ZPERSON表中的Z_PK字段内容两个一组对应起来，这样就相当于把ZPERSON表中两条数据项关联起来了。之前我们在代码中只将LiLei同学添加到了MissGao老师的学生列表中，但是Core Data已经自动维护起了关系，让MissGao也存在于LiLei的老师列表中。Core Data把底层的数据库封装起来，通过简单的操作让程序员更高校的管理数据，所以SQLite这部分我们只是了解下就可以了。</p>
]]></content>
  </entry>
  
</feed>
