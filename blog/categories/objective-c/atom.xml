<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-05-02T01:16:11+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[初识Core Data(1)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data%281%29/"/>
    <updated>2014-05-01T19:58:00+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data(1)</id>
    <content type="html"><![CDATA[<p>本文内容：<br/>
1. Core Data概述<br/>
2. 新建一个Core Data工程</p>

<hr />

<!--more-->


<h2>Core Data概述</h2>

<p>Core Data本身既不是数据库也不是数据库访问框架。相反，Core Data是一个完整的数据模型解决方案。我简单理解为对持久层的封装，使得我们可以通过可视化建立数据模型，简化数据存取。有人会联想到Hibernate，其实Core Data比Hibernate强大得多，它不仅支持SQLite数据库，还能对XML文件、二进制文件、用户自定义文件进行操作。</p>

<p>即使不懂SQL语句，也依然可以使用Core Data。因为Core Data将底层的数据库SQL语句封装成了一套API，并可通过可视化操作来建立数据库的模型和表之间的关系，它甚至在数据变化时会帮你自动处理关系（比如删除了一门课程，所有选这门课程的学生也会自动解除与此门课程的关系），Core Data还能对非法数据进行过滤，还支持对数据操作的Undo/Redo功能。更重要的是，Core Data的<code>NSFetchRequest</code>类可以替代SQL中的Select语句，并提供了更高效的方法将查询结果显示在UITableView中。</p>

<p>iOS 3.0和Mac OS X10.5都支持Core Data，但iOS上不支持XML文件存储。Core Data对读取性能做了大量优化，其中惰性加载（Faulting）就是一个例子，毕竟设备的内存是有限切珍贵的。<br/>
在OSX上可以绑定利用KVO和KVC保持UI项与模型对象或属性之间的连接，无需编写任何代码，通过对象和数组控制器自动从Core Data存储区分批提取<code>NSManagedObject</code>对象。这就像在VS中用.Net构建基于SQLServer的桌面程序。<br/>
苹果公司单独为iOS平台的Core Data引入了<code>NSFetchedResultsController</code>类帮助视图与从持久化存储文件提取的数据之间的交互。它主要是用来充当<code>UITableiView</code>的数据源，负责调整<code>UITableiView</code>行与节（section）的显示数目，以及为各表格行提供内容。</p>

<h2>新建一个Core Data工程</h2>

<p>在Xcode5中，只有Master-Detail Application，Utility Application以及Empty Application支持创建时使用Core Data模板，我们选择带有UITableView的Master-Detail Application吧。</p>

<p><img src="/images/blog/QQ20140501-1@2x.png" alt="" /></p>

<p>一定要勾选Core Data选项，项目名称就叫MyCDDemo吧，嘿嘿</p>

<p><img src="/images/blog/QQ20140501-2@2x.png" alt="" /></p>

<p>项目建立后会发现Frameworks中已经有了<code>CoreData.framework</code>一项，并且还多了一个MyCDDemo.xcdatamodeld文件，该文件定义了数据模型结构，你可以使用XCode内置的可视化建模工具进行构建。点开它你会发现左侧有三项：Entities，Fetch Request、Configurations。</p>

<p><strong>Entities</strong></p>

<p>在系统的学习Core Data前，可以简单的将Entity理解为数据库中的一张表，在代码中一个<code>NSEntityDescription</code>类的对象就代表了一个Entity。Entity也像类一样可以继承，如果你有若干个相似的实体，就可以抽离出它们的共有特性作为一个“父实体”，就省去了在多个实体中都指定相同的属性。甚至可以勾选Abstract Entitiy让其成为抽象实体，就像抽象类一样。</p>

<p><img src="/images/blog/xcodeparententity_2x.png" alt="" /></p>

<p>现在已经有了一个现成的实体：Event，也就是在SQLite中有了一张叫做Event的表：</p>

<p><img src="/images/blog/QQ20140501-3@2x.png" alt="" /></p>

<p>Attributes就相当于一张表的列属性，可以设置其数据类型，默认值，最大最小值等，类似数据库可视化建表。需要注意的是这里的空值是NULL，不等同于OC中的nil，更不等同于0和空字符串@“”。Event实体中已经有了一个叫timeStamp的属性，类型为Date，这是模版自动生成的，暂且别修改它。</p>

<p>Relationships描述了Entity间的关系：多对一，一对一等。当你指定了一个关系后，苹果推荐我们也指定一个反转关系。比如A和B是多对多的关系，那么A指向B的关系Type为To Many，同时设定B指向A的关系Type为To Many。</p>

<p>Fetched Property表示了一种弱的、单向的关系。因为Core Data不支持在persistent store之间建立Relationships，所以Fetched Property可用于建立cross-store关系，还用于建立“松耦合”关系，相似暂时的分组。（a fetched property of a department might be &ldquo;recent hires&rdquo; (employees do not have an inverse to the recent hires relationship)）</p>

<p><strong>Fetch Request</strong></p>

<p>我们使用<code>NSFetchRequest</code>类来描述数据请求，利用数据请求从持久存储（persistent store）中获取对象。经常碰到的情形是你经常需要多次执行同样的请求，或是执行遵循一个给定模式的请求，但是其中包含变量（如查找条件）——这些变量经常由用户提供。例如，在运行程序的时候，你要根据用户需要获取某个作者在用户指定日期后出版的所有出版物。</p>

<p>你可以预定义请求，把它们作为模板存储在被管理对象模型中。预定义的模板在你需要的时候就可以取出使用。通常情况下，我们通过Xcode的data modeling tool工具创建请求模板。模板可以包含变量：</p>

<p><img src="/images/blog/variablelikepredicate_2x.png" alt="" /></p>

<p><strong>Configurations</strong></p>

<p>配置包含了一个名称和若干个相关的实体。实体的集合是可以重叠的——这就是说，一个实体可以出现在多个配置中。在代码中，我们使用<code>setEntities: forConfiguration:</code>的方法来指定配置。也可以用Xcode的建模工具来指定。要获取某项配置的实体，需要用<code>entitiesForConfiguration:</code>的方法。</p>

<p>一般说来，如果你想把不同的实体存放在不同的存储中去，就可能用到配置。一个持久化存储协调器（persistent store coordinator，你暂且理解为负责数据库连接的东东）只能有一个被管理对象模型（managed object model，也就是把xcdatamodeld文件加载到代码中的内容啦）。所以，默认情况下，和协调器关联的某个存储必须包含同样的实体。要想绕过这个限制，你可以创建一个包含所有实体并集的模型，然后在模型中为每一个你想使用的实体子集创建配置，这样一来，使用这个模型创建协调器，当你需要添加存储（persistent store）时，可根据不同的配置来指定对应的存储属性。当你创建配置的时候，需要记住，不能创建跨存储的关系（cross-store relationships）。</p>

<p>模版已经生成了一个叫Default的配置，但是在程序中并没有用到它（这在之后的内容会阐述）。</p>

<p>在了解了xcdatamodeld类型文件之后，你可能对Core Data如何描述一个数据库有了一定的概念，下一步我们准备阅读模版自动生成的代码，你会体会到xcdatamodeld文件在程序中是如何被加载和使用的。</p>

<p>先看看AppDelegate.h</p>

<p>``` objc</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface AppDelegate : UIResponder <UIApplicationDelegate></p>

<p>@property (strong, nonatomic) UIWindow *window;</p>

<p>@property (readonly, strong, nonatomic) NSManagedObjectContext <em>managedObjectContext;
@property (readonly, strong, nonatomic) NSManagedObjectModel </em>managedObjectModel;
@property (readonly, strong, nonatomic) NSPersistentStoreCoordinator *persistentStoreCoordinator;</p>

<ul>
<li>(void)saveContext;</li>
<li>(NSURL *)applicationDocumentsDirectory;</li>
</ul>


<p>@end
```
嗯，比平时的程序多出了三个属性嘛，而且后两个属性之前还提到过，这“三剑客“是Core Data中非常重要的三个类：</p>

<ul>
<li>Managed Object Model（管理数据模型）: 你可以将这个东西看作是数据库的轮廓，或者结构。这里包含了各个实体的定义信息，一般来说，你会使用我们刚刚看过的视觉编辑器来操作这个物体，添加属性，建立属性之间的关系等等，当然你也可以使用代码。</li>
<li>Persistent Store Coordinator （持久性数据协调器）： 你可以将这个东西看作是数据库连接库，在这里，你将设置数据存储的名字和位置，以及数据存储的时机。</li>
<li>Managed Object Context （管理数据内容）：你可以将这一部分看作是数据的实际内容，这也是整个数据库中对我们而言最重要的部分（这还用说），基本上，插入数据，查询数据，删除数据的工作都在这里完成。</li>
</ul>


<p>如果你还是不好理解，那么简单的把这“三剑客”理解为：数据定义语言 (DDL)、数据库连接（DBC）、数据操作语言 (DML)在Core Data中的另一种存在吧！</p>

<p>下面该看看AppDelegate.m，了解下“三剑客”实例化的过程：
首先是程序加载完毕的代理方法：</p>

<p>```
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>// Override point for customization after application launch.
UINavigationController *navigationController = (UINavigationController *)self.window.rootViewController;
MasterViewController *controller = (MasterViewController *)navigationController.topViewController;
controller.managedObjectContext = self.managedObjectContext;
return YES;
</code></pre>

<p>}
<code>``
我们暂且只看</code>controller.managedObjectContext = self.managedObjectContext;<code>这句，调用</code>managedObjectContext<code>的getter方法并赋给程序启动后出现的</code>MasterViewController<code>，那么我们就看一下</code>managedObjectContext`的getter方法：</p>

<p>```
// Returns the managed object context for the application.
// If the context doesn&rsquo;t already exist, it is created and bound to the persistent store coordinator for the application.
&ndash; (NSManagedObjectContext *)managedObjectContext
{</p>

<pre><code>if (_managedObjectContext != nil) {
    return _managedObjectContext;
}

NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];
if (coordinator != nil) {
    _managedObjectContext = [[NSManagedObjectContext alloc] init];
    [_managedObjectContext setPersistentStoreCoordinator:coordinator];
}
return _managedObjectContext;
</code></pre>

<p>}
```</p>

<p>嗯，英文注释不错，第一次调用的时候会实例化一个<code>NSManagedObjectContext</code>对象，并使用<code>persistentStoreCoordinator</code>方法返回的<code>NSPersistentStoreCoordinator</code>对象配置上下文，最后返回新实例化的<code>NSManagedObjectContext</code>对象。<br/>
顺藤摸瓜，我们再看看<code>persistentStoreCoordinator</code>的getter：</p>

<p>```
// Returns the persistent store coordinator for the application.
// If the coordinator doesn&rsquo;t already exist, it is created and the application&rsquo;s store added to it.
&ndash; (NSPersistentStoreCoordinator *)persistentStoreCoordinator
{</p>

<pre><code>if (_persistentStoreCoordinator != nil) {
    return _persistentStoreCoordinator;
}

NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@"MyCDDemo.sqlite"];

NSError *error = nil;
_persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];
if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&amp;error]) {
    /*
     Replace this implementation with code to handle the error appropriately.

     abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 

     Typical reasons for an error here include:
     * The persistent store is not accessible;
     * The schema for the persistent store is incompatible with current managed object model.
     Check the error message to determine what the actual problem was.


     If the persistent store is not accessible, there is typically something wrong with the file path. Often, a file URL is pointing into the application's resources directory instead of a writeable directory.

     If you encounter schema incompatibility errors during development, you can reduce their frequency by:
     * Simply deleting the existing store:
     [[NSFileManager defaultManager] removeItemAtURL:storeURL error:nil]

     * Performing automatic lightweight migration by passing the following dictionary as the options parameter:
     @{NSMigratePersistentStoresAutomaticallyOption:@YES, NSInferMappingModelAutomaticallyOption:@YES}

     Lightweight migration will only work for a limited set of schema changes; consult "Core Data Model Versioning and Data Migration Programming Guide" for details.

     */
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}    

return _persistentStoreCoordinator;
</code></pre>

<p>}
<code>``
为了访问documents目录中的SQLite存储文件MyCDDemo.sqlite，还定义了一个</code>applicationDocumentsDirectory`方法，它的作用是获取程序documents的路径，代码如下：</p>

<p>```
// Returns the URL to the application&rsquo;s Documents directory.
&ndash; (NSURL *)applicationDocumentsDirectory
{</p>

<pre><code>return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];
</code></pre>

<p>}
<code>``
MyCDDemo.sqlite文件是在编译MyCDDemo.xcdatamodeld时生成的，同样生成的还有MyCDDemo.momd文件，后面会提到。
</code>NSPersistentStoreCoordinator<code>初始化时需要传入</code>managedObjectModel<code>。</code>NSPersistentStoreCoordinator<code>对象在添加持久存储的时候不仅需要传入存储类型，还有配置，存储文件URL，选项以及错误类型。我们使用sqlite作为存储类型，配置为nil，还记得之前叫做default的配置么？这里我们只有一个持久存储，所以配置一项不需要。如果添加存储的时候出现错误，就会进入if判断，具体处理错误的细节可以看看模版生成的注释。  
既然</code>NSPersistentStoreCoordinator<code>又用到了</code>managedObjectModel<code>，我们再看看</code>managedObjectModel`方法吧：</p>

<p>```
// Returns the managed object model for the application.
// If the model doesn&rsquo;t already exist, it is created from the application&rsquo;s model.
&ndash; (NSManagedObjectModel *)managedObjectModel
{</p>

<pre><code>if (_managedObjectModel != nil) {
    return _managedObjectModel;
}
NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@"MyCDDemo" withExtension:@"momd"];
_managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
return _managedObjectModel;
</code></pre>

<p>}
<code>``
依然是跟之前一样的代码风格，这次</code>NSManagedObjectModel`类在初始化的时候用到了MyCDDemo.momd文件，前面提到过，当你编译项目时，MyCDDemo.xcdatamodeld数据模型将被编译成MyCDDemo.momd资源，并且保存到app的Bundle目录。</p>

<p>最后，在程序退出时，会调用代理<code>applicationWillTerminate:</code></p>

<p>```
&ndash; (void)applicationWillTerminate:(UIApplication *)application
{</p>

<pre><code>// Saves changes in the application's managed object context before the application terminates.
[self saveContext];
</code></pre>

<p>}
<code>``
它调用了</code>saveContext`方法：</p>

<p>```
&ndash; (void)saveContext
{</p>

<pre><code>NSError *error = nil;
NSManagedObjectContext *managedObjectContext = self.managedObjectContext;
if (managedObjectContext != nil) {
    if ([managedObjectContext hasChanges] &amp;&amp; ![managedObjectContext save:&amp;error]) {
         // Replace this implementation with code to handle the error appropriately.
         // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
        NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
        abort();
    } 
}
</code></pre>

<p>}
<code>``
</code>managedObjectContext<code>对象中的数据无论怎么修改，都是发生在内存中的，需要调用</code>save`方法来保存到存储文件当中。</p>

<p>按理说接下来应该看看<code>MasterViewController中</code>被传入的<code>managedObjectContext</code>对象是如何使用的，但在这之前，我们先运行下程序，看看这个App有什么功能：</p>

<p><img src="/images/blog/QQ20140501-4@2x.png" alt="" /></p>

<p>再普通不过的tableview了，点击加号便可添加一条记录，内容为时间戳，回想起之前看的名称为Event的Entity，是不是想起了什么，嘿嘿。再添加了四条记录后，不妨打开sqlite文件查看下，路径为<code>~/Library/Application Support/iPhone Simulator/[OS version]/Applications/[appGUID]/Documents/</code>，目录内包含了三个文件MyCDDemo.sqlite、MyCDDemo.sqlite-shm、MyCDDemo.sqlite-wal。如上文所述，根据AppDelegate.m文件中的<code>persistentStoreCoordinator</code>方法可知，时间戳记录被存储在MyCDDemo.sqlite文件中。我用Navicat Premium将其打开：</p>

<p><img src="/images/blog/QQ20140501-5@2x.png" alt="" /></p>

<p><img src="/images/blog/QQ20140501-6@2x.png" alt="" /></p>

<p>相信你对“三剑客”有了更深的理解，再附上一张图加深下印象：</p>

<p><img src="/images/blog/coredata1.png" alt="" /></p>

<p>一个<code>NSManagedObjectModel</code>对象处在<code>NSPersistentStoreCoordinator</code>对象和<code>NSManagedObjectContext</code>对象之间。Core Data根据<code>NSManagedObjectModel</code>对象确定如何将底层的持久化文件中的数据映射为<code>NSManagedObject</code>对象。一个<code>NSManagedObjectModel</code>对象用于表示数据的结构。<code>NSManagedObjectModel</code>对象也被称为对象图(object graph)。你可以简单的理解为：<strong>在数据库sqlite文件中，一张表中的一条数据（table row）就相当于代码中的一个NSManagedObject对象，他们之间的映射是通过<code>NSManagedObjectModel</code>对象完成的</strong></p>

<p>下面让我们进入到<code>MasterViewController</code>中来认识一下这个新出现的<code>NSManagedObject</code>“小弟”</p>

<p>既然数据库中的数据最终显示在了<code>UITableView</code>上，我们撇开<code>MasterViewController</code>中其他的方法，直奔<code>UITableViewDataSource</code>协议中已经实现的那几个方法：</p>

<p>```
&ndash; (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{</p>

<pre><code>return [[self.fetchedResultsController sections] count];
</code></pre>

<p>}</p>

<ul>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
  id <NSFetchedResultsSectionInfo> sectionInfo = [self.fetchedResultsController sections][section];
  return [sectionInfo numberOfObjects];
}</p></li>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
  UITableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:@&ldquo;Cell&rdquo; forIndexPath:indexPath];
  [self configureCell:cell atIndexPath:indexPath];
  return cell;
}</p></li>
<li><p>(BOOL)tableView:(UITableView <em>)tableView canEditRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  // Return NO if you do not want the specified item to be editable.
  return YES;
}</p></li>
<li><p>(void)tableView:(UITableView <em>)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  if (editingStyle == UITableViewCellEditingStyleDelete) {
      NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
      [context deleteObject:[self.fetchedResultsController objectAtIndexPath:indexPath]];</p>

<pre><code>  NSError *error = nil;
  if (![context save:&amp;error]) {
       // Replace this implementation with code to handle the error appropriately.
       // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
      NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
      abort();
  }
</code></pre>

<p>  } <br/>
}</p></li>
<li><p>(BOOL)tableView:(UITableView <em>)tableView canMoveRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  // The table view should not be re-orderable.
  return NO;
}
```</p></li>
</ul>


<p>如果你对<code>UITableView</code>的使用很有经验，一眼就可看出数据是由<code>fetchedResultsController</code>对象提供的。即使在<code>tableView: cellForRowAtIndexPath:</code>方法中没出现<code>fetchedResultsController</code>，但是在其调用的<code>configureCell: atIndexPath:</code>方法中依然用到了<code>fetchedResultsController</code>：</p>

<p>```
&ndash; (void)configureCell:(UITableViewCell <em>)cell atIndexPath:(NSIndexPath </em>)indexPath
{</p>

<pre><code>NSManagedObject *object = [self.fetchedResultsController objectAtIndexPath:indexPath];
cell.textLabel.text = [[object valueForKey:@"timeStamp"] description];
</code></pre>

<p>}
```
嗯看来NSManagedObject对象全都由这个fetchedResultsController提供咯，下面揭开它神秘的面纱：</p>

<p>```
&ndash; (NSFetchedResultsController *)fetchedResultsController
{</p>

<pre><code>if (_fetchedResultsController != nil) {
    return _fetchedResultsController;
}

NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
// Edit the entity name as appropriate.
NSEntityDescription *entity = [NSEntityDescription entityForName:@"Event" inManagedObjectContext:self.managedObjectContext];
[fetchRequest setEntity:entity];

// Set the batch size to a suitable number.
[fetchRequest setFetchBatchSize:20];

// Edit the sort key as appropriate.
NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"timeStamp" ascending:NO];
NSArray *sortDescriptors = @[sortDescriptor];

[fetchRequest setSortDescriptors:sortDescriptors];

// Edit the section name key path and cache name if appropriate.
// nil for section name key path means "no sections".
NSFetchedResultsController *aFetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedObjectContext sectionNameKeyPath:nil cacheName:@"Master"];
aFetchedResultsController.delegate = self;
self.fetchedResultsController = aFetchedResultsController;

NSError *error = nil;
if (![self.fetchedResultsController performFetch:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}

return _fetchedResultsController;
</code></pre>

<p>}
```</p>

<p>嗯，之前提到过，Core Data在iOS平台使用了<code>NSFetchedResultsController</code>对象来简化对提取结果和表格视图的处理。<code>NSFetchedResultsController</code>对象被惰性创建并只在表格视图数据源方法有需要时才提取数据。你会看到在<code>NSFetchRequest</code>对象的配置中，使用了Event实体，并提供了一个<code>NSSortDescriptor</code>对象以让提取结果按timeStamp进行排序。最后通过<code>NSFetchRequest</code>对象和<code>managedObjectContext</code>（在AppDelegate中传入的<code>NSManagedObjectContext</code>实例）作为参数传入<code>NSFetchedResultsController</code>的初始化方法。（<code>sectionNameKeyPath</code>参数传入nil时表示只有一个section，你会发现<code>NSFetchedResultsController</code>从数据库获取的结果跟<code>UITableView</code>需要的数据格式相同，都通过<code>NSIndexPath</code>地址来获取一条数据的内容）<br/>
<code>NSFetchedResultsController</code>也有它的代理，将<code>MasterViewController</code>设置为其代理，这样在fetched results 发生变化时，<code>MasterViewController</code>中实现的<code>NSFetchedResultsControllerDelegate</code>方法会被调用：</p>

<p>```
&ndash; (void)controllerWillChangeContent:(NSFetchedResultsController *)controller
{</p>

<pre><code>[self.tableView beginUpdates];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)controller:(NSFetchedResultsController *)controller didChangeSection:(id <NSFetchedResultsSectionInfo>)sectionInfo
         atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type
{
  switch(type) {
      case NSFetchedResultsChangeInsert:
          [self.tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade];
          break;</p>

<pre><code>  case NSFetchedResultsChangeDelete:
      [self.tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade];
      break;
</code></pre>

<p>  }
}</p></li>
<li><p>(void)controller:(NSFetchedResultsController <em>)controller didChangeObject:(id)anObject
     atIndexPath:(NSIndexPath </em>)indexPath forChangeType:(NSFetchedResultsChangeType)type
    newIndexPath:(NSIndexPath <em>)newIndexPath
{
  UITableView </em>tableView = self.tableView;</p>

<p>  switch(type) {
      case NSFetchedResultsChangeInsert:
          [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
          break;</p>

<pre><code>  case NSFetchedResultsChangeDelete:
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      break;

  case NSFetchedResultsChangeUpdate:
      [self configureCell:[tableView cellForRowAtIndexPath:indexPath] atIndexPath:indexPath];
      break;

  case NSFetchedResultsChangeMove:
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
      break;
</code></pre>

<p>  }
}</p></li>
<li><p>(void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
  [self.tableView endUpdates];
}</p></li>
</ul>


<p>/*
// Implementing the above methods to update the table view in response to individual changes may have performance implications if a large number of changes are made simultaneously. If this proves to be an issue, you can instead just implement controllerDidChangeContent: which notifies the delegate that all section and object changes have been processed.</p>

<ul>
<li>(void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
 // In the simplest, most efficient, case, reload the table view.
 [self.tableView reloadData];
}</li>
</ul>


<p>```</p>

<p>相对于之前<code>UITableViewDataSource</code>协议方法对<code>NSFetchedResultsController</code>对象中数据的修改（通过<code>NSManagedObject</code>对象做载体），<code>NSFetchedResultsControllerDelegate</code>协议方法会在察觉到数据修改后被调用，用于产生tableview操作数据后对应的动画效果。</p>

<p>可能你会觉得有些混乱，这里贴上几张图梳理下各个类的关系和结构：</p>

<p><img src="/images/blog/coredata_doc_management_2x.png" alt="" /></p>

<p><img src="/images/blog/fetch_request_2x.png" alt="" /></p>

<p><img src="/images/blog/advanced_persistence_stack_2x.png" alt="" /></p>

<p><img src="/images/blog/managed_object_model_2x.png" alt="" /></p>

<p><img src="/images/blog/entity_description_2x.png" alt="" /></p>

<p>最后，找到<code>insertNewObject</code>方法，当用户尝试加入一个对象到表视图时，该方法将被调用。接着你将看到如下的处理过程：</p>

<ul>
<li>获得一个<code>NSManagedObjectContext</code>对象；</li>
<li>决定创建新对象的实体；</li>
<li>根据实体名称创建一个新的<code>NSManagedObject</code>对象并将其插入到<code>NSManagedObjectContext</code>对象；</li>
<li>对新创建的<code>NSManagedObject</code>对象设置timeStamp属性值</li>
<li><code>NSManagedObjectContext</code>对象执行保存。</li>
</ul>


<p>当上下文执行保存，新的对象将被写到持久存储区中。这是如此简单！</p>

<p>DetailViewController的内容比较简单，不在叙述，到此结束，新建Core Data的模版工程代码已经解析完毕了。在下一期文章中将会亲手修改代码，探索Core Data更多的使用技巧。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C交叉引用解决方法]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/24/objective-cjiao-cha-yin-yong-jie-jue-fang-fa/"/>
    <updated>2014-04-24T20:25:00+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/24/objective-cjiao-cha-yin-yong-jie-jue-fang-fa</id>
    <content type="html"><![CDATA[<p>如果类A的头文件import了B，类B的头文件import了A，这样在编译时有可能产生一种错误：“can not find interface declaration”，这是因为Objective-C不允许交叉引用</p>

<!--more-->


<p>#import是GCC编译器提供的，XCode在编译Objective－C、C和C++程序时都会使用它。#import可保证头文件只被包含一次，而不论此命令实际上在那个文件中出现了多少次。<br/>
在C语言中，程序员通常使用基于#ifdef命令的方案来避免一个文件包含另一个文件，而后者又包含第一个文件的情况。<br/>
@class创建了一个向前引用。就是在告诉编译器：“相信我，以后你会知道这个类到底是什么。但是现在，你只需要知道这些。”<br/>
如果有循环依赖关系，@class也很有用。即A类使用B类，B类也使用A类。如果试图通过#import语句让这两个类互相引用，那么最后就会出现编译错误。但是如果在A.h中使用@class B，在B.h中使用@class A，那么这两个类就可以互相引用了。<br/>
<strong>所以最佳的解决方案是在头文件中使用@class，在.m文件中使用#import</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Double Dispatch模式及其在iOS开发中实践]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/13/double-dispatchmo-shi-ji-qi-zai-ioskai-fa-zhong-shi-zhan/"/>
    <updated>2014-04-13T15:51:03+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/13/double-dispatchmo-shi-ji-qi-zai-ioskai-fa-zhong-shi-zhan</id>
    <content type="html"><![CDATA[<h2>引子</h2>

<p>在一个太空大战游戏中，导弹可以撞向飞船，也可能撞向行星，所以在碰撞检测的时候就需要判断碰撞的结果。假设游戏有四种物体：飞船，陨石，行星，导弹，那么就产生了<code>4*3/2+4</code>种情形（一枚导弹撞上另一枚导弹）。这种排列组合计算出的结果会随着物体种类N的增多爆炸性增长，如果这个时候还用一堆if－else来检测碰撞，那真是<code>Naive</code>了。这时我们可以利用面向对象语言的多态性质来在程序运行时动态绑定，因为碰撞检测是一种“双向选择”，所以我们需要<code>double dispatch</code>（双分派），<code>Visitor</code>模式就是<code>double dispatch</code>的一种应用。<br/>
<img src="/images/blog/doubledispatch.jpg" alt="Visitor模式" /></p>

<p>DD模式适合于处理多个对象之间的相互作用。假如不用DD模式的话，那么每个对象跟别的对象发生关系时，就必须辛辛苦苦的进行if&hellip;else&hellip;枚举，因为它并不知道对方是何神圣。DD模式的引入解决了这个问题，其实说白了就是利用语言内置的虚函数机制来替你干活，把工作移交给编译器去做了。</p>

<h2>本文内容</h2>

<ul>
<li>C++中的Double Dispatch实例</li>
<li>Java中的Double Dispatch实例</li>
<li>Objective-C中实现碰撞检测用到的Visitor模式</li>
</ul>


<!-- more-->


<h2>C++中的Double Dispatch实例</h2>

<p>本节内容摘自<a href="http://www.cnblogs.com/west-link/archive/2011/07/26/2116887.html">这里</a><br/>
我们先从字面上去理解它吧，直观地说，它指的是两次dispatch。这里的dispatch指的是什么呢？举个例子：</p>

<p>``` cpp
class Event
   {</p>

<pre><code>   public:
       virtual void PrintName()
       {
            cout&lt;&lt;"我是通用事件"&lt;&lt;endl;           
       }
</code></pre>

<p>   }</p>

<p>   class KeyEvent:public Event
   {</p>

<pre><code>  public:
       virtual void PrintName()
       {
            cout&lt;&lt;"我是按键事件"&lt;&lt;endl;           
       }
</code></pre>

<p>   }</p>

<p>   class ClickEvent:public Event
   {</p>

<pre><code>   public:
       virtual void PrintName()
       {
            cout&lt;&lt;"我是单击事件"&lt;&lt;endl;           
       }
</code></pre>

<p>   }
```</p>

<p>多态性是动态的，被调用的方法由对象的真正类型确定，这个过程就被称之为dispatch。例如在C++中，每个对象都有一个虚函数表，当用基类的类型引用子类对象时，虚函数指针指向的是子类的虚函数表，调用的虚函数都是子类中的版本，所以下面代码输出的是：“我是按键事件”，这就算是一次dispatch的过程，即根据对象类型来动态确定调用哪个函数的过程。</p>

<p><code>
Event* pEvent = new KeyEvent();
pEvent-&gt;PrintName();
</code></p>

<p>什么时候会用到两次dispatch呢? 继续往下看：</p>

<p>```
class EventRecorder
   {</p>

<pre><code>   public:
       virtual void RecordEvent(Event* event)
       {
           cout&lt;&lt;"使用EventRecorder记录通用事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(KeyEvent* event)
       {
           cout&lt;&lt;"使用EventRecorder记录按键事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(ClickEvent* event)
       {
           cout&lt;&lt;"使用EventRecorder记录单击事件"&lt;&lt; endl;           
       }
</code></pre>

<p>   }</p>

<p>   class AdvanceEventRecorder:public EventRecorder
   {</p>

<pre><code>   public:
       virtual void RecordEvent(Event* event)
       {
           cout&lt;&lt;"使用高级EventRecorder记录通用事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(KeyEvent* event)
       {
           cout&lt;&lt;"使用高级EventRecorder记录按键事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(ClickEvent* event)
       {
           cout&lt;&lt;"使用高级EventRecorder记录单击事件"&lt;&lt; endl;           
       }
</code></pre>

<p>   }
```</p>

<p>这两个类中分别包含三个重载函数，多态是动态的，而函数重载则是静态的，它在编译时期就确定下来了，所以，下面代码片段的运行结果并不是我们所期望的:</p>

<p>```</p>

<pre><code>EventRecorder* pRecorder = new AdvanceEventRecorder();
Event* pEvent = new KeyEvent();
pRecorder-&gt;RecordEvent(pEvent);
</code></pre>

<p>```
输出内容为：使用高级EventRecorder记录通用事件<br/>
实际上，在这个场景中，我们期望调用的是：AdvanceEventRecorder::RecordEvent(KeyEvent* event)<br/>
下面我们使用Double Dispatch设计模式来达到上面的代码片段的目的，在所有Event对象中增加下面的函数：</p>

<p>```
   virtual void RecordEvent(EventRecorder* recorder)
   {</p>

<pre><code>  recorder-&gt;RecordEvent(this);
</code></pre>

<p>   }
```
下面的代码片段将输出：使用高级EventRecorder记录按键事件</p>

<p>```</p>

<pre><code>EventRecorder* pRecorder = new AdvanceEventRecorder();
Event* pEvent = new KeyEvent();
pEvent-&gt;RecordEvent(pRecorder);
</code></pre>

<p><code>``
可以看出，第一次dispatch正确地找到了</code>KeyEvent<code>的</code>RecordEvent(EventRecorder<em> recorder)<code>，第二次dispatch找到了</code>AdvanceEventRecorder<code>的</code>RecordEvent(KeyEvent</em> event)`。
   Visitor模式就是对Double Dispatch的应用，另外，在碰撞检测算法中也会经常用到。</p>

<h2>Java中的Double Dispatch实例</h2>

<p>本节参考自<a href="http://www.blogjava.net/chaocai/archive/2009/02/19/255640.html">这里</a>
相对于C++中使用继承来说，Java提供的接口和函数重载让Double Dispatch模式更容易实现</p>

<h3>1 根据对象来选择行为问题</h3>

<p><code>java
public interface Event {
}
public class BlueEvent implements Event {
}
public class RedEvent implements Event {
}
public class Handler {
public void handle(Event event){
System.out.println("It is event");
}
public void handle(RedEvent event){
System.out.println("It is RedEvent");
}
public void handle(BlueEvent event){
System.out.println("It is BlueEvent");
}
}
public class Main {
public static void main(String[] args) {
Event evt=new BlueEvent();
new Handler().handle(evt);
}
}
</code></p>

<p>你认为运行结果是什么呢？<br/>
结果：It is event<br/>
是不是有点出乎意料，不是It is BlueEvent，<strong>这是因为Overload并不支持在运行时根据参数的运行时类型来绑定方法</strong>，所以要执行哪个方法是在编译时就选定了的。</p>

<h3>2 Double Dispatch Pattern</h3>

<p>由于Java,C++及C#都具有上述局限，通常我们只能通过Switch或if结构来实现，当然这种实现方式既不优雅而且影响代码的可维护性。<br/>
通过以下的Double Dispatch Pattern便可以优雅的实现。</p>

<p><code>
public interface Event {
public void injectHandler(EventHandler v);
}
public class BlueEvent implements Event {
public void injectHandler(EventHandler v) {
v.handle(this);
}
}
public class RedEvent implements Event {
public void injectHandler(EventHandler v) {
v.handle(this);
}
}
public class EventHandler {
public void handle(BlueEvent e){
System.out.println("It is BlueEvent");
}
public void handle(RedEvent e){
System.out.println("It is RedEvent");
}
}
public class Main {
public static void main(String[] args) {
Event evt=new BlueEvent();
evt.injectHandler(new EventHandler());
}
}
</code></p>

<h2>Objective-C中实现碰撞检测用到的Visitor模式</h2>

<p>虽然OC不支持函数重载，但是其独有的SEL类型可以很好的解决这个问题<br/>
感谢kouky提供的iOS上碰撞检测的<a href="https://github.com/kouky/iOS-SpriteKit-Pong">Demo</a>，这里他用到了Visitor模式<br/>
由于判断物体类型是用一个32位掩码来标记，所以这里不可避免的要用到if语句，这不代表它不是动态绑定，因为if语句是在初始化方法<code>+ (id)contactVisitorWithBody:(SKPhysicsBody *)body forContact:(SKPhysicsContact *)contact</code>中其作用的，只是为了判断物体类型，而不是判断碰撞两者的组合类型<br/>
可以参考我写的例子<a href="https://github.com/yulingtianxia/MyFirstGame/tree/master/ColorAtom">ColorAtom</a></p>

<p>首先新建一个访问者基本类<code>ContactVisitor</code>，其本质为对SKPhysicsBody和SKPhysicsContact对象的封装，而SKPhysicsContact在本例中虽未用到（因为碰撞检测后啥也没干，只输出了碰撞双方name），但其保存着碰撞坐标等信息，也很重要。两次dispatch都是在访问者基本类实现的，而碰撞后具体操作则卸载了访问者具体类（如AtomNodeContactVisitor）</p>

<p>``` objc</p>

<p>//  ContactVisitor.h
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;SpriteKit/SpriteKit.h></h1>

<p>@interface ContactVisitor : NSObject</p>

<p>@property (nonatomic,readonly, strong) SKPhysicsBody <em>body;
@property (nonatomic, readonly, strong) SKPhysicsContact </em>contact;</p>

<ul>
<li>(id)contactVisitorWithBody:(SKPhysicsBody <em>)body forContact:(SKPhysicsContact </em>)contact;</li>
<li>(void)visit:(SKPhysicsBody *)body;</li>
</ul>


<p>@end
```</p>

<p>属性body即为访问者的SKPhysicsBody，而方法<code>visit:</code>的参数为被访问者的SKPhysicsBody<br/>
<code>contactVisitorWithBody:forContact:</code>方法的作用是根据掩码类型初始化对应类型的访问者具体类</p>

<p>```
//
//  ContactVisitor.m
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;ContactVisitor.h&rdquo;</h1>

<h1>import &lt;objc/runtime.h></h1>

<h1>import &ldquo;NodeCategories.h&rdquo;</h1>

<h1>import &ldquo;AtomNodeContactVisitor.h&rdquo;</h1>

<h1>import &ldquo;PlayFieldSceneContactVisitor.h&rdquo;</h1>

<p>@implementation ContactVisitor
+ (id)contactVisitorWithBody:(SKPhysicsBody <em>)body forContact:(SKPhysicsContact </em>)contact
{</p>

<pre><code>//第一次dispatch，通过node类别返回对应的实例
if ((body.categoryBitMask&amp;AtomCategory)!=0) {
    return [[AtomNodeContactVisitor alloc] initWithBody:body forContact:contact];
}
if ((body.categoryBitMask&amp;PlayFieldCategory)!=0) {
    return [[PlayFieldSceneContactVisitor alloc] initWithBody:body forContact:contact];
}
else{
    return nil;
}
</code></pre>

<p>}</p>

<ul>
<li><p>(id)initWithBody:(SKPhysicsBody <em>)body forContact:(SKPhysicsContact </em>)contact
{
  self = [super init];
  if (self) {
      <em>contact = contact;
      </em>body = body;
  }
  return self;
}</p></li>
<li><p>(void)visit:(SKPhysicsBody <em>)body
{
  //第二次dispatch，通过构造方法名来执行对应方法
  // 生成node的名字，比如"AtomNode"
  NSString </em>bodyClassName = [NSString stringWithUTF8String:class_getName(body.node.class)];</p>

<p>  // 生成方法名，比如"visitAtomBody"
  NSMutableString *contactSelectorString = [NSMutableString stringWithFormat:@&ldquo;visit&rdquo;];
  [contactSelectorString appendString:bodyClassName];
  [contactSelectorString appendString:@&ldquo;:&rdquo;];</p>

<p>  SEL selector = NSSelectorFromString(contactSelectorString);
  //判断是否存在此方法
  if ([self respondsToSelector:selector]) {
      [self performSelector:selector withObject:body];
  }</p></li>
</ul>


<p>}</p>

<p>```</p>

<p>以访问者具体类以<code>AtomNodeContactVisitor</code>类为例，它继承自访问者基本类ContactVisitor</p>

<p>```</p>

<p>//
//  AtomNodeContactVisitor.h
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;ContactVisitor.h&rdquo;</h1>

<p>@interface AtomNodeContactVisitor : ContactVisitor</p>

<p>/<em>Atom访问了Atom，同类碰撞</em>/
&ndash;(void) visitAtomNode:(SKPhysicsBody<em>) anotherAtomBody;
/</em>Atom访问了边界，也就是球撞墙上了<em>/
&ndash;(void) visitPlayFieldScene:(SKPhysicsBody</em>) playfieldBody;
@end</p>

<p>```</p>

<p>在处理碰撞后的visitXXX方法中，我将碰撞双方的访问者和被访问者的关系输出</p>

<p>```
//
//  AtomNodeContactVisitor.m
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;AtomNodeContactVisitor.h&rdquo;</h1>

<h1>import &ldquo;AtomNode.h&rdquo;</h1>

<h1>import &ldquo;PlayFieldScene.h&rdquo;</h1>

<p>@implementation AtomNodeContactVisitor
&ndash;(void) visitAtomNode:(SKPhysicsBody*) anotherAtomBody
{</p>

<pre><code>AtomNode *thisAtom = (AtomNode*)self.body.node;
AtomNode *anotherAtom = (AtomNode*)anotherAtomBody.node;
//处理碰撞后的结果
NSLog(@"%@-&gt;%@",thisAtom.name,anotherAtom.name);
</code></pre>

<p>}
&ndash;(void) visitPlayFieldScene:(SKPhysicsBody*) playfieldBody
{</p>

<pre><code>AtomNode *atom = (AtomNode*)self.body.node;
PlayFieldScene *playfield = (PlayFieldScene*) playfieldBody.node;
NSLog(@"%@-&gt;%@",atom.name,playfield.name);
</code></pre>

<p>}
@end
```
下面建立被访问者类，其本质就是对SKPhysicsBody的封装，并接受Visitor的注入</p>

<p>```
//
//  VisitablePhysicsBody.h
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;ContactVisitor.h&rdquo;</h1>

<p>@interface VisitablePhysicsBody : NSObject
@property (nonatomic, readonly, strong) SKPhysicsBody *body;</p>

<ul>
<li>(id) initWithBody:(SKPhysicsBody *)body;</li>
<li>(void) acceptVisitor:(ContactVisitor *)visitor;</li>
</ul>


<p>@end
```</p>

<p>关键的一步：在<code>acceptVisitor:</code>方法中调用访问者的<code>visit:</code>方法</p>

<p>```
//
//  VisitablePhysicsBody.m
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;VisitablePhysicsBody.h&rdquo;</h1>

<p>@implementation VisitablePhysicsBody
&ndash; (id)initWithBody:(SKPhysicsBody *)body
{</p>

<pre><code>self = [super init];
if (self) {
    _body = body;
}
return self;
</code></pre>

<p>}</p>

<ul>
<li>(void)acceptVisitor:(ContactVisitor *)visitor
{
  [visitor visit:self.body];
}</li>
</ul>


<p>@end</p>

<p>```</p>

<p>可能有人会有疑问，<code>visit:</code>方法穿入的参数类型永远是<code>SKPhysicsBody</code>，这哪里是动态绑定啊，其实是由于本例的特殊性，碰撞检测时区分物体类型不是靠<code>SKPhysicsBody</code>子类化来区分和绑定，而是靠SKPhysicsBody类中的<code>categoryBitMask</code>属性来区分，这也就免不了需要在<code>ContactVisitor</code>初始化的时候通过if语句来判断具体初始化哪个子类<br/>
最后，在Scene实现SKPhysicsContactDelegate协议</p>

<p>```</p>

<h1>pragma mark SKPhysicsContactDelegate</h1>

<p>&ndash;(void)didBeginContact:(SKPhysicsContact *)contact
{</p>

<pre><code>//A-&gt;B
ContactVisitor *visitorA = [ContactVisitor contactVisitorWithBody:contact.bodyA forContact:contact];
VisitablePhysicsBody *visitableBodyB = [[VisitablePhysicsBody alloc] initWithBody:contact.bodyB];
[visitableBodyB acceptVisitor:visitorA];
//B-&gt;A
ContactVisitor *visitorB = [ContactVisitor contactVisitorWithBody:contact.bodyB forContact:contact];
VisitablePhysicsBody *visitableBodyA = [[VisitablePhysicsBody alloc] initWithBody:contact.bodyA];
[visitableBodyA acceptVisitor:visitorB];
</code></pre>

<p>}
```
物理老师总说力的作用时相互的，所以我们需要两次访问：A访问B和B访问A，但是这样会调用两次visitXXX方法，原则上这两个逻辑上对称的方法我们只需要实现其中一个就可以，但必须得像上面代码一样，A->B和B->A缺一不可，因为碰撞的时候我们不知道bodyA和bodyB的类型，也就无法判断visitXXX方法是A->B时能调用还是B->A时能调用到<br/>
当然，你也可以两个visit方法都实现，但只对visitor的node做操作，或只对visitable的node操作，总之仁者见仁智者见智啦</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XCode和Objective-C Cheat Sheet]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/06/xcodehe-objective-c-cheat-sheet/"/>
    <updated>2014-04-06T18:38:24+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/06/xcodehe-objective-c-cheat-sheet</id>
    <content type="html"><![CDATA[<p>关于XCode和OC的速查，方便记忆，以后会更新</p>

<!-- more-->


<p>XCode5 Cheat Sheet:(<a href="http://www.git-tower.com/blog/xcode-cheat-sheet/">作者</a>)<br/>
<img src="/images/blog/xcode-cheat-sheet<em>页面</em>1.jpg"> <br/>
<img src="/images/blog/xcode-cheat-sheet<em>页面</em>2.jpg">
Objective-C Cheat Sheet and Quick Reference Updated for Xcode 5:(<a href="http://www.raywenderlich.com/54099/objective-c-cheat-sheet-and-quick-reference-updated-for-xcode-5">作者</a>) <br/>
<img src="/images/blog/RW-Objective-C-Cheatsheet-v-1-5.jpg"></p>
]]></content>
  </entry>
  
</feed>
