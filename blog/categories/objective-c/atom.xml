<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-08-09T15:10:04+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[NSPredicate]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/17/nspredicate/"/>
    <updated>2014-05-17T20:42:11+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/17/nspredicate</id>
    <content type="html"><![CDATA[<p>本文转载自<a href="http://nshipster.cn/nspredicate/">http://nshipster.cn/nspredicate/</a></p>

<p>NSPredicate是一个Foundation类，它指定数据被获取或者过滤的方式。它的查询语言就像SQL的WHERE和正则表达式的交叉一样，提供了具有表现力的，自然语言界面来定义一个集合被搜寻的逻辑条件。</p>

<!--more-->


<p>相比较抽象的谈论它，展示NSPredicate的使用方法更加容易，所以我们来重新审视<a href="http://nshipster.com/nssortdescriptor/">NSSortDescriptor</a>中使用的示例数据集吧：</p>

<table>
<thead>
<tr>
<th>索引 </th>
<th> 0 </th>
<th> 1 </th>
<th> 2 </th>
<th> 3 </th>
</tr>
</thead>
<tbody>
<tr>
<td>名 </td>
<td> Alice </td>
<td> Bob   </td>
<td> Charlie </td>
<td>  Quentin</td>
</tr>
<tr>
<td>姓 </td>
<td> Smith </td>
<td> Jones </td>
<td> Smith </td>
<td> Alberts</td>
</tr>
<tr>
<td>年龄  </td>
<td> 24    </td>
<td> 27    </td>
<td> 33    </td>
<td> 31</td>
</tr>
</tbody>
</table>


<p>``` objc</p>

<p>@interface Person : NSObject
@property NSString <em>firstName;
@property NSString </em>lastName;
@property NSNumber *age;
@end</p>

<p>@implementation Person</p>

<ul>
<li>(NSString *)description {
  return [NSString stringWithFormat:@&ldquo;%@ %@&rdquo;, self.firstName, self.lastName];
}</li>
</ul>


<p>@end</p>

<h1>pragma mark &ndash;</h1>

<p>NSArray <em>firstNames = @[ @&ldquo;Alice&rdquo;, @&ldquo;Bob&rdquo;, @&ldquo;Charlie&rdquo;, @&ldquo;Quentin&rdquo; ];
NSArray </em>lastNames = @[ @&ldquo;Smith&rdquo;, @&ldquo;Jones&rdquo;, @&ldquo;Smith&rdquo;, @&ldquo;Alberts&rdquo; ];
NSArray *ages = @[ @24, @27, @33, @31 ];</p>

<p>NSMutableArray <em>people = [NSMutableArray array];
[firstNames enumerateObjectsUsingBlock:^(id obj, NSUInteger idx, BOOL </em>stop) {</p>

<pre><code>Person *person = [[Person alloc] init];
person.firstName = firstNames[idx];
person.lastName = lastNames[idx];
person.age = ages[idx];
[people addObject:person];
</code></pre>

<p>}];</p>

<p>NSPredicate <em>bobPredicate = [NSPredicate predicateWithFormat:@&ldquo;firstName = &lsquo;Bob&rsquo;&rdquo;];
NSPredicate </em>smithPredicate = [NSPredicate predicateWithFormat:@&ldquo;lastName = %@&rdquo;, @&ldquo;Smith&rdquo;];
NSPredicate *thirtiesPredicate = [NSPredicate predicateWithFormat:@&ldquo;age >= 30&rdquo;];</p>

<p>// [&ldquo;Bob Jones&rdquo;]
NSLog(@&ldquo;Bobs: %@&rdquo;, [people filteredArrayUsingPredicate:bobPredicate]);</p>

<p>// [&ldquo;Alice Smith&rdquo;, &ldquo;Charlie Smith&rdquo;]
NSLog(@&ldquo;Smiths: %@&rdquo;, [people filteredArrayUsingPredicate:smithPredicate]);</p>

<p>// [&ldquo;Charlie Smith&rdquo;, &ldquo;Quentin Alberts&rdquo;]
NSLog(@&ldquo;30&rsquo;s: %@&rdquo;, [people filteredArrayUsingPredicate:thirtiesPredicate]);
```</p>

<h2>集合中使用NSPredicate</h2>

<p>Foundation提供使用谓词（predicate）来过滤NSArray／NSMutableArray&amp;NSSet／NSMutableSet的方法。</p>

<p>不可变的集合，NSArray&amp;NSSet，有可以通过评估接收到的predicate来返回一个不可变集合的方法<code>filteredArrayUsingPredicate:</code>和<code>filteredSetUsingPredicate:</code>。</p>

<p>可变集合，NSMutableArray&amp;NSMutableSet，可以使用方法<code>filterUsingPredicate:</code>，它可以通过运行接收到的谓词来移除评估结果为FALSE的对象。</p>

<p>NSDictionary可以用谓词来过滤它的键和值（两者都为NSArray对象）。NSOrderedSet可以由过滤的NSArray或NSSet生成一个新的有序的集，或者NSMutableSet可以简单的<code>removeObjectsInArray:</code>，来传递通过<em>否定</em>predicate过滤的对象。</p>

<h2>Core Data中使用NSPredicate</h2>

<p>NSFetchRequest有一个predicate属性，它可以指定管理对象应该被获取的逻辑条件。谓词的使用规则在这里同样适用，唯一的区别在于，在管理对象环境中，谓词由持久化存储助理（persistent store coordinator）评估，而不像集合那样在内存中被过滤。</p>

<h2>谓词语法</h2>

<h3>替换</h3>

<ul>
<li>%@是对值为字符串，数字或者日期的对象的替换值。</li>
<li>%K是key path的替换值。</li>
</ul>


<p>```
NSPredicate *ageIs33Predicate = [NSPredicate predicateWithFormat:@&ldquo;%K = %@&rdquo;, @&ldquo;age&rdquo;, @33];</p>

<p>// [&ldquo;Charlie Smith&rdquo;]
NSLog(@&ldquo;Age 33: %@&rdquo;, [people filteredArrayUsingPredicate:ageIs33Predicate]);
<code>``
- $VARIABLE_NAME是可以被</code>NSPredicate -predicateWithSubstitutionVariables:`替换的值。</p>

<p>```
NSPredicate *namesBeginningWithLetterPredicate = [NSPredicate predicateWithFormat:@&ldquo;(firstName BEGINSWITH[cd] $letter) OR (lastName BEGINSWITH[cd] $letter)&rdquo;];</p>

<p>// [&ldquo;Alice Smith&rdquo;, &ldquo;Quentin Alberts&rdquo;]
NSLog(@&ldquo;&lsquo;A&rsquo; Names: %@&rdquo;, [people filteredArrayUsingPredicate:[namesBeginningWithLetterPredicate predicateWithSubstitutionVariables:@{@&ldquo;letter&rdquo;: @&ldquo;A&rdquo;}]]);
```</p>

<h3>基本比较</h3>

<ul>
<li>=, ==：左边的表达式和右边的表达式相等。</li>
<li>>=, =>：左边的表达式大于或者等于右边的表达式。</li>
<li>&lt;=, =&lt;：左边的表达式小于等于右边的表达式。</li>
<li>>：左边的表达式大于右边的表达式。</li>
<li>&lt;：左边的表达式小于右边的表达式。</li>
<li>!=, &lt;>：左边的表达式不等于右边的表达式。</li>
<li>BETWEEN：左边的表达式等于右边的表达式的值或者介于它们之间。右边是一个有两个指定上限和下限的数值的数列（指定顺序的数列）。比如，1 BETWEEN { 0 , 33 }，或者$INPUT BETWEEN { $LOWER, $UPPER }。</li>
</ul>


<h3>基本复合谓词</h3>

<ul>
<li>AND, &amp;&amp;：逻辑与.</li>
<li>OR, ||：逻辑或.</li>
<li>NOT, !：逻辑非.</li>
</ul>


<h3>字符串比较</h3>

<p><em>字符串比较在默认的情况下是区分大小写和音调的。你可以在方括号中用关键字符c和d来修改操作符以相应的指定不区分大小写和变音符号，比如firstname BEGINSWITH[cd] $FIRST_NAME。</em></p>

<ul>
<li>BEGINSWITH：左边的表达式以右边的表达式作为开始。</li>
<li>CONTAINS：左边的表达式包含右边的表达式。</li>
<li>ENDSWITH：左边的表达式以右边的表达式作为结束。</li>
<li>LIKE：左边的表达式等于右边的表达式：?和<em>可作为通配符，其中?匹配1个字符，</em>匹配0个或者多个字符。</li>
<li>MATCHES：左边的表达式根据ICU v3（更多内容请查看<a href="http://userguide.icu-project.org/strings/regexp">ICU User Guide for Regular Expressions</a>）的regex风格比较，等于右边的表达式。</li>
</ul>


<h3>合计操作</h3>

<h4>关系操作</h4>

<ul>
<li>ANY，SOME：指定下列表达式中的任意元素。比如，ANY children.age &lt; 18。</li>
<li>ALL：指定下列表达式中的所有元素。比如，ALL children.age &lt; 18。</li>
<li>NONE：指定下列表达式中没有的元素。比如，NONE children.age &lt; 18。它在逻辑上等于NOT (ANY &hellip;)。</li>
<li>IN：等于SQL的IN操作，左边的表达必须出现在右边指定的集合中。比如，name IN { &lsquo;Ben&rsquo;, &lsquo;Melissa&rsquo;, &lsquo;Nick&rsquo; }。</li>
</ul>


<h4>数组操作</h4>

<ul>
<li>array[index]：指定数组中特定索引处的元素。</li>
<li>array[FIRST]：指定数组中的第一个元素。</li>
<li>array[LAST]：指定数组中的最后一个元素。</li>
<li>array[SIZE]：指定数组的大小。</li>
</ul>


<h3>布尔值谓词</h3>

<ul>
<li>TRUEPREDICATE：结果始终为真的谓词。</li>
<li>FALSEPREDICATE：结果始终为假的谓词。</li>
</ul>


<h2>NSCompoundPredicate</h2>

<p>我们见过与&amp;或被用在谓词格式字符串中以创建复合谓词。然而，我们也可以用NSCompoundPredicate来完成同样的工作。</p>

<p>例如，下列谓词是相等的：</p>

<p>```
[NSCompoundPredicate andPredicateWithSubpredicates:@[[NSPredicate predicateWithFormat:@&ldquo;age > 25&rdquo;], [NSPredicate predicateWithFormat:@&ldquo;firstName = %@&rdquo;, @&ldquo;Quentin&rdquo;]]];</p>

<p>[NSPredicate predicateWithFormat:@&ldquo;(age > 25) AND (firstName = %@)&rdquo;, @&ldquo;Quentin&rdquo;];
```</p>

<p>虽然语法字符串文字更加容易输入，但是在有的时候，你需要结合现有的谓词。在那些情况下，你可以使用<code>NSCompoundPredicate -andPredicateWithSubpredicates:</code>&amp;<code>-orPredicateWithSubpredicates:</code>。</p>

<h2>NSComparisonPredicate</h2>

<p>同样的，如果你在读过<a href="http://nshipster.com/nsexpression/">上周的文章</a>之后发现你使用了太多的NSExpression的话，NSComparisonPredicate可以帮助你解决这个问题。</p>

<p>就像NSCompoundPredicate一样，NSComparisonPredicate从子部件构建了一个NSPredicate－－在这种情况下，左侧和右侧都是NSExpression。 分析它的类的构造函数可以让我们一窥NSPredicate的格式字符串是如何解析的：</p>

<p>```
+ (NSPredicate <em>)predicateWithLeftExpression:(NSExpression </em>)lhs</p>

<pre><code>                         rightExpression:(NSExpression *)rhs
                                modifier:(NSComparisonPredicateModifier)modifier
                                    type:(NSPredicateOperatorType)type
                                 options:(NSUInteger)options
</code></pre>

<p>```</p>

<h4>参数</h4>

<ul>
<li>lhs：左边的表达式。</li>
<li>rhs：右边的表达式。</li>
<li>modifier：应用的修改符。（ANY或者ALL）</li>
<li>type：谓词运算符类型。</li>
<li>options：要应用的选项。没有选项的话则为0。</li>
</ul>


<h3>NSComparisonPredicate类型</h3>

<p><code>
enum {
   NSLessThanPredicateOperatorType = 0,
   NSLessThanOrEqualToPredicateOperatorType,
   NSGreaterThanPredicateOperatorType,
   NSGreaterThanOrEqualToPredicateOperatorType,
   NSEqualToPredicateOperatorType,
   NSNotEqualToPredicateOperatorType,
   NSMatchesPredicateOperatorType,
   NSLikePredicateOperatorType,
   NSBeginsWithPredicateOperatorType,
   NSEndsWithPredicateOperatorType,
   NSInPredicateOperatorType,
   NSCustomSelectorPredicateOperatorType,
   NSContainsPredicateOperatorType,
   NSBetweenPredicateOperatorType
};
typedef NSUInteger NSPredicateOperatorType;
</code></p>

<h3>NSComparisonPredicate选项</h3>

<ul>
<li>NSCaseInsensitivePredicateOption：不区分大小写的谓词。你通过在谓词格式字符串中加入后面带有[c]的字符串操作（比如，"NeXT" like[c] &ldquo;next"）来表达这一选项。</li>
<li>NSDiacriticInsensitivePredicateOption：忽视发音符号的谓词。你通过在谓词格式字符串中加入后面带有[d]的字符串操作（比如，"naïve" like[d] &ldquo;naive"）来表达这一选项。</li>
<li>NSNormalizedPredicateOption：表示待比较的字符串已经被预处理了。这一选项取代了NSCaseInsensitivePredicateOption和NSDiacriticInsensitivePredicateOption，旨在用作性能优化的选项。你可以通过在谓词格式字符串中加入后面带有[n]的字符串（比如，"WXYZlan" matches[n] &ldquo;.lan"）来表达这一选项。</li>
<li>NSLocaleSensitivePredicateOption：表明要使用&lt;，&lt;=，=，=>，> 作为比较的字符串应该使用区域识别的方式处理。你可以通过在&lt;，&lt;=，=，=>，>其中之一的操作符后加入[l]（比如，"straße" >[l] &ldquo;strasse"）以便在谓词格式字符串表达这一选项。</li>
</ul>


<h2>Block谓词</h2>

<p>最后，如果你实在不愿意学习NSPredicate的格式语法，你也可以学学NSPredicate +predicateWithBlock:。</p>

<p>```
NSPredicate <em>shortNamePredicate = [NSPredicate predicateWithBlock:^BOOL(id evaluatedObject, NSDictionary </em>bindings) {</p>

<pre><code>        return [[evaluatedObject firstName] length] &lt;= 5;
    }];
</code></pre>

<p>// [&ldquo;Alice Smith&rdquo;, &ldquo;Bob Jones&rdquo;]
NSLog(@&ldquo;Short Names: %@&rdquo;, [people filteredArrayUsingPredicate:shortNamePredicate]);
<code>``
...好吧，虽然使用</code>predicateWithBlock:`是懒人的做法，但它也并不是一无是处。</p>

<p>事实上，因为block可以封装任意的计算，所以有一个查询类是无法以NSPredicate格式字符串形式来表达的（比如对运行时被动态计算的值的评估）。而且当同一件事情可以用NSExpression结合自定义选择器来完成时，block为完成工作提供了一个方便的接口。</p>

<p>重要提示：<strong>由<code>predicateWithBlock:</code>生成的NSPredicate不能用于由SQLite存储库支持的Core Data数据的提取要求。</strong></p>

<p>我知道我已经说过很多次了，可是NSPredicate真的是Cocoa的优势之一。其他语言的第三方库如果能有它一半的能力就已经很幸运了－－更别提标准库了。对于我们这些应用和框架开发者来说，有它作为标准组件使得我们在处理数据时有了很大的优势。</p>

<p>和NSExpression一样，NSPredicate一直在提醒我们Foundation有多么好：它不仅仅十分有用，它精致的构架和设计也是我们写代码时灵感的来源。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C中的KVC和KVO]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo/"/>
    <updated>2014-05-12T12:02:32+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/12/objective-czhong-de-kvche-kvo</id>
    <content type="html"><![CDATA[<p>本文讲述了使用Cocoa框架中的KVC和KVO，实现观察者模式</p>

<!--more-->


<h2>KVC</h2>

<p>键/值编码中的基本调用包括<code>-valueForKey:</code>和<code>-setValue:forKey:</code>。以字符串的形式向对象发送消息，这个字符串是我们关注的属性的关键。<br/>
<code>valueForKey:</code>首先查找以键<code>-key</code>或<code>-isKey   </code>命名的getter方法。如果不存在getter方法（假如我们没有通过<code>@synthesize</code>提供存取方法），它将在对象内部查找名为<code>_key</code>或<code>key</code>的实例变量。<br/>
对于KVC，Cocoa自动放入和取出标量值（int，float和struct）放入NSNumber或NSValue中；当使用<code>-setValue:ForKey:</code>时，它自动将标量值从这些对象中取出。仅KVC具有这种自动包装功能，常规方法调用和属性语法不具备该功能。<br/>
<code>-setValue:ForKey:</code>的工作方式和<code>-valueForKey:</code>相同。它首先查找名称的setter方法，如果不存在setter方法，它将在类中查找名为<code>_key</code>或<code>key</code>的实例变量。</p>

<p>使用KVC访问属性的代价比直接使用存取方法要大，所以只在需要的时候才用。</p>

<p>最简单的 KVC 能让我们通过以下的形式访问属性：</p>

<p><code>objc
@property (nonatomic, copy) NSString *name;
</code></p>

<p>取值：</p>

<p><code>
NSString *n = [object valueForKey:@"name"];
</code>
设定：</p>

<p><code>
[object setValue:@"Daniel" forKey:@"name"];
</code>
值得注意的是这个不仅可以访问作为对象属性，而且也能访问一些标量（例如 int 和 CGFloat）和 struct（例如 CGRect）。Foundation 框架会为我们自动封装它们。举例来说，如果有以下属性：</p>

<p><code>
@property (nonatomic) CGFloat height;
</code>
我们可以这样设置它：</p>

<p><code>
[object setValue:@(20) forKey:@"height"];
</code></p>

<p>有关KVC的更多用法，参看下面的文章：</p>

<p><a href="http://blog.csdn.net/omegayy/article/details/7381301  ">http://blog.csdn.net/omegayy/article/details/7381301  </a>
<a href="http://blog.csdn.net/wzzvictory/article/details/9674431  ">http://blog.csdn.net/wzzvictory/article/details/9674431  </a>
<a href="http://objccn.io/issue-7-3/">http://objccn.io/issue-7-3/</a></p>

<h2>KVO</h2>

<p>KVO是Cocoa提供的一种称为键－值观察的机制，对象可以通过它得到其他对象特性属性的变更通知。这种机制在MVC模式的场景中很重要，因为它让视图对象可以经由控制器层观察模型对象的变更。<br/>
这一机制基于NSKeyValueObserving非正式协议，Cocoa通过这个协议为所有遵守协议的对象提供了一种自动化的属性观察能力。要实现自动观察，参与KVO的对象需要符合KVC的要求和存取方法，也可以手动实现观察者通知，也可以两者都保留。</p>

<p>KVO是Cocoa框架使用<strong>观察者模式</strong>的一种途径。</p>

<p>设置一个属性的观察者需要三步，理解这些步骤可以更清楚的知道KVO的工作框图<br/>
1. 首先看看你当前的场景如果使用KVO是否更妥当，比如，当一个实例的某个具体属性有任何变更的时候，另一个实例需要被通知。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353389577.jpg" alt="" /></p>

<p>比如，BankObject中的accountBalance属性有任何变更时，某个PersonObject对象都要觉察到。<br/>
2. 这个PersonObject对象必须注册成为BankObject的accountBalance属性的观察者，可以通过发送<code>addObserver:forKeyPath:options:context:</code>消息来实现。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353389319.jpg" alt="" /></p>

<p>注意：<code>addObserver:forKeyPath:options:context:</code>方法在你指定的两个实例间建立联系，而不是在两个类之间。<br/>
3. 为了回应变更通知，观察者必须实现<code>observeValueForKeyPath:ofObject:change:context:</code>方法。这个方法的实现决定了观察者如何回应变更通知。你可以在这个方法里自定义如何回应被观察属性的变更。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353388989.jpg" alt="" />  <br/>
4. 当一个被观察属性的值以符合KVO方式变更或者当它依赖的键变更时，<code>observeValueForKeyPath:ofObject:change:context:</code>方法会被自动执行。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353389524.jpg" alt="" /></p>

<h3>Registering for Key-Value Observing</h3>

<h4>注册成为观察者</h4>

<p>你可以通过发送<code>addObserver:forKeyPath:options:context:</code>消息来注册观察者</p>

<p>``` objc
&ndash; (void)registerAsObserver {</p>

<pre><code>/*
 Register 'inspector' to receive change notifications for the "openingBalance" property of
 the 'account' object and specify that both the old and new values of "openingBalance"
 should be provided in the observe… method.
 */
[account addObserver:inspector
         forKeyPath:@"openingBalance"
             options:(NSKeyValueObservingOptionNew |
                        NSKeyValueObservingOptionOld)
                context:NULL];
</code></pre>

<p>}
```</p>

<p>inspector注册成为了account的观察者，被观察属性的KeyPath是@&ldquo;openingBalance"，也就是account的openingBalance属性，NSKeyValueObservingOptionNew和NSKeyValueObservingOptionOld选项分别标识在观察者接收通知时change字典对应入口提供更改后的值和更改前的值。更简单的办法是用 NSKeyValueObservingOptionPrior 选项，随后我们就可以用以下方式提取出改变前后的值：(change是个字典，详细介绍请看下节)</p>

<p><code>
id oldValue = change[NSKeyValueChangeOldKey];
id newValue = change[NSKeyValueChangeNewKey];
</code></p>

<p>我们常常需要当一个值改变的时候更新 UI，但是我们也要在第一次运行代码的时候更新一次 UI。我们可以用 KVO 并添加 NSKeyValueObservingOptionInitial 的选项 来一箭双雕地做好这样的事情。这将会让 KVO 通知在调用 -addObserver:forKeyPath:&hellip; 到时候也被触发。<br/>
当我们注册 KVO 通知的时候，我们可以添加 NSKeyValueObservingOptionPrior 选项，这能使我们在键值改变之前被通知。这和-willChangeValueForKey:被触发的时间相对应。<br/>
如果我们注册通知的时候附加了 NSKeyValueObservingOptionPrior 选项，我们将会收到两个通知：一个在值变更前，另一个在变更之后。变更前的通知将会在 change 字典中有不同的键。</p>

<p>context是一个指针，当<code>observeValueForKeyPath:ofObject:change:context:</code>方法执行时context会提供给观察者。context可以使C指针或者一个对象引用，既可以当作一个唯一的标识来分辨被观察的变更，也可以向观察者提供数据。</p>

<h4>接收变更通知</h4>

<p>当被观察的属性变更时，观察者会接到<code>observeValueForKeyPath:ofObject:change:context:</code>消息，所有的观察者都必须实现这个方法。<br/>
观察者会被提供触发通知的对象和key path，一个包含变更详细信息的字典，还有一个注册观察者时提供的context指针。</p>

<p>```
&ndash; (void)observeValueForKeyPath:(NSString *)keyPath</p>

<pre><code>                  ofObject:(id)object
                    change:(NSDictionary *)change
                   context:(void *)context {

if ([keyPath isEqual:@"openingBalance"]) {
    [openingBalanceInspectorField setObjectValue:
        [change objectForKey:NSKeyValueChangeNewKey]];
}
/*
 Be sure to call the superclass's implementation *if it implements it*.
 NSObject does not implement the method.
 */
[super observeValueForKeyPath:keyPath
                     ofObject:object
                       change:change
                       context:context];
</code></pre>

<p>}
```
关于change参数，它是一个字典，有五个常量作为它的键：</p>

<p>NSString <em>const NSKeyValueChangeKindKey;<br/>
NSString </em>const NSKeyValueChangeNewKey;<br/>
NSString <em>const NSKeyValueChangeOldKey;<br/>
NSString </em>const NSKeyValueChangeIndexesKey;<br/>
NSString *const NSKeyValueChangeNotificationIsPriorKey;</p>

<p><strong>NSKeyValueChangeKindKey</strong><br/>
指明了变更的类型，值为“NSKeyValueChange”枚举中的某一个，类型为NSNumber。</p>

<p><code>
enum {
   NSKeyValueChangeSetting = 1,
   NSKeyValueChangeInsertion = 2,
   NSKeyValueChangeRemoval = 3,
   NSKeyValueChangeReplacement = 4
};
typedef NSUInteger NSKeyValueChange;
</code>
<strong>NSKeyValueChangeNewKey</strong><br/>
如果 NSKeyValueChangeKindKey的值为 NSKeyValueChangeSetting，并且 NSKeyValueObservingOptionNew选项在注册观察者时也指定了，那么这个键的值就是属性变更后的新值。<br/>
对于 NSKeyValueChangeInsertion或者NSKeyValueChangeReplacement，如果 NSKeyValueObservingOptionNew选项在注册观察者时也指定了，这个键的值是一个数组，其包含了插入或替换的对象。<br/>
<strong>NSKeyValueChangeOldKey</strong><br/>
如果 NSKeyValueChangeKindKey的值为 NSKeyValueChangeSetting，并且 NSKeyValueObservingOptionOld选项在注册观察者时也指定了，那么这个键的值就是属性变更前的旧值。<br/>
对于  NSKeyValueChangeRemoval 或者NSKeyValueChangeReplacement，如果 NSKeyValueObservingOptionOld选项在注册观察者时也指定了，这个键的值是一个数组，其包含了被移除或替换的对象。<br/>
<strong>NSKeyValueChangeIndexesKey</strong><br/>
如果 NSKeyValueChangeKindKey的值为NSKeyValueChangeInsertion, NSKeyValueChangeRemoval, 或者 NSKeyValueChangeReplacement，这个键的值是一个NSIndexSet对象，包含了增加，移除或者替换对象的index。<br/>
<strong>NSKeyValueChangeNotificationIsPriorKey</strong><br/>
如果注册观察者时NSKeyValueObservingOptionPrior选项被指明了，此通知会在变更发生前被发出。其类型为NSNumber，包含的值为YES。我们可以像以下这样区分通知是在改变之前还是之后被触发的：</p>

<p>```
if ([change[NSKeyValueChangeNotificationIsPriorKey] boolValue]) {</p>

<pre><code>// 改变之前
</code></pre>

<p>} else {</p>

<pre><code>// 改变之后
</code></pre>

<p>}
```</p>

<h4>移除观察者</h4>

<p>你可以通过发送<code>removeObserver:forKeyPath:</code>消息来移除观察者，你需要指明观察对象和路径。</p>

<p>```
&ndash; (void)unregisterForChangeNotification {</p>

<pre><code>[observedObject removeObserver:inspector forKeyPath:@"openingBalance"];
</code></pre>

<p>}
<code>``
上面的代码将openingBalance属性的观察者inspector移除，移除后观察者再也不会收到</code>observeValueForKeyPath:ofObject:change:context:`消息。<br/>
在移除观察者之前，如果context是一个对象的引用，那么必须保持对它的强引用直到观察者被移除。</p>

<h3>KVO Compliance（KVO兼容）</h3>

<p>有两种方法可以保证变更通知被发出。自动发送通知是NSObject提供的，并且一个类中的所有属性都默认支持，只要是符合KVO的。一般情况你使用自动变更通知，你不需要写任何代码。<br/>
人工变更通知需要些额外的代码，但也对通知发送提供了额外的控制。你可以通过重写子类<code>automaticallyNotifiesObserversForKey:</code>方法的方式控制子类一些属性的自动通知。</p>

<h4>Automatic Change Notification（自动通知）</h4>

<p>下面代码中的方法都能导致KVO变更消息发出</p>

<p>```
// Call the accessor method.
[account setName:@&ldquo;Savings&rdquo;];</p>

<p>// Use setValue:forKey:.
[account setValue:@&ldquo;Savings&rdquo; forKey:@&ldquo;name&rdquo;];</p>

<p>// Use a key path, where &lsquo;account&rsquo; is a kvc-compliant property of &lsquo;document&rsquo;.
[document setValue:@&ldquo;Savings&rdquo; forKeyPath:@&ldquo;account.name&rdquo;];</p>

<p>// Use mutableArrayValueForKey: to retrieve a relationship proxy object.
Transaction <em>newTransaction = &lt;#Create a new transaction for the account#>;
NSMutableArray </em>transactions = [account mutableArrayValueForKey:@&ldquo;transactions&rdquo;];
[transactions addObject:newTransaction];
```</p>

<h4>Manual Change Notification（手动通知）</h4>

<p>下面的代码为openingBalance属性开启了人工通知，并让父类决定其他属性的通知方式。</p>

<p>```
+ (BOOL)automaticallyNotifiesObserversForKey:(NSString *)theKey {</p>

<pre><code>BOOL automatic = NO;
if ([theKey isEqualToString:@"openingBalance"]) {
    automatic = NO;
}
else {
    automatic = [super automaticallyNotifiesObserversForKey:theKey];
}
return automatic;
</code></pre>

<p>}
```</p>

<p>要实现人工观察者通知，你要执行在变更前执行<code>willChangeValueForKey:</code>方法，在变更后执行<code>didChangeValueForKey:</code>方法：</p>

<p>```
&ndash; (void)setOpeningBalance:(double)theBalance {</p>

<pre><code>[self willChangeValueForKey:@"openingBalance"];
_openingBalance = theBalance;
[self didChangeValueForKey:@"openingBalance"];
</code></pre>

<p>}
```
为了使不必要的通知最小化我们应该在变更前先检查一下值是否变了：</p>

<p>```
&ndash; (void)setOpeningBalance:(double)theBalance {</p>

<pre><code>if (theBalance != _openingBalance) {
    [self willChangeValueForKey:@"openingBalance"];
    _openingBalance = theBalance;
    [self didChangeValueForKey:@"openingBalance"];
}
</code></pre>

<p>}
```
如果一个操作导致了多个键的变化，你必须嵌套变更通知：</p>

<p>```
&ndash; (void)setOpeningBalance:(double)theBalance {</p>

<pre><code>[self willChangeValueForKey:@"openingBalance"];
[self willChangeValueForKey:@"itemChanged"];
_openingBalance = theBalance;
_itemChanged = _itemChanged+1;
[self didChangeValueForKey:@"itemChanged"];
[self didChangeValueForKey:@"openingBalance"];
</code></pre>

<p>}
```
在to-many关系操作的情形中，你不仅必须表明key是什么，还要表明变更类型和影响到的索引。变更类型是一个 NSKeyValueChange值，被影响对象的索引是一个 NSIndexSet对象。<br/>
下面的代码示范了在to-many关系transactions对象中的删除操作：</p>

<p>```
&ndash; (void)removeTransactionsAtIndexes:(NSIndexSet *)indexes {</p>

<pre><code>[self willChange:NSKeyValueChangeRemoval
    valuesAtIndexes:indexes forKey:@"transactions"];

// Remove the transaction objects at the specified indexes.

[self didChange:NSKeyValueChangeRemoval
    valuesAtIndexes:indexes forKey:@"transactions"];
</code></pre>

<p>}
```</p>

<h3>Registering Dependent Keys（注册依赖的属性）</h3>

<p>有一些属性的值取决于一个或者多个其他对象的属性值，一旦某个被依赖的属性值变了，依赖它的属性的变化也需要被通知。</p>

<h4>To-one Relationships</h4>

<p>要自动触发 to-one关系，有两种方法：重写<code>keyPathsForValuesAffectingValueForKey:</code>方法或者定义名称为<code>keyPathsForValuesAffecting&lt;Key&gt;</code>的方法。</p>

<p>例如一个人的全名是由姓氏和名子组成的：</p>

<p>```
&ndash; (NSString *)fullName {</p>

<pre><code>return [NSString stringWithFormat:@"%@ %@",firstName, lastName];
</code></pre>

<p>}
```
一个观察fullName的程序在firstName或者lastName变化时也应该接收到通知。</p>

<p>一种解决方法是重写<code>keyPathsForValuesAffectingValueForKey:</code>方法来表明fullname属性是依赖于firstname和lastname的：</p>

<p>```
+ (NSSet <em>)keyPathsForValuesAffectingValueForKey:(NSString </em>)key {</p>

<pre><code>NSSet *keyPaths = [super keyPathsForValuesAffectingValueForKey:key];

if ([key isEqualToString:@"fullName"]) {
    NSArray *affectingKeys = @[@"lastName", @"firstName"];
    keyPaths = [keyPaths setByAddingObjectsFromArray:affectingKeys];
}
return keyPaths;
</code></pre>

<p>}
```
相当于在影响fullName值的keypath中新加了两个key：lastName和firstName，很容易理解。</p>

<p>另一种实现同样结果的方法是实现一个遵循命名方式为<code>keyPathsForValuesAffecting&lt;Key&gt;</code>的类方法，<Key>是依赖于其他值的属性名（首字母大写），用上面代码的例子来重新实现一下：</p>

<p>```
+ (NSSet *)keyPathsForValuesAffectingFullName {</p>

<pre><code>return [NSSet setWithObjects:@"lastName", @"firstName", nil];
</code></pre>

<p>}
```</p>

<p>有时在类别中我们不能添加<code>keyPathsForValuesAffectingValueForKey:</code>方法，因为不能再类别中重写方法，所以这时可以实现<code>keyPathsForValuesAffecting&lt;Key&gt;</code>方法来代替。</p>

<p>注意：你不能在<code>keyPathsForValuesAffectingValueForKey:</code>方法中设立to-many关系的依赖，相反，你必须观察在to-many集合中的每一个对象中相关的属性并通过亲自更新他们的依赖来回应变更。下一节将会讲述对付此情形的策略。</p>

<h4>To-many Relationships</h4>

<p><code>keyPathsForValuesAffectingValueForKey:</code>方法不支持包含to-many关系的keypath。比如，假如你有一个Department类，它有一个针对Employee类的to-many关系（雇员），Employee类有salary属性。你希望Department类有一个totalSalary属性来计算所有员工的薪水，也就是在这个关系中Department的totalSalary依赖于所有Employee的salary属性。你不能通过实现<code>keyPathsForValuesAffectingTotalSalary</code>方法并返回<code>employees.salary</code>。</p>

<p>有两种解决方法：<br/>
1. 你可以用KVO将parent（比如Department）作为所有children（比如Employee）相关属性的观察者。你必须在把child添加或删除到parent时也把parent作为child的观察者添加或删除。在<code>observeValueForKeyPath:ofObject:change:context:</code>方法中我们可以针对被依赖项的变更来更新依赖项的值：</p>

<p>```
&ndash; (void)observeValueForKeyPath:(NSString <em>)keyPath ofObject:(id)object change:(NSDictionary </em>)change context:(void *)context {</p>

<pre><code>if (context == totalSalaryContext) {
    [self updateTotalSalary];
}
else
// deal with other observations and/or invoke super...
</code></pre>

<p>}</p>

<ul>
<li><p>(void)updateTotalSalary {
  [self setTotalSalary:[self valueForKeyPath:@&ldquo;<a href="&#109;&#97;&#105;&#108;&#x74;&#x6f;&#x3a;&#x65;&#x6d;&#112;&#108;&#111;&#x79;&#x65;&#101;&#x73;&#x2e;&#64;&#115;&#x75;&#x6d;&#46;&#115;&#97;&#x6c;&#x61;&#114;&#x79;">&#101;&#109;&#112;&#108;&#111;&#121;&#101;&#101;&#x73;&#x2e;&#x40;&#115;&#x75;&#x6d;&#46;&#x73;&#x61;&#108;&#97;&#114;&#x79;</a>&rdquo;]];
}</p></li>
<li><p>(void)setTotalSalary:(NSNumber *)newTotalSalary {</p>

<p>  if (totalSalary != newTotalSalary) {
      [self willChangeValueForKey:@&ldquo;totalSalary&rdquo;];
      _totalSalary = newTotalSalary;
      [self didChangeValueForKey:@&ldquo;totalSalary&rdquo;];
  }
}</p></li>
<li><p>(NSNumber *)totalSalary {
  return _totalSalary;
}
```</p></li>
</ul>


<p>2.如果你在使用Core Data，你可以在应用的notification center中将parent注册为它的 managed object context的观察者，parent应该回应相应的变更通知，这些通知是children以类似KVO的形式发出的。</p>

<p>其实这也是Objective-C中利用Cocoa实现观察者模式的另一种途径：NSNotificationCenter</p>

<h3>调试KVO</h3>

<p>你可以在 lldb 里查看一个被观察对象的所有观察信息。</p>

<p><code>
(lldb) po [observedObject observationInfo]
</code>
这会打印出有关谁观察谁之类的很多信息。</p>

<p>这个信息的格式不是公开的，我们不能让任何东西依赖它，因为苹果随时都可以改变它。不过这是一个很强大的排错工具。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[装饰者模式]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi/"/>
    <updated>2014-05-10T09:47:05+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353405846.png" alt="" /></p>

<!--more-->


<ul>
<li>装饰者和被装饰对象有相同的超类型。</li>
<li>你可以用一个或多个装饰者包装一个对象。</li>
<li>既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合 ,可以用装饰过的对象代替它。</li>
<li><strong>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。</strong></li>
<li>对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰
对象。</li>
</ul>


<p><strong>类应该对扩展开放，对修改关闭。</strong></p>

<h2>用配置咖啡饮料做例子</h2>

<p>比如，现在有一个饮料类（Beverage），向饮料中添加不同的配料（蒸奶（Steamed Milk）、豆浆（Soy）、
摩卡（Mocha，也就是巧克力风味）或覆盖奶泡），就会配制出很多种不同的种类的饮料，其价格也随着添加的配料而变化，饮料店需要计算价格，如果用具体子类继承饮料类并考虑到所有组合的话，将是一个“类爆炸”：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353406269.png" alt="" /></p>

<p>更恶心的是，如果某种配料的价格有变化，就必须含有此配料相应的更改一些饮料子类的实现，记住：<strong>类应该对扩展开放，对修改关闭。</strong></p>

<p>应用装饰者模式，就像给对象穿衣服一样一层一层将拓展动态的添加上去，灵活多变有弹性</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353407109.png" alt="" /></p>

<p>下面用Java实现这个例子</p>

<p>Beverage是一个抽象类，有两个方法：getDescrip-tion()及cost（）</p>

<p><code>java
public abstract class Beverage {
String description = "Unknown Beverage";
public String getDescription() {
return description;
}
public abstract double cost();
}
</code>
Beverage很简单。让我们也来实现Condiment（配料）抽象类，也就是装饰者类吧：</p>

<p><code>
public abstract class CondimentDecorator extends Beverage {
public abstract String getDescription();
}
</code>
必须让Condiment Decorator能够取代Beverage，所以将CondimentDecorator扩展自 Beverage 类</p>

<p>现在，已经有了基类，让我们开始开始实现一些饮料吧！先从浓缩咖啡（Espresso）开始。别忘了，我们需要为具体的饮料设置描述，而且还必须实现cost()方法</p>

<p><code>
public class Espresso extends Beverage {
public Espresso() {
description = "Espresso";
}
public double cost() {
return 1.99;
}
}
</code></p>

<p>其他几种具体的饮料就不写了</p>

<p>如果你回头去看看装饰者模式的类图，将发现我们已经完成了抽象组件（Beverage），有了具体组件（HouseBlend），也有了抽象装饰者（CondimentDecorator）。现在，我们就来实现具体装饰者。先从摩卡下手：</p>

<p><code>
public class Mocha extends CondimentDecorator {
Beverage beverage;
public Mocha(Beverage beverage) {
this.beverage = beverage;
}
public String getDescription() {
return beverage.getDescription() + ", Mocha";
}
public double cost() {
return .20 + beverage.cost();
}
}
</code></p>

<p>你会发现在装饰者类中，完成了描述和价格的效果添加，也就是完成了拓展</p>

<p>其他几种配料代码就不写了</p>

<p>下面进行测试：</p>

<p><code>
public class StarbuzzCoffee {
public static void main(String args[]) {
Beverage beverage = new Espresso();
System.out.println(beverage.getDescription()
+ " $" + beverage.cost());
Beverage beverage2 = new DarkRoast();
beverage2 = new Mocha(beverage2);
beverage2 = new Mocha(beverage2);
beverage2 = new Whip(beverage2);
System.out.println(beverage2.getDescription()
+ " $" + beverage2.cost());
Beverage beverage3 = new HouseBlend();
beverage3 = new Soy(beverage3);
beverage3 = new Mocha(beverage3);
beverage3 = new Whip(beverage3);
System.out.println(beverage3.getDescription()
+ " $" + beverage3.cost());
}
}
</code></p>

<p>输出结果：</p>

<p>```
% java StarbuzzCoffee<br/>
Espresso $1.99<br/>
Dark Roast Coffee, Mocha, Mocha, Whip $1.49<br/>
House Blend Coffee, Soy, Mocha, Whip $1.34<br/>
%</p>

<p>```
果然是一层套一层吧：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353407345.png" alt="" /></p>

<h2>Java中的装饰者</h2>

<p>java.io包内的类太多了，简直是……“排山倒海”。你第一次（还有第二次和第三次）看到这些API发出“哇”的惊叹时，放心，你不是唯一受到惊吓的人。现在，你已经知道装饰者模式，这些I/O的相关类对你来说应该更有意义了，因为其中许多类都是装饰者。下面是一个典型的对象集合，用装饰者来将功能结合起来，以读取文件数据：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353408228.png" alt="" /></p>

<p><code>BufferedInputStream</code>及<code>LineNumberInputStream</code>都扩展自<code>FilterInputStream</code>，而<code>FilterInputStream</code>是一个抽象的装饰类。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353408237.png" alt="" /></p>

<p>你会发现“输出”流的设计方式也是一样的。你可能还会发现Reader/Writer流（作为基于字符数据的输入输出）和输入流/输出流的类相当类似（虽然有一些小差异和不一致之处，但是相当雷同，所以你应该可以了解这些类）。</p>

<p>但是JavaAI/O也引出装饰者模式的一个“缺点”：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。但是，现在你已经了解了装饰者的工作原理，以后当使用别人的大量装饰的API时，就可以很容易地辨别出他们的装饰者类是如何组织的，以方便用包装方式取得想要的行为。</p>

<h2>Objective-C类别与装饰模式</h2>

<p>Objective-C中也可以实现基于继承和接口的装饰者模式，但这里介绍的是另一种实现方法：类别</p>

<p>类别是一个Objective-C的语言功能，通过它可以向类添加行为（方法的接口与实现），而不必进行子类化。通过类别添加的方法对类原有的方法没有不良影响。类别中的方法成为了类的一部分，并可由其子类继承。</p>

<p>我们可以用类别来实现装饰模式，然而这不是一种严格的实现，它实现了模式的意图，但却是一种变体。由装饰器类别添加的行为是编译时绑定的，虽然Objective-C原本支持动态绑定（应该用方法的哪个实现）。而且装饰器类别实际上没有封装被扩展的类的实例。</p>

<p>尽管使用类别来实现这个模式跟原始风格有些偏离，但是实现少量的装饰器的时候，它比真正子类的方式更为轻量、更为容易。</p>

<p>这次我们来装饰一张照片，装饰的方法有很多，比如旋转位移变换，阴影。。。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353408757.png" alt="" /></p>

<p>工程代码可以在<a href="https://github.com/yulingtianxia/Decorator">这里</a>下载</p>

<p>这一方式中有三个类别：UIImage(BaseFilter),UIImage(Transform)和UIImage(Shadow)。从现在起，我把它们分别简称为BaseFilter、Transform和Shadow。BaseFilter定义了几个基本的二维绘图操作，使用当前绘图上下文绘制自己，其他滤镜类别可以使用同样的方法来绘制图像。Transform和Shadow没有继承BaseFilter，但他们属于同一类，因为他们都是UIImage的类别。BaseFilter中定义的方法也能在Transform和Shadow类别中使用，而不必像子类化那样进行继承。</p>

<p>UIImage(BaseFilter)中的方法定义，用户绘制图像，相当于装饰者抽象类，而UIImage则是被装饰的组件:</p>

<p>``` objc</p>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (BaseFilter)
&ndash; (CGContextRef) beginContext
{</p>

<pre><code>CGSize size = [self size];
UIGraphicsBeginImageContextWithOptions(size, NO, 0);
CGContextRef context = UIGraphicsGetCurrentContext();

return context;
</code></pre>

<p>}</p>

<ul>
<li><p>(UIImage *) getImageFromCurrentImageContext
{
  [self drawAtPoint:CGPointZero];</p>

<p>  // Retrieve the UIImage from the current context
  UIImage *imageOut = UIGraphicsGetImageFromCurrentImageContext();</p>

<p>  return imageOut;
}</p></li>
<li><p>(void) endContext
{
  UIGraphicsEndImageContext();
}
@end
```</p></li>
</ul>


<p>Transform类别定义了一个<code>imageWithTransform:transform</code>方法，接受一个转换引用，然后把应用于内部的图像引用，并让它把自己画出来，然后返回变换后的图像:</p>

<p>```</p>

<h1>import &ldquo;UIImage+Transform.h&rdquo;</h1>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (Transform)
&ndash; (UIImage *) imageWithTransform:(CGAffineTransform)transform
{</p>

<pre><code>CGContextRef context = [self beginContext];

// setup transformation
CGContextConcatCTM(context, transform);

// Draw the original image to the context
UIImage *imageOut = [self getImageFromCurrentImageContext];

[self endContext];

return imageOut;
</code></pre>

<p>}
@end
```</p>

<p>Shadow类别定义了一个<code>imageWithDropShadow</code>方法，向图像的内部引用添加阴影效果，并返回应用效果之后的最终图像。</p>

<p>```</p>

<h1>import &ldquo;UIImage+Shadow.h&rdquo;</h1>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (Shadow)
&ndash; (UIImage *) imageWithDropShadow
{</p>

<pre><code>CGContextRef context = [self beginContext];

// set up shadow
CGSize offset = CGSizeMake (-25,  15);
CGContextSetShadow(context, offset, 20.0);

// Draw the original image to the context
UIImage * imageOut = [self getImageFromCurrentImageContext];

[self endContext];

return imageOut;
</code></pre>

<p>}
@end
```
最后在ViewController中加载图像：</p>

<p>```
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.
UIImage *image = imageView.image;


// create a transformation
CGAffineTransform rotateTransform = CGAffineTransformMakeRotation(-M_PI / 4.0);
CGAffineTransform translateTransform = CGAffineTransformMakeTranslation(-image.size.width / 2.0,
                                                                        image.size.height / 8.0);
CGAffineTransform finalTransform = CGAffineTransformConcat(rotateTransform, translateTransform);
UIImage* finalImage = [[image imageWithTransform:finalTransform] imageWithDropShadow];
[imageView setImage:finalImage];
</code></pre>

<p>}
```</p>

<p>因为类别只能拓展方法，不能在原有类的基础上添加属性，但是我们依然可以通过下面的方式向类中动态添加属性，来弥补类别的不足：</p>

<p>给UIImage添加一个新的title属性<br/>
具体代码如下：<br/>
<code>UIImage+Title.h</code>:</p>

<p><code>
@interface UIImage(Title)
@property(nonatomic, copy) NSString *title;
@end
</code>
<code>UIImage+Title.m</code>:</p>

<p>```</p>

<h1>import &ldquo;UIImage+Title.h&rdquo;</h1>

<p>static char titleKey;</p>

<p>@implementation UIImage(Title)
&ndash; (NSString *)title
{</p>

<pre><code>return objc_getAssociatedObject(self, &amp;titleKey);
</code></pre>

<p>}</p>

<ul>
<li>(void)setTitle:(NSString *)title
{
  objc_setAssociatedObject(self, &amp;titleKey, title, OBJC_ASSOCIATION_COPY);
}
@end
```
可以看到关键是用到了runtime的两个函数：</li>
<li><code>id objc_getAssociatedObject(id object, void *key)</code></li>
<li><code>void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)</code></li>
</ul>


<p>该函数中第一个参数表示目标对象，第三个参数表示要添加的属性，第四个参数设置objc_AssociationPolicy,它有以下几个选项：<code>OBJC_ASSOCIATION_ASSIGN</code>，<code>OBJC_ASSOCIATION_RETAIN</code>，<code>OBJC_ASSOCIATION_COPY</code>，分别对应我们在声明属性时的<code>assign</code>,<code>retain</code>,<code>copy</code>。<br/>
关于第二个参数，key。因为一个对象可以关联多个新的对像，我们需要一个标志来区分他们。所以这个key就起这样的作用。这里的需要的key的地址，不关心它指向谁。</p>

<p>当我们第二次以新的value调用objc_setAssociatedObject时，如果policy是OBJC_ASSOCIATION_ASSIGN，新的value被关联，对原来旧的value没有任何影响。如果policy是OBJC_ASSOCIATION_RETAIN和OBJC_ASSOCIATION_COPY，新的value被关联，旧的value被release。如果想release原来的value又不关联新的value，，可以用objc_setAssociatedObject直接传一个nil做为value的值。</p>

<p>注意不要使用<code>objc_removeAssociatedObjects</code>，因为它用去掉所有的关联的对象。</p>

<p>参考资料：<br/>
1. 《iOS设计模式解析》<br/>
2. 《HeadFirst设计模式》<br/>
3. <a href="http://fanliugen.com/?p=460">http://fanliugen.com/?p=460</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Core Data(2)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/"/>
    <updated>2014-05-02T20:17:04+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2</id>
    <content type="html"><![CDATA[<p>本文内容：</p>

<ul>
<li>自定义NSManagedObject</li>
<li>使用数据模型设计器</li>
<li>探究Core Data在SQLite中的实现</li>
</ul>


<p>推荐先阅读上一篇文章：<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a></p>

<p><strong>文章所使用的项目代码可以到<a href="https://github.com/yulingtianxia/MyCDDemo">这里</a>下载</strong></p>

<p>在<a href="http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3/">下一篇文章</a>里，我将会通过教程的方式，讲述如何用Swift结合CoreData的NSFetchedResultsController写一个小Demo-<a href="https://github.com/yulingtianxia/HardChoice">HardChoice</a></p>

<!--more-->


<h2>自定义NSManagedObject</h2>

<p>在上一篇教程中我们每条数据都是通过<code>NSManagedObject</code>对象装载，通过KVC方式使用<code>valueForKey：</code>方法访问对象属性，但是使用KVC要比使用访问器效率低一点。 只在必要时使用KVC，比如你需要动态选择key或keyPath。</p>

<p><code>objc
[newEmployee setValue:@”Stig” forKey:firstName];
[aDepartment setValue:@1000 forKeyPath:manager.salary];
</code></p>

<p>下面我们将自定义<code>NSManagedObject</code>类，通过对它的继承拓展，使得我们有自己的Event类，并通过访问器方法代替KVC方式来访问对象的属性。<br/>
按CMD+N或者在可视化建模工具下选择菜单中Editor->Create NSManagedObject Subclass：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353399425.png" alt="" /></p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353399917.png" alt="" /></p>

<p>选中需要子类化的Entity（当然我们只有一个Event，自动勾选了）：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353400261.png" alt="" /></p>

<p>最后点击Create，于是Event类就创建好了，可以看到属性timeStamp已经自动生成了，并且实现为<code>@dynamic</code></p>

<p>熟悉Objective-C语法的都知道<code>@synthesize</code>实际的意义就是自动生成属性的setter和getter方法。</p>

<p><code>@dynamic</code>就是要告诉编译器，代码中用<code>@dynamic</code>修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译。其主要的作用就是用在<code>NSManagerObject</code>对象的属性声明上，由于此类对象的属性一般是从Core Data的属性中生成的，Core Data框架会在程序运行的时候为此类属性生成getter和setter方法。</p>

<p>好的，下面我们改写以前的代码，这次我们将使用Event类的对象完成以前的任务：</p>

<p>在MasterViewController.m文件中加入<code>#import "Event.h"</code>，然后将<code>insertNewObject:</code>方法替换如下</p>

<p>```
&ndash; (void)insertNewObject:(id)sender
{</p>

<pre><code>NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
NSEntityDescription *entity = [[self.fetchedResultsController fetchRequest] entity];
Event *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];

// If appropriate, configure the new managed object.
// Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
</code></pre>

<p>//    [newManagedObject setValue:[NSDate date] forKey:@&ldquo;timeStamp&rdquo;];</p>

<pre><code>newManagedObject.timeStamp = [NSDate date];
// Save the context.
NSError *error = nil;
if (![context save:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}
</code></pre>

<p>}
<code>``
嗯，英文注释还告诉我们通常你应该用访问器方法呢，还说但是现在在这用KVC就避免了向模板添加自定义类的需求，真逗啊  
依此类推，更改</code>prepareForSegue: sender:`方法：</p>

<p>```
&ndash; (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{</p>

<pre><code>if ([[segue identifier] isEqualToString:@"showDetail"]) {
    NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
    Event *object = [[self fetchedResultsController] objectAtIndexPath:indexPath];
    [[segue destinationViewController] setDetailItem:object];
}
</code></pre>

<p>}
```</p>

<p>还有<code>configureCell: atIndexPath:</code>方法：</p>

<p>```
&ndash; (void)configureCell:(UITableViewCell <em>)cell atIndexPath:(NSIndexPath </em>)indexPath
{</p>

<pre><code>Event *object = [self.fetchedResultsController objectAtIndexPath:indexPath];
</code></pre>

<p>//    cell.textLabel.text = [[object valueForKey:@&ldquo;timeStamp&rdquo;] description];</p>

<pre><code>cell.textLabel.text = [object.timeStamp description];
</code></pre>

<p>}
<code>``
相应地我们也可以针对</code>DetailViewController`进行改造：</p>

<p>DetailViewController.h:</p>

<p>```</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@class Event;
@interface DetailViewController : UIViewController</p>

<p>@property (strong, nonatomic) Event *detailItem;</p>

<p>@property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;
@end
```</p>

<p>DetailViewController.m:</p>

<p>```</p>

<h1>import &ldquo;DetailViewController.h&rdquo;</h1>

<h1>import &ldquo;Event.h&rdquo;</h1>

<p>@interface DetailViewController ()
&ndash; (void)configureView;
@end</p>

<p>@implementation DetailViewController</p>

<h1>pragma mark &ndash; Managing the detail item</h1>

<ul>
<li><p>(void)setDetailItem:(Event *)newDetailItem
{
  if (<em>detailItem != newDetailItem) {
      </em>detailItem = newDetailItem;</p>

<pre><code>  // Update the view.
  [self configureView];
</code></pre>

<p>  }
}</p></li>
<li><p>(void)configureView
{
  // Update the user interface for the detail item.</p>

<p>  if (self.detailItem) {
//        self.detailDescriptionLabel.text = [[self.detailItem valueForKey:@&ldquo;timeStamp&rdquo;] description];
      self.detailDescriptionLabel.text = [self.detailItem.timeStamp description];
  }
}</p></li>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];
  // Do any additional setup after loading the view, typically from a nib.
  [self configureView];
}</p></li>
<li><p>(void)didReceiveMemoryWarning
{
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}</p></li>
</ul>


<p>@end
```
这部分比较简单，就不详细解释了，运行程序，跟以前一样（不截图了）</p>

<p>如果想复用<code>MasterViewController</code>里面那些代码，需要做些大改动，具体可以参看<a href="http://objccn.io/issue-1-1/">更轻量的 View Controllers</a>这篇文章</p>

<h2>使用数据模型设计器</h2>

<p>点击MyCDDemo.xcdatamodeld文件进入数据模型设计器，点击下方的加号（Add Enity），添加一个Enity，将其名字改为Person。然后添加name和sex属性，类型为string，需要注意的是属性名需要首字母小写，而且我们无需像往常给数据库建表一样为其添加ID字段，因为Core Data中你不需要任何类型的唯一标识Id，也不需要处理表连接。Core Data将在后台自动处理。你所需要做的就是定义对象间的关系。Core Data框架将在后台决定如何生成最佳的底层机制。</p>

<p>与实体名一样，属性的命名也有很多的要求和约定。属性名不能以大写字母开头，不能包含空格，一般都是单数。对于Boolean类型属性，你应该遵循Objective-C实例变量的约定,比如指定一个CustomerOrder对象是否已经发货，那么应该命名属性为shipped，而不是isShipped、hasShipped等。</p>

<p>关于Core Data属性类型，我从网上摘抄了一段比较全面的解释：</p>

<ul>
<li><p>Undefined选项值是新创建的属性的默认类型；如果属性类型为undefined，项目将无法通过编译。</p></li>
<li><p>Integer 16/32/64只表示整数，没有小数点。所以如果10除以3，你将会得到3，而余数1会丢失。Integer 16/32/64之间唯一的区别是所表示的数值范围不同。因为Core Data使用符号数，所以起始范围是负数，而不是0。</p>

<ul>
<li><p>Integer 16 数值范围：-32768~32767；</p></li>
<li><p>Integer 32 数值范围：-2147483648~2147483647；</p></li>
<li><p>Integer 64 数值范围：–9223372036854775808~9223372036854775807。</p></li>
</ul>


<p>  标准整型数的最大值和最小值可以在stdint.h中找到。在任何类文件中输入INT32_MAX,选中右击，然后选择Jump To Definition，你将看到许多最大值最小值定义。<strong>实体的属性的类型是Integer 16/32/64，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSNumber</strong>。</p></li>
<li><p>Double和Float可以认为是有小数部分的整数。它们都是基于二进制数值系统，在CPU运算时很可能会发生舍入误差。比如1/5，如果使用十进制数值系统，可以精确表示为0.2.但在二进制数值系统中，只能表示一个大概，在小数部分你会得到大量数字。<strong>所以不要使用Integer、Double、Float表示货币值。</strong>计算精度越高则越加趋于准确值，但内存占用也会越大。一个Float数使用32bit进行存储，一个Double数使用64bit。它们都使用科学计数法进行存储，所以一个数包含尾数和指数部分。</p>

<p>  在iOS中，最大的Float值是340282346638528859811704183484516925440.000000，最小的Float值是340282346638528859811704183484516925440.000000Double和Float都有一个符号位。而Double比Float的数值范围更大。</p>

<p>  当你决定该选择Float还是Double时，想一下你的属性是否真的需要超过Float提供的7位精度，如果不是，你应该选择Float，因为它更加匹配64bit的iPhone 5S底层处理器。除此之外，如果你想增加浮点数的计算速度而精度并没有严格要求，Float也是最佳选择。<strong>实体的属性的类型是Float或Double，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSNumber。</strong></p></li>
<li><p><strong>Decimal（十进制）是处理货币值和其他需要十进制场合下最佳选择</strong>，Decimal提供了优秀的计算精度，也消除了计算过程中的舍入误差。因为CPU的本地数制是二进制，所以CPU在处理十进制数时，开销会多一点。<strong>实体的属性的类型是Decimal，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSDecimalNumber。</strong>当你使用NSDecimalNumber执行计算时(如加减乘除计算)，为了保证计算精度，你只能使用它提供的内建方法。更多关于NSDecimalNumber可参见这里。</p></li>
<li><p>String类型和Objective-C中的NSString类似，用于保存字符数组。当生成实体对应的NSManagedObject子类时，String属性被表示为NSString。</p></li>
<li><p>Boolean数据类型被用于表示YES/NO值。当生成实体对应的NSManagedObject子类时，Boolean数据类型会被表示为NSNumber。所以为了获取布尔值，你需要想NSNumber对象发送boolValue消息。</p></li>
<li><p>Date类型是自解释类型。用来存储日期和时间。<strong>当生成实体对应的NSManagedObject子类时，Date类型会被表示为NSDate。</strong></p></li>
<li><p>Binary Data用来表示照片，音频，或一些BLOB类型数据(&ldquo;Binary Large OBjects&rdquo; such as image and sound data)。<strong>当生成实体对应的NSManagedObject子类时，Binary Data数据类型会被表示为NSData。</strong></p></li>
<li><p>Transformable属性类型用于存储一个Objective-C对象。该属性类型允许你存储任何类的实例，比如你使用Transformable属性表示UIColor。<strong>当生成NSManagedObject子类时，Transformable类型会被表示为id。</strong>对于id对象的保存和解档需要使用一个NSValueTransformer的实例或子类的实例。由该类负责属性值与NSData之间的转换。但这也相当的简单，尤其是当属性值的类型已经实现了NSCoding协议，此时系统会自动提供一个默认的NSValueTransformer实例来完成归档和解档。</p></li>
</ul>


<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353400282.png" alt="" /></p>

<p>选择一个属性，在右侧的Data Model Inspector中可以对属性进行更为详细的设置，而且这些设置项会根据你所设置的属性类型不同而不同，大致分为以下几类：</p>

<ul>
<li>Transient（瞬时）选项表示属性不会存储到持久化存储文件中。Transient通常用在属性的值是由其他属性计算或合成而来（比如fullName属性是根据Persion类实例的firstName和lastName拼接而来）。</li>
<li>Optional（可选）选项表示当前属性的值允许为空。如果将属性指定为Optional，那么即使属性的值为空，实体的NSManagedObject实例也可被保存。如果该值是必选的（不选中Optional则为必选），如果属性值为空，NSManagedObject对象上下文将拒绝保存这个属性值不完整的NSManagedObject对象（当你尝试并保存上下文，你将接收到一个NSError对象）。所有的属性最初的状态都是Optinal。</li>
<li>Indexed选项表示底层的持久化存储文件应该为该属性生成一个索引；如果你使用基于多个属性的查询条件来提取对象，指定此类属性为Indexed，可以大幅提高提取速度。</li>
<li>Reg.Ex是Regular Expression的缩写，主要是用来验证属性值是否匹配特定的模式。此选项只对String类型有效。</li>
<li>Validation可以保证非法数据不被保存进持久化存储文件中。数值属性类型（Integer 16/32/64、Float、Double、Decimal）都有maximum和minimum最大值最小值设定。你也可以对String类型设置最大长度和最小长度。或对Date类型设置日期范围。不过最好的做法是当用户向UITextField中输入数据时就开始验证数据，而非等到向上下文发送save消息才验证数据。</li>
<li>除了Transformable和Binary Data类型以外，Default适用于所有属性类型。它被用来配置属性的默认值。</li>
<li>Allows External Storage允许大尺寸的二进制数据可以保存在持久化存储文件的外部。当你保存如照片，音频或视频时，建议是选中该选项， 这样Core Data就会对大于1MB的数据保存在持久化存储文件的外部。</li>
</ul>


<p>如果你细心的话，会发现无论是属性还是实体等选项，右侧的Data Model Inspector经常会出现User Info一栏。<br/>
在managed object model中很多元素，比如entities, attributes,和 relationships，有一个相关联的用户信息字典。你可以在用户信息字典中以键值对的形式放入你想要的任何信息。这里常用的信息有实体的版本详情，还有fetched property中谓词（predicate）用到的值。</p>

<p>说了一大堆，再添加两个实体吧：Teacher和Student，都继承自Person：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353400755.png" alt="" /></p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353401739.png" alt="" /></p>

<p>点击右下方的Editor Style切换到Graph模式：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353401953.png" alt="" /></p>

<p>选中Teacher，长按Add Attribute会弹出所有的选项（同样你也可以试试长按Add Enity），选择Add Relationship，添加一个关系，命名为students，Type为To Many，目标为Student（一个老师教很多学生）：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353402308.png" alt="" /></p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/14035340227.png" alt="" /></p>

<p>我们再尝试一种添加关系的新方法：把以前在Teacher中建立的students删除，选中Student，按住Ctrl，鼠标拖至Teacher，这样一个双向的关系就建立起来了：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353402879.png" alt="" /></p>

<p>分别编辑双方的关系，Tpye都是To Many：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353402596.png" alt="" /></p>

<p>用上一节中提到的方法，建立这三个新建的Entity的<code>NSManagedObject</code>子类：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/14035340286.png" alt="" /></p>

<p>因为创建顺序的问题，当Student创建的时候还不知道有<code>Teacher</code>类，于是其生成的一些方法将Teacher默认为<code>NSManagedObject</code>类：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<p>@interface Student : NSManagedObject</p>

<p>@property (nonatomic, retain) NSNumber * grade;
@property (nonatomic, retain) NSSet *teachers;
@end</p>

<p>@interface Student (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addTeachersObject:(NSManagedObject *)value;</li>
<li>(void)removeTeachersObject:(NSManagedObject *)value;</li>
<li>(void)addTeachers:(NSSet *)values;</li>
<li>(void)removeTeachers:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>而Teacher类创建的时候已经有了<code>Student</code>类，就不会出现上面的问题：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<p>@class Student;</p>

<p>@interface Teacher : NSManagedObject</p>

<p>@property (nonatomic, retain) NSString * course;
@property (nonatomic, retain) NSSet *students;
@end</p>

<p>@interface Teacher (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addStudentsObject:(Student *)value;</li>
<li>(void)removeStudentsObject:(Student *)value;</li>
<li>(void)addStudents:(NSSet *)values;</li>
<li>(void)removeStudents:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>虽然<code>Teacher</code>类认识<code>Student</code>类，因为它已经创建了，但是此时Persion类还没有创建，于是此时<code>Student</code>类和<code>Teacher</code>类继承的依然是<code>NSManagedObject</code>，这不是我们想要的结果。<br/>
解决方法是重新生成下这三个Entity对应的<code>NSManagedObject</code>子类，并覆盖原有的文件：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<h1>import &ldquo;Person.h&rdquo;</h1>

<p>@class Teacher;</p>

<p>@interface Student : Person</p>

<p>@property (nonatomic, retain) NSNumber * grade;
@property (nonatomic, retain) NSSet *teachers;
@end</p>

<p>@interface Student (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addTeachersObject:(Teacher *)value;</li>
<li>(void)removeTeachersObject:(Teacher *)value;</li>
<li>(void)addTeachers:(NSSet *)values;</li>
<li>(void)removeTeachers:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>你会发现多了一个<code>CoreDataGeneratedAccessors</code>类别，这个类别中的方法是Core Data框架根据你在数据模式编辑器中设置的实体关系自动生成的，你不需要实现它们，Core Data会在运行时实现这些方法<br/>
如果你偏要想看看其实现机理，在右下方的代码片段库中选择“Core Data To-Many Relationship Accessors”并拖拽到代码中</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353403195.png" alt="" /></p>

<p>生成的代码如下：</p>

<p>```
&ndash; (void)add&lt;#CapitalizedRelationshipName#>Object:(&lt;#relationship destination class#> *)value
{</p>

<pre><code>NSSet *changedObjects = [NSSet setWithObject:value];
[self willChangeValueForKey:@"&lt;#relationshipName#&gt;" withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects];
[[self primitiveValueForKey:@"&lt;#relationshipName#&gt;"] addObject:value];
[self didChangeValueForKey:@"&lt;#relationshipName#&gt;" withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)remove&lt;#CapitalizedRelationshipName#>Object:(&lt;#relationship destination class#> <em>)value
{
  NSSet </em>changedObjects = [NSSet setWithObject:value];
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] removeObject:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects];
}</p></li>
<li><p>(void)add&lt;#CapitalizedRelationshipName#>:(NSSet *)value
{  <br/>
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueUnionSetMutation usingObjects:value];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] unionSet:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueUnionSetMutation usingObjects:value];
}</p></li>
<li><p>(void)remove&lt;#CapitalizedRelationshipName#>:(NSSet *)value
{
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:value];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] minusSet:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:value];
}
```</p></li>
</ul>


<p>我们需要将&lt;#Capitalized relationship name#>, &lt;#Relationship destination class#> 和 &lt;#Relationship name#>替换为我们定义的连接名，对照下前面<code>CoreDataGeneratedAccessors</code>类别中的方法名，你就会明白了</p>

<p>同样以前标记为<code>@dynamic</code>的属性，其实现原理如下：</p>

<p>```
&ndash; (&lt;#propertyObjectType#> *)&lt;#propertyName#>
{</p>

<pre><code>[self willAccessValueForKey:@"&lt;#propertyName#&gt;"];
&lt;#propertyObjectType#&gt; *value = [self primitiveValueForKey:@"&lt;#propertyName#&gt;"];
[self didAccessValueForKey:@"&lt;#propertyName#&gt;"];
return value;
</code></pre>

<p>}</p>

<ul>
<li>(void)set&lt;#CapitalizedPropertyName#>:(&lt;#propertyObjectType#> *)value
{
  [self willChangeValueForKey:@&ldquo;&lt;#propertyName#>&rdquo;];
  [self setPrimitiveValue:value forKey:@&ldquo;&lt;#propertyName#>&rdquo;];
  [self didChangeValueForKey:@&ldquo;&lt;#propertyName#>&rdquo;];
}
```
现在，我们并不需要知道他们的实现方法是如何被动态生成的，估计是用到了block或者delegate。</li>
</ul>


<h2>探究Core Data在SQLite中的实现</h2>

<p>在上一节中我们创建了<code>Person</code>，<code>Teacher</code>和<code>Student</code>三个Entity和对应的<code>NSManagedObject</code>子类，下面我们需要在代码中对其进行“实战部署”，并观察它们是如何在SQLite数据库中保存的，这样更有利于理解Core Data机制。</p>

<p>为了简单测试，我直接在MasterViewController.m文件中的<code>insertNewObject:</code>方法中加入测试代码（其实关于测试应该利用好Xcode自带的单元测试工具<a href="http://yulingtianxia.com/blog/2014/04/28/iosdan-yuan-ce-shi-%5Bnil%5Dxctest/">XCTest</a>，我这里为了方便操作，用了以前添加数据的<code>insertNewObject:</code>方法，关于工程初始代码的讲解，请看我之前的一篇<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">教程</a>）</p>

<p>```
&ndash; (void)insertNewObject:(id)sender
{</p>

<pre><code>NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
NSEntityDescription *entity = [[self.fetchedResultsController fetchRequest] entity];
Event *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];

// If appropriate, configure the new managed object.
// Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
</code></pre>

<p>//    [newManagedObject setValue:[NSDate date] forKey:@&ldquo;timeStamp&rdquo;];</p>

<pre><code>newManagedObject.timeStamp = [NSDate date];
//新加的测试代码
Student *aStudent = [NSEntityDescription insertNewObjectForEntityForName:@"Student" inManagedObjectContext:context];
aStudent.name = @"LiLei";
aStudent.sex = @"male";
aStudent.grade = @1;
Teacher *aTeacher = [NSEntityDescription insertNewObjectForEntityForName:@"Teacher" inManagedObjectContext:context];
aTeacher.name = @"MissGao";
aTeacher.sex = @"female";
aTeacher.course = @"English";
[aTeacher addStudentsObject:aStudent];


// Save the context.
NSError *error = nil;
if (![context save:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}
</code></pre>

<p>}
```</p>

<p>我们建立了一名叫LiLei的一年级男生和一名叫MissGao的教英语的女教师，并将LiLei同学添加到高老师的学生名单中。</p>

<p>运行程序，打开MyCDDemo.sqlite文件，查看表结构：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353403982.png" alt="" /></p>

<p>你会发现虽然Student和Teacher继承Person，但是Person表里面竟然也有grade和course字段</p>

<p>点击程序中的加号来添加一条数据：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353403912.png" alt="" /></p>

<p>查看ZPERSON，Z_3TEACHERS，Z_PRIMARYKEY表内容：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353404264.png" alt="" /></p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353404745.png" alt="" /></p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353405697.png" alt="" /></p>

<p>这次一目了然了：</p>

<p>ZPERSON表存储了子类所有字段数据，其Z_ENT字段标志着这条数据的类型，Z_ENT与类型名Z_NAME的映射关系储存在Z_PRIMARYKEY表中，而Z_3TEACHERS存储的则是ZPERSON表中数据项之间的关系，也就是之前我们建立的学生和老师的对应关系，其原理是将ZPERSON表中的Z_PK字段内容两个一组对应起来，这样就相当于把ZPERSON表中两条数据项关联起来了。之前我们在代码中只将LiLei同学添加到了MissGao老师的学生列表中，但是Core Data已经自动维护起了关系，让MissGao也存在于LiLei的老师列表中。Core Data把底层的数据库封装起来，通过简单的操作让程序员更高校的管理数据，所以SQLite这部分我们只是了解下就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Core Data(1)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/"/>
    <updated>2014-05-01T19:58:00+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1</id>
    <content type="html"><![CDATA[<p>本文内容：</p>

<ul>
<li>Core Data概述</li>
<li>新建一个Core Data工程</li>
<li>总结</li>
</ul>


<hr />

<!--more-->


<h2>Core Data概述</h2>

<p>Core Data本身既不是数据库也不是数据库访问框架。相反，Core Data是一个完整的数据模型解决方案。我简单理解为对持久层的封装，使得我们可以通过可视化建立数据模型，简化数据存取。有人会联想到Hibernate，其实Core Data比Hibernate强大得多，它不仅支持SQLite数据库，还能对XML文件、二进制文件、用户自定义文件进行操作。</p>

<p>即使不懂SQL语句，也依然可以使用Core Data。因为Core Data将底层的数据库SQL语句封装成了一套API，并可通过可视化操作来建立数据库的模型和表之间的关系，它甚至在数据变化时会帮你自动处理关系（比如删除了一门课程，所有选这门课程的学生也会自动解除与此门课程的关系），Core Data还能对非法数据进行过滤，还支持对数据操作的Undo/Redo功能。更重要的是，Core Data的<code>NSFetchRequest</code>类可以替代SQL中的Select语句，并提供了更高效的方法将查询结果显示在UITableView中。</p>

<p>iOS 3.0和Mac OS X10.5都支持Core Data，但iOS上不支持XML文件存储。Core Data对读取性能做了大量优化，其中惰性加载（Faulting）就是一个例子，毕竟设备的内存是有限切珍贵的。<br/>
在OSX上可以绑定利用KVO和KVC保持UI项与模型对象或属性之间的连接，无需编写任何代码，通过对象和数组控制器自动从Core Data存储区分批提取<code>NSManagedObject</code>对象。这就像在VS中用.Net构建基于SQLServer的桌面程序。<br/>
苹果公司单独为iOS平台的Core Data引入了<code>NSFetchedResultsController</code>类帮助视图与从持久化存储文件提取的数据之间的交互。它主要是用来充当<code>UITableiView</code>的数据源，负责调整<code>UITableiView</code>行与节（section）的显示数目，以及为各表格行提供内容。</p>

<h2>新建一个Core Data工程</h2>

<p>在Xcode5中，只有Master-Detail Application，Utility Application以及Empty Application支持创建时使用Core Data模板，我们选择带有UITableView的Master-Detail Application吧。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/14035339677.png" alt="" /></p>

<p>一定要勾选Core Data选项，项目名称就叫MyCDDemo吧，嘿嘿</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353396978.png" alt="" /></p>

<p>项目建立后会发现Frameworks中已经有了<code>CoreData.framework</code>一项，并且还多了一个MyCDDemo.xcdatamodeld文件，该文件定义了数据模型结构，你可以使用XCode内置的可视化建模工具进行构建。点开它你会发现左侧有三项：Entities，Fetch Request、Configurations。</p>

<p><strong>Entities</strong></p>

<p>在系统的学习Core Data前，可以简单的将Entity理解为数据库中的一张表，在代码中一个<code>NSEntityDescription</code>类的对象就代表了一个Entity。Entity也像类一样可以继承，如果你有若干个相似的实体，就可以抽离出它们的共有特性作为一个“父实体”，就省去了在多个实体中都指定相同的属性。甚至可以勾选Abstract Entitiy让其成为抽象实体，就像抽象类一样。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353414584.png" alt="" /></p>

<p>现在已经有了一个现成的实体：Event，也就是在SQLite中有了一张叫做Event的表：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353397403.png" alt="" /></p>

<p>Attributes就相当于一张表的列属性，可以设置其数据类型，默认值，最大最小值等，类似数据库可视化建表。需要注意的是这里的空值是NULL，不等同于OC中的nil，更不等同于0和空字符串@“”。Event实体中已经有了一个叫timeStamp的属性，类型为Date，这是模版自动生成的，暂且别修改它。</p>

<p>Relationships描述了Entity间的关系：多对一，一对一等。当你指定了一个关系后，苹果推荐我们也指定一个反转关系。比如A和B是多对多的关系，那么A指向B的关系Type为To Many，同时设定B指向A的关系Type为To Many。</p>

<p>Fetched Property表示了一种弱的、单向的关系。因为Core Data不支持在persistent store之间建立Relationships，所以Fetched Property可用于建立cross-store关系，还用于建立“松耦合”关系，相似暂时的分组。（a fetched property of a department might be &ldquo;recent hires&rdquo; (employees do not have an inverse to the recent hires relationship)）</p>

<p><strong>Fetch Request</strong></p>

<p>我们使用<code>NSFetchRequest</code>类来描述数据请求，利用数据请求从持久存储（persistent store）中获取对象。经常碰到的情形是你经常需要多次执行同样的请求，或是执行遵循一个给定模式的请求，但是其中包含变量（如查找条件）——这些变量经常由用户提供。例如，在运行程序的时候，你要根据用户需要获取某个作者在用户指定日期后出版的所有出版物。</p>

<p>你可以预定义请求，把它们作为模板存储在被管理对象模型中。预定义的模板在你需要的时候就可以取出使用。通常情况下，我们通过Xcode的data modeling tool工具创建请求模板。模板可以包含变量：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353412465.png" alt="" /></p>

<p><strong>Configurations</strong></p>

<p>配置包含了一个名称和若干个相关的实体。实体的集合是可以重叠的——这就是说，一个实体可以出现在多个配置中。在代码中，我们使用<code>setEntities: forConfiguration:</code>的方法来指定配置。也可以用Xcode的建模工具来指定。要获取某项配置的实体，需要用<code>entitiesForConfiguration:</code>的方法。</p>

<p>一般说来，如果你想把不同的实体存放在不同的存储中去，就可能用到配置。一个持久化存储协调器（persistent store coordinator，你暂且理解为负责数据库连接的东东）只能有一个被管理对象模型（managed object model，也就是把xcdatamodeld文件加载到代码中的内容啦）。所以，默认情况下，和协调器关联的某个存储必须包含同样的实体。要想绕过这个限制，你可以创建一个包含所有实体并集的模型，然后在模型中为每一个你想使用的实体子集创建配置，这样一来，使用这个模型创建协调器，当你需要添加存储（persistent store）时，可根据不同的配置来指定对应的存储属性。当你创建配置的时候，需要记住，不能创建跨存储的关系（cross-store relationships）。</p>

<p>模版已经生成了一个叫Default的配置，但是在程序中并没有用到它（这在之后的内容会阐述）。</p>

<p>在了解了xcdatamodeld类型文件之后，你可能对Core Data如何描述一个数据库有了一定的概念，下一步我们准备阅读模版自动生成的代码，你会体会到xcdatamodeld文件在程序中是如何被加载和使用的。</p>

<p>先看看AppDelegate.h</p>

<p>``` objc</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface AppDelegate : UIResponder <UIApplicationDelegate></p>

<p>@property (strong, nonatomic) UIWindow *window;</p>

<p>@property (readonly, strong, nonatomic) NSManagedObjectContext <em>managedObjectContext;
@property (readonly, strong, nonatomic) NSManagedObjectModel </em>managedObjectModel;
@property (readonly, strong, nonatomic) NSPersistentStoreCoordinator *persistentStoreCoordinator;</p>

<ul>
<li>(void)saveContext;</li>
<li>(NSURL *)applicationDocumentsDirectory;</li>
</ul>


<p>@end
```
嗯，比平时的程序多出了三个属性嘛，而且后两个属性之前还提到过，这“三剑客“是Core Data中非常重要的三个类：</p>

<ul>
<li>Managed Object Model（管理数据模型）: 你可以将这个东西看作是数据库的轮廓，或者结构。这里包含了各个实体的定义信息，一般来说，你会使用我们刚刚看过的视觉编辑器来操作这个物体，添加属性，建立属性之间的关系等等，当然你也可以使用代码。</li>
<li>Persistent Store Coordinator （持久性数据协调器）： 你可以将这个东西看作是数据库连接库，在这里，你将设置数据存储的名字和位置，以及数据存储的时机。</li>
<li>Managed Object Context （管理数据内容）：你可以将这一部分看作是数据的实际内容，这也是整个数据库中对我们而言最重要的部分（这还用说），基本上，插入数据，查询数据，删除数据的工作都在这里完成。</li>
</ul>


<p>如果你还是不好理解，那么简单的把这“三剑客”理解为：数据定义语言 (DDL)、数据库连接（DBC）、数据操作语言 (DML)在Core Data中的另一种存在吧！</p>

<p>下面该看看AppDelegate.m，了解下“三剑客”实例化的过程：
首先是程序加载完毕的代理方法：</p>

<p>```
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>// Override point for customization after application launch.
UINavigationController *navigationController = (UINavigationController *)self.window.rootViewController;
MasterViewController *controller = (MasterViewController *)navigationController.topViewController;
controller.managedObjectContext = self.managedObjectContext;
return YES;
</code></pre>

<p>}
<code>``
我们暂且只看</code>controller.managedObjectContext = self.managedObjectContext;<code>这句，调用</code>managedObjectContext<code>的getter方法并赋给程序启动后出现的</code>MasterViewController<code>，那么我们就看一下</code>managedObjectContext`的getter方法：</p>

<p>```
// Returns the managed object context for the application.
// If the context doesn&rsquo;t already exist, it is created and bound to the persistent store coordinator for the application.
&ndash; (NSManagedObjectContext *)managedObjectContext
{</p>

<pre><code>if (_managedObjectContext != nil) {
    return _managedObjectContext;
}

NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];
if (coordinator != nil) {
    _managedObjectContext = [[NSManagedObjectContext alloc] init];
    [_managedObjectContext setPersistentStoreCoordinator:coordinator];
}
return _managedObjectContext;
</code></pre>

<p>}
```</p>

<p>嗯，英文注释不错，第一次调用的时候会实例化一个<code>NSManagedObjectContext</code>对象，并使用<code>persistentStoreCoordinator</code>方法返回的<code>NSPersistentStoreCoordinator</code>对象配置上下文，最后返回新实例化的<code>NSManagedObjectContext</code>对象。<br/>
顺藤摸瓜，我们再看看<code>persistentStoreCoordinator</code>的getter：</p>

<p>```
// Returns the persistent store coordinator for the application.
// If the coordinator doesn&rsquo;t already exist, it is created and the application&rsquo;s store added to it.
&ndash; (NSPersistentStoreCoordinator *)persistentStoreCoordinator
{</p>

<pre><code>if (_persistentStoreCoordinator != nil) {
    return _persistentStoreCoordinator;
}

NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@"MyCDDemo.sqlite"];

NSError *error = nil;
_persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];
if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&amp;error]) {
    /*
     Replace this implementation with code to handle the error appropriately.

     abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 

     Typical reasons for an error here include:
     * The persistent store is not accessible;
     * The schema for the persistent store is incompatible with current managed object model.
     Check the error message to determine what the actual problem was.


     If the persistent store is not accessible, there is typically something wrong with the file path. Often, a file URL is pointing into the application's resources directory instead of a writeable directory.

     If you encounter schema incompatibility errors during development, you can reduce their frequency by:
     * Simply deleting the existing store:
     [[NSFileManager defaultManager] removeItemAtURL:storeURL error:nil]

     * Performing automatic lightweight migration by passing the following dictionary as the options parameter:
     @{NSMigratePersistentStoresAutomaticallyOption:@YES, NSInferMappingModelAutomaticallyOption:@YES}

     Lightweight migration will only work for a limited set of schema changes; consult "Core Data Model Versioning and Data Migration Programming Guide" for details.

     */
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}    

return _persistentStoreCoordinator;
</code></pre>

<p>}
<code>``
为了访问documents目录中的SQLite存储文件MyCDDemo.sqlite，还定义了一个</code>applicationDocumentsDirectory`方法，它的作用是获取程序documents的路径，代码如下：</p>

<p>```
// Returns the URL to the application&rsquo;s Documents directory.
&ndash; (NSURL *)applicationDocumentsDirectory
{</p>

<pre><code>return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];
</code></pre>

<p>}
<code>``
MyCDDemo.sqlite文件是在编译MyCDDemo.xcdatamodeld时生成的，同样生成的还有MyCDDemo.momd文件，后面会提到。
</code>NSPersistentStoreCoordinator<code>初始化时需要传入</code>managedObjectModel<code>。</code>NSPersistentStoreCoordinator<code>对象在添加持久存储的时候不仅需要传入存储类型，还有配置，存储文件URL，选项以及错误类型。我们使用sqlite作为存储类型，配置为nil，还记得之前叫做default的配置么？这里我们只有一个持久存储，所以配置一项不需要。如果添加存储的时候出现错误，就会进入if判断，具体处理错误的细节可以看看模版生成的注释。  
既然</code>NSPersistentStoreCoordinator<code>又用到了</code>managedObjectModel<code>，我们再看看</code>managedObjectModel`方法吧：</p>

<p>```
// Returns the managed object model for the application.
// If the model doesn&rsquo;t already exist, it is created from the application&rsquo;s model.
&ndash; (NSManagedObjectModel *)managedObjectModel
{</p>

<pre><code>if (_managedObjectModel != nil) {
    return _managedObjectModel;
}
NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@"MyCDDemo" withExtension:@"momd"];
_managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
return _managedObjectModel;
</code></pre>

<p>}
<code>``
依然是跟之前一样的代码风格，这次</code>NSManagedObjectModel`类在初始化的时候用到了MyCDDemo.momd文件，前面提到过，当你编译项目时，MyCDDemo.xcdatamodeld数据模型将被编译成MyCDDemo.momd资源，并且保存到app的Bundle目录。</p>

<p>最后，在程序退出时，会调用代理<code>applicationWillTerminate:</code></p>

<p>```
&ndash; (void)applicationWillTerminate:(UIApplication *)application
{</p>

<pre><code>// Saves changes in the application's managed object context before the application terminates.
[self saveContext];
</code></pre>

<p>}
<code>``
它调用了</code>saveContext`方法：</p>

<p>```
&ndash; (void)saveContext
{</p>

<pre><code>NSError *error = nil;
NSManagedObjectContext *managedObjectContext = self.managedObjectContext;
if (managedObjectContext != nil) {
    if ([managedObjectContext hasChanges] &amp;&amp; ![managedObjectContext save:&amp;error]) {
         // Replace this implementation with code to handle the error appropriately.
         // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
        NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
        abort();
    } 
}
</code></pre>

<p>}
<code>``
</code>managedObjectContext<code>对象中的数据无论怎么修改，都是发生在内存中的，需要调用</code>save`方法来保存到存储文件当中。</p>

<p>按理说接下来应该看看<code>MasterViewController中</code>被传入的<code>managedObjectContext</code>对象是如何使用的，但在这之前，我们先运行下程序，看看这个App有什么功能：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353397837.png" alt="" /></p>

<p>再普通不过的tableview了，点击加号便可添加一条记录，内容为时间戳，回想起之前看的名称为Event的Entity，是不是想起了什么，嘿嘿。再添加了四条记录后，不妨打开sqlite文件查看下，路径为<code>~/Library/Application Support/iPhone Simulator/[OS version]/Applications/[appGUID]/Documents/</code>，目录内包含了三个文件MyCDDemo.sqlite、MyCDDemo.sqlite-shm、MyCDDemo.sqlite-wal。如上文所述，根据AppDelegate.m文件中的<code>persistentStoreCoordinator</code>方法可知，时间戳记录被存储在MyCDDemo.sqlite文件中。我用Navicat Premium将其打开：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/14035339876.png" alt="" /></p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353398727.png" alt="" /></p>

<p>相信你对“三剑客”有了更深的理解，再附上一张图加深下印象：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353388879.png" alt="" /></p>

<p>一个<code>NSManagedObjectModel</code>对象处在<code>NSPersistentStoreCoordinator</code>对象和<code>NSManagedObjectContext</code>对象之间。Core Data根据<code>NSManagedObjectModel</code>对象确定如何将底层的持久化文件中的数据映射为<code>NSManagedObject</code>对象。一个<code>NSManagedObjectModel</code>对象用于表示数据的结构。<code>NSManagedObjectModel</code>对象也被称为对象图(object graph)。你可以简单的理解为：<strong>在数据库sqlite文件中，一张表中的一条数据（table row）就相当于代码中的一个NSManagedObject对象，他们之间的映射是通过<code>NSManagedObjectModel</code>对象完成的</strong></p>

<p>下面让我们进入到<code>MasterViewController</code>中来认识一下这个新出现的<code>NSManagedObject</code>“小弟”</p>

<p>既然数据库中的数据最终显示在了<code>UITableView</code>上，我们撇开<code>MasterViewController</code>中其他的方法，直奔<code>UITableViewDataSource</code>协议中已经实现的那几个方法：</p>

<p>```
&ndash; (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{</p>

<pre><code>return [[self.fetchedResultsController sections] count];
</code></pre>

<p>}</p>

<ul>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
  id <NSFetchedResultsSectionInfo> sectionInfo = [self.fetchedResultsController sections][section];
  return [sectionInfo numberOfObjects];
}</p></li>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
  UITableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:@&ldquo;Cell&rdquo; forIndexPath:indexPath];
  [self configureCell:cell atIndexPath:indexPath];
  return cell;
}</p></li>
<li><p>(BOOL)tableView:(UITableView <em>)tableView canEditRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  // Return NO if you do not want the specified item to be editable.
  return YES;
}</p></li>
<li><p>(void)tableView:(UITableView <em>)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  if (editingStyle == UITableViewCellEditingStyleDelete) {
      NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
      [context deleteObject:[self.fetchedResultsController objectAtIndexPath:indexPath]];</p>

<pre><code>  NSError *error = nil;
  if (![context save:&amp;error]) {
       // Replace this implementation with code to handle the error appropriately.
       // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
      NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
      abort();
  }
</code></pre>

<p>  } <br/>
}</p></li>
<li><p>(BOOL)tableView:(UITableView <em>)tableView canMoveRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  // The table view should not be re-orderable.
  return NO;
}
```</p></li>
</ul>


<p>如果你对<code>UITableView</code>的使用很有经验，一眼就可看出数据是由<code>fetchedResultsController</code>对象提供的。即使在<code>tableView: cellForRowAtIndexPath:</code>方法中没出现<code>fetchedResultsController</code>，但是在其调用的<code>configureCell: atIndexPath:</code>方法中依然用到了<code>fetchedResultsController</code>：</p>

<p>```
&ndash; (void)configureCell:(UITableViewCell <em>)cell atIndexPath:(NSIndexPath </em>)indexPath
{</p>

<pre><code>NSManagedObject *object = [self.fetchedResultsController objectAtIndexPath:indexPath];
cell.textLabel.text = [[object valueForKey:@"timeStamp"] description];
</code></pre>

<p>}
```
嗯看来NSManagedObject对象全都由这个fetchedResultsController提供咯，下面揭开它神秘的面纱：</p>

<p>```
&ndash; (NSFetchedResultsController *)fetchedResultsController
{</p>

<pre><code>if (_fetchedResultsController != nil) {
    return _fetchedResultsController;
}

NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
// Edit the entity name as appropriate.
NSEntityDescription *entity = [NSEntityDescription entityForName:@"Event" inManagedObjectContext:self.managedObjectContext];
[fetchRequest setEntity:entity];

// Set the batch size to a suitable number.
[fetchRequest setFetchBatchSize:20];

// Edit the sort key as appropriate.
NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"timeStamp" ascending:NO];
NSArray *sortDescriptors = @[sortDescriptor];

[fetchRequest setSortDescriptors:sortDescriptors];

// Edit the section name key path and cache name if appropriate.
// nil for section name key path means "no sections".
NSFetchedResultsController *aFetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedObjectContext sectionNameKeyPath:nil cacheName:@"Master"];
aFetchedResultsController.delegate = self;
self.fetchedResultsController = aFetchedResultsController;

NSError *error = nil;
if (![self.fetchedResultsController performFetch:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}

return _fetchedResultsController;
</code></pre>

<p>}
```</p>

<p>嗯，之前提到过，Core Data在iOS平台使用了<code>NSFetchedResultsController</code>对象来简化对提取结果和表格视图的处理。<code>NSFetchedResultsController</code>对象被惰性创建并只在表格视图数据源方法有需要时才提取数据。你会看到在<code>NSFetchRequest</code>对象的配置中，使用了Event实体，并提供了一个<code>NSSortDescriptor</code>对象以让提取结果按timeStamp进行排序。最后通过<code>NSFetchRequest</code>对象和<code>managedObjectContext</code>（在AppDelegate中传入的<code>NSManagedObjectContext</code>实例）作为参数传入<code>NSFetchedResultsController</code>的初始化方法。（<code>sectionNameKeyPath</code>参数传入nil时表示只有一个section，你会发现<code>NSFetchedResultsController</code>从数据库获取的结果跟<code>UITableView</code>需要的数据格式相同，都通过<code>NSIndexPath</code>地址来获取一条数据的内容）<br/>
<code>NSFetchedResultsController</code>也有它的代理，将<code>MasterViewController</code>设置为其代理，这样在fetched results 发生变化时，<code>MasterViewController</code>中实现的<code>NSFetchedResultsControllerDelegate</code>方法会被调用：</p>

<p>```
&ndash; (void)controllerWillChangeContent:(NSFetchedResultsController *)controller
{</p>

<pre><code>[self.tableView beginUpdates];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)controller:(NSFetchedResultsController *)controller didChangeSection:(id <NSFetchedResultsSectionInfo>)sectionInfo
         atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type
{
  switch(type) {
      case NSFetchedResultsChangeInsert:
          [self.tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade];
          break;</p>

<pre><code>  case NSFetchedResultsChangeDelete:
      [self.tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade];
      break;
</code></pre>

<p>  }
}</p></li>
<li><p>(void)controller:(NSFetchedResultsController <em>)controller didChangeObject:(id)anObject
     atIndexPath:(NSIndexPath </em>)indexPath forChangeType:(NSFetchedResultsChangeType)type
    newIndexPath:(NSIndexPath <em>)newIndexPath
{
  UITableView </em>tableView = self.tableView;</p>

<p>  switch(type) {
      case NSFetchedResultsChangeInsert:
          [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
          break;</p>

<pre><code>  case NSFetchedResultsChangeDelete:
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      break;

  case NSFetchedResultsChangeUpdate:
      [self configureCell:[tableView cellForRowAtIndexPath:indexPath] atIndexPath:indexPath];
      break;

  case NSFetchedResultsChangeMove:
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
      break;
</code></pre>

<p>  }
}</p></li>
<li><p>(void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
  [self.tableView endUpdates];
}</p></li>
</ul>


<p>/*
// Implementing the above methods to update the table view in response to individual changes may have performance implications if a large number of changes are made simultaneously. If this proves to be an issue, you can instead just implement controllerDidChangeContent: which notifies the delegate that all section and object changes have been processed.</p>

<ul>
<li>(void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
 // In the simplest, most efficient, case, reload the table view.
 [self.tableView reloadData];
}</li>
</ul>


<p>```</p>

<p>相对于之前<code>UITableViewDataSource</code>协议方法对<code>NSFetchedResultsController</code>对象中数据的修改（通过<code>NSManagedObject</code>对象做载体），<code>NSFetchedResultsControllerDelegate</code>协议方法会在察觉到数据修改后被调用，用于产生tableview操作数据后对应的动画效果。</p>

<p>可能你会觉得有些混乱，这里贴上几张图梳理下各个类的关系和结构：</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353388301.png" alt="" /></p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353389167.png" alt="" /></p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353388423.png" alt="" /></p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353389646.png" alt="" /></p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353389047.png" alt="" /></p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353388523.jpg" alt="" /></p>

<p>最后，找到<code>insertNewObject</code>方法，当用户尝试加入一个对象到表视图时，该方法将被调用。接着你将看到如下的处理过程：</p>

<ul>
<li>获得一个<code>NSManagedObjectContext</code>对象；</li>
<li>决定创建新对象的实体；</li>
<li>根据实体名称创建一个新的<code>NSManagedObject</code>对象并将其插入到<code>NSManagedObjectContext</code>对象；</li>
<li>对新创建的<code>NSManagedObject</code>对象设置timeStamp属性值</li>
<li><code>NSManagedObjectContext</code>对象执行保存。</li>
</ul>


<p>当上下文执行保存，新的对象将被写到持久存储区中。这是如此简单！</p>

<p>DetailViewController的内容比较简单，不在叙述，到此结束，新建Core Data的模版工程代码已经解析完毕了。在下一期文章中将会亲手修改代码，探索Core Data更多的使用技巧。</p>

<h2>总结</h2>

<p>Core Data框架基本的5个类：：NSPersistentStoreCoordinator、NSManagedObjectContext、NSManagedObjectModel、NSEntityDescription、NSManagedObject。</p>

<ul>
<li><p>NSPersistentStoreCoordinator持久化存储协调器（简称协调器）：负责从磁盘加载数据和将数据写入磁盘。协调器可以处理多种格式的数据库文件（NSPersistentStore），如二进制文件，XML文件、SQLite文件。你也可以实现自己的数据库文件格式（使用NSAtomicStore和NSIncrementalStore类），理论上你可以实现打开World或Photoshop文件的协调器。</p></li>
<li><p>NSEntityDescription实体描述（简称实体）：实体可以被看做是NSManagedObject对象的“class”。实体定义了一个NSManagedObject对象所拥有的所有属性（NSAttributeDescription）,关系（NSRelationshipDescription），提取属性（NSFetchedPropertyDescription）。</p></li>
<li><p>NSManagedObjectContext托管对象上下文（简称上下文）：上下文是内存中的一块暂存区域。查询对象（使用NSFetchRequest），创建对象，删除对象等操作都是在上下文中进行。在上下文没有保存之前，对数据的任何修改都只记录在暂存区中，不会影响磁盘上的数据。你可以创建多个上下文，但整个程序只能创建一个NSPersstentStoreCoordinator对象。</p></li>
<li><p>NSManagedObject托管对象：Core Data的核心单元。模型对象的数据被持有在NSManagedObject对象中。每一个NSManagedObject对象都对应一个实体（就像每一个对象都有一个类）</p></li>
<li><p>NSManagedObjectModel托管对象模型：NSManagedObjectModel通常被定义在一个.mom文件中，文件中保存了所有实体的定义。NSManagedObjectModel and the NS*Description 类完整定义了Core Data模型应该/可以包含的内容。</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
