<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Objective-C | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/objective-c/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-05-10T17:41:39+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[装饰者模式]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi/"/>
    <updated>2014-05-10T09:47:05+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>

<p><img src="/images/blog/QQ20140510-1@2x.png" alt="" /></p>

<!--more-->


<ul>
<li>装饰者和被装饰对象有相同的超类型。- 你可以用一个或多个装饰者包装一个对象。- 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合 ,可以用装饰过的对象代替它。- <strong>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。</strong>&ndash; 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。<br/>
<strong>类应该对扩展开放，对修改关闭。</strong></li>
</ul>


<h2>用配置咖啡饮料做例子</h2>

<p>比如，现在有一个饮料类（Beverage），向饮料中添加不同的配料（蒸奶（Steamed Milk）、豆浆（Soy）、摩卡（Mocha，也就是巧克力风味）或覆盖奶泡），就会配制出很多种不同的种类的饮料，其价格也随着添加的配料而变化，饮料店需要计算价格，如果用具体子类继承饮料类并考虑到所有组合的话，将是一个“类爆炸”：<br/>
<img src="/images/blog/QQ20140510-2@2x.png" alt="" /><br/>
更恶心的是，如果某种配料的价格有变化，就必须含有此配料相应的更改一些饮料子类的实现，记住：<strong>类应该对扩展开放，对修改关闭。</strong> <br/>
应用装饰者模式，就像给对象穿衣服一样一层一层将拓展动态的添加上去，灵活多变有弹性<br/>
<img src="/images/blog/QQ20140510-3@2x.png" alt="" /><br/>
下面用Java实现这个例子<br/>
Beverage是一个抽象类，有两个方法：getDescrip-tion()及cost()。  <code>
public abstract class Beverage {String description = "Unknown Beverage";public String getDescription() {return description;}public abstract double cost();}</code> Beverage很简单。让我们也来实现Condiment（配料）抽象类，也就是装饰者类吧：<br/>
<code>
public abstract class CondimentDecorator extends Beverage {public abstract String getDescription();}</code> 必须让Condiment Decorator能够取代Beverage，所以将CondimentDecorator扩展自 Beverage 类<br/>
现在，已经有了基类，让我们开始开始实现一些饮料吧！先从浓缩咖啡（Espresso）开始。别忘了，我们需要为具体的饮料设置描述，而且还必须实现cost()方法。<br/>
<code>
public class Espresso extends Beverage {public Espresso() {description = "Espresso";}public double cost() {return 1.99;}}</code>
其他几种具体的饮料就不写了<br/>
如果你回头去看看装饰者模式的类图，将发现我们已经完成了抽象组件（Beverage），有了具体组件（HouseBlend），也有了抽象装饰者（CondimentDecorator）。现在，我们就来实现具体装饰者。先从摩卡下手：<br/>
<code>
public class Mocha extends CondimentDecorator {Beverage beverage;public Mocha(Beverage beverage) {this.beverage = beverage;}public String getDescription() {return beverage.getDescription() + ", Mocha";}public double cost() {return .20 + beverage.cost();}}</code>
你会发现在装饰者类中，完成了描述和价格的效果添加，也就是完成了拓展<br/>
其他几种配料代码就不写了<br/>
下面进行测试：<br/>
<code>
public class StarbuzzCoffee {public static void main(String args[]) {Beverage beverage = new Espresso();System.out.println(beverage.getDescription()+ " $" + beverage.cost());Beverage beverage2 = new DarkRoast();beverage2 = new Mocha(beverage2);beverage2 = new Mocha(beverage2);beverage2 = new Whip(beverage2);System.out.println(beverage2.getDescription()+ " $" + beverage2.cost());Beverage beverage3 = new HouseBlend();beverage3 = new Soy(beverage3);beverage3 = new Mocha(beverage3);beverage3 = new Whip(beverage3);System.out.println(beverage3.getDescription()+ " $" + beverage3.cost());}}</code></p>

<p>输出结果：</p>

<p><code>
% java StarbuzzCoffeeEspresso $1.99Dark Roast Coffee, Mocha, Mocha, Whip $1.49House Blend Coffee, Soy, Mocha, Whip $1.34%
</code> <br/>
果然是一层套一层吧：<br/>
<img src="/images/blog/QQ20140510-4@2x.png" alt="" /></p>

<h2>Java中的装饰者</h2>

<p>java.io包内的类太多了，简直是……“排山倒海”。你第一次（还有第二次和第三次）看到这些API发出“哇”的惊叹时，放心，你不是唯一受到惊吓的人。现在，你已经知道装饰者模式，这些I/O的相关类对你来说应该更有意义了，因为其中许多类都是装饰者。下面是一个典型的对象集合，用装饰者来将功能结合起来，以读取文件数据：<br/>
<img src="/images/blog/QQ20140510-5@2x.png" alt="" /><br/>
<code>BufferedInputStream</code>及<code>LineNumberInputStream</code>都扩展自<code>FilterInputStream</code>，而<code>FilterInputStream</code>是一个抽象的装饰类。<br/>
<img src="/images/blog/QQ20140510-6@2x.png" alt="" /><br/>
你会发现“输出”流的设计方式也是一样的。你可能还会发现Reader/Writer流（作为基于字符数据的输入输出）和输入流/输出流的类相当类似（虽然有一些小差异和不一致之处，但是相当雷同，所以你应该可以了解这些类）。<br/>
但是JavaAI/O也引出装饰者模式的一个“缺点”：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。但是，现在你已经了解了装饰者的工作原理，以后当使用别人的大量装饰的API时，就可以很容易地辨别出他们的装饰者类是如何组织的，以方便用包装方式取得想要的行为。</p>

<h2>Objective-C类别与装饰模式</h2>

<p>Objective-C中也可以实现基于继承和接口的装饰者模式，但这里介绍的是另一种实现方法：类别<br/>
类别是一个Objective-C的语言功能，通过它可以向类添加行为（方法的接口与实现），而不必进行子类化。通过类别添加的方法对类原有的方法没有不良影响。类别中的方法成为了类的一部分，并可由其子类继承。<br/>
我们可以用类别来实现装饰模式，然而这不是一种严格的实现，它实现了模式的意图，但却是一种变体。由装饰器类别添加的行为是编译时绑定的，虽然Objective-C原本支持动态绑定（应该用方法的哪个实现）。而且装饰器类别实际上没有封装被扩展的类的实例。<br/>
尽管使用类别来实现这个模式跟原始风格有些偏离，但是实现少量的装饰器的时候，它比真正子类的方式更为轻量、更为容易。
这次我们来装饰一张照片，装饰的方法有很多，比如旋转位移变换，阴影。。。<br/>
<img src="/images/blog/QQ20140510-7@2x.png" alt="" /></p>

<p>工程代码可以在<a href="https://github.com/yulingtianxia/Decorator">这里</a>下载</p>

<p>这一方式中有三个类别：UIImage(BaseFilter),UIImage(Transform)和UIImage(Shadow)。从现在起，我把它们分别简称为BaseFilter、Transform和Shadow。BaseFilter定义了几个基本的二维绘图操作，使用当前绘图上下文绘制自己，其他滤镜类别可以使用同样的方法来绘制图像。Transform和Shadow没有继承BaseFilter，但他们属于同一类，因为他们都是UIImage的类别。BaseFilter中定义的方法也能在Transform和Shadow类别中使用，而不必像子类化那样进行继承。</p>

<p>UIImage(BaseFilter)中的方法定义，用户绘制图像，相当于装饰者抽象类，而UIImage则是被装饰的组件:</p>

<p>``` objc</p>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (BaseFilter)
&ndash; (CGContextRef) beginContext
{</p>

<pre><code>CGSize size = [self size];
UIGraphicsBeginImageContextWithOptions(size, NO, 0);
CGContextRef context = UIGraphicsGetCurrentContext();

return context;
</code></pre>

<p>}</p>

<ul>
<li><p>(UIImage *) getImageFromCurrentImageContext
{
  [self drawAtPoint:CGPointZero];</p>

<p>  // Retrieve the UIImage from the current context
  UIImage *imageOut = UIGraphicsGetImageFromCurrentImageContext();</p>

<p>  return imageOut;
}</p></li>
<li><p>(void) endContext
{
  UIGraphicsEndImageContext();
}
@end
<code>
Transform类别定义了一个`imageWithTransform:transform`方法，接受一个转换引用，然后把应用于内部的图像引用，并让它把自己画出来，然后返回变换后的图像：  
</code> #import &ldquo;UIImage+Transform.h&rdquo;</p>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (Transform)</p></li>
<li><p>(UIImage *) imageWithTransform:(CGAffineTransform)transform
{
  CGContextRef context = [self beginContext];</p>

<p>  // setup transformation
  CGContextConcatCTM(context, transform);</p>

<p>  // Draw the original image to the context
  UIImage *imageOut = [self getImageFromCurrentImageContext];</p>

<p>  [self endContext];</p>

<p>  return imageOut;
}
@end
```</p></li>
</ul>


<p>Shadow类别定义了一个<code>imageWithDropShadow</code>方法，向图像的内部引用添加阴影效果，并返回应用效果之后的最终图像。</p>

<p>```</p>

<h1>import &ldquo;UIImage+Shadow.h&rdquo;</h1>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (Shadow)
&ndash; (UIImage *) imageWithDropShadow
{</p>

<pre><code>CGContextRef context = [self beginContext];

// set up shadow
CGSize offset = CGSizeMake (-25,  15);
CGContextSetShadow(context, offset, 20.0);

// Draw the original image to the context
UIImage * imageOut = [self getImageFromCurrentImageContext];

[self endContext];

return imageOut;
</code></pre>

<p>}
@end
```
最后在ViewController中加载图像：</p>

<p>```
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.
UIImage *image = imageView.image;


// create a transformation
CGAffineTransform rotateTransform = CGAffineTransformMakeRotation(-M_PI / 4.0);
CGAffineTransform translateTransform = CGAffineTransformMakeTranslation(-image.size.width / 2.0,
                                                                        image.size.height / 8.0);
CGAffineTransform finalTransform = CGAffineTransformConcat(rotateTransform, translateTransform);
UIImage* finalImage = [[image imageWithTransform:finalTransform] imageWithDropShadow];
[imageView setImage:finalImage];
</code></pre>

<p>}
```</p>

<p>因为类别只能拓展方法，不能在原有类的基础上添加属性，但是我们依然可以通过下面的方式向类中动态添加属性，来弥补类别的不足：</p>

<p>给UIImage添加一个新的title属性<br/>
具体代码如下：<br/>
<code>UIImage+Title.h</code>:</p>

<p><code>
@interface UIImage(Title)
@property(nonatomic, copy) NSString *title;
@end
</code>
<code>UIImage+Title.m</code>:</p>

<p>```</p>

<h1>import &ldquo;UIImage+Title.h&rdquo;</h1>

<p>static char titleKey;</p>

<p>@implementation UIImage(Title)
&ndash; (NSString *)title
{</p>

<pre><code>return objc_getAssociatedObject(self, &amp;titleKey);
</code></pre>

<p>}</p>

<ul>
<li>(void)setTitle:(NSString *)title
{
  objc_setAssociatedObject(self, &amp;titleKey, title, OBJC_ASSOCIATION_COPY);
}
@end
```
可以看到关键是用到了runtime的两个函数：</li>
<li><code>id objc_getAssociatedObject(id object, void *key)</code></li>
<li><code>void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)</code></li>
</ul>


<p>该函数中第一位参数表示目标对象，第三个参数表示要添加的属性，第四个参数设置objc_AssociationPolicy，它有以下几个选项：<code>OBJC_ASSOCIATION_ASSIGN</code>，<code>OBJC_ASSOCIATION_RETAIN</code>，<code>OBJC_ASSOCIATION_COPY</code>，分别对应我们在声明属性时的<code>assign</code>,<code>retain</code>,<code>copy</code>。<br/>
关于第二个参数，key。因为一个对象可以关联多个新的对像，我们需要一个标志来区分他们。所以这个key就起这样的作用。这里的需要的key的地址，不关心它指向谁。</p>

<p>当我们第二次以新的value调用objc_setAssociatedObject时，如果policy是OBJC_ASSOCIATION_ASSIGN，新的value被关联，对原来旧的value没有任何影响。如果policy是OBJC_ASSOCIATION_RETAIN和OBJC_ASSOCIATION_COPY，新的value被关联，旧的value被release。如果想release原来的value又不关联新的value，，可以用objc_setAssociatedObject直接传一个nil做为value的值。</p>

<p>注意不要使用<code>objc_removeAssociatedObjects</code>，因为它用去掉所有的关联的对象。参考资料：<br/>
1. 《iOS设计模式解析》<br/>
2. 《HeadFirst设计模式》<br/>
3. <a href="http://fanliugen.com/?p=460">http://fanliugen.com/?p=460</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Core Data(2)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/"/>
    <updated>2014-05-02T20:17:04+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2</id>
    <content type="html"><![CDATA[<p>本文内容：</p>

<ul>
<li>自定义NSManagedObject</li>
<li>使用数据模型设计器</li>
<li>探究Core Data在SQLite中的实现</li>
</ul>


<p>推荐先阅读上一篇文章：<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a></p>

<p><strong>文章所使用的项目代码可以到<a href="https://github.com/yulingtianxia/MyCDDemo">这里</a>下载</strong></p>

<!--more-->


<h2>自定义NSManagedObject</h2>

<p>在上一篇教程中我们每条数据都是通过<code>NSManagedObject</code>对象装载，通过KVC方式使用<code>valueForKey：</code>方法访问对象属性，但是使用KVC要比使用访问器效率低一点。 只在必要时使用KVC，比如你需要动态选择key或keyPath。</p>

<p><code>objc
[newEmployee setValue:@”Stig” forKey:firstName];
[aDepartment setValue:@1000 forKeyPath:manager.salary];
</code></p>

<p>下面我们将自定义<code>NSManagedObject</code>类，通过对它的继承拓展，使得我们有自己的Event类，并通过访问器方法代替KVC方式来访问对象的属性。<br/>
按CMD+N或者在可视化建模工具下选择菜单中Editor->Create NSManagedObject Subclass：</p>

<p><img src="/images/blog/QQ20140502-1@2x.png" alt="" /></p>

<p><img src="/images/blog/QQ20140502-2@2x.png" alt="" /></p>

<p>选中需要子类化的Entity（当然我们只有一个Event，自动勾选了）：</p>

<p><img src="/images/blog/QQ20140502-3@2x.png" alt="" /></p>

<p>最后点击Create，于是Event类就创建好了，可以看到属性timeStamp已经自动生成了，并且实现为<code>@dynamic</code></p>

<p>熟悉Objective-C语法的都知道<code>@synthesize</code>实际的意义就是自动生成属性的setter和getter方法。</p>

<p><code>@dynamic</code>就是要告诉编译器，代码中用<code>@dynamic</code>修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译。其主要的作用就是用在<code>NSManagerObject</code>对象的属性声明上，由于此类对象的属性一般是从Core Data的属性中生成的，Core Data框架会在程序运行的时候为此类属性生成getter和setter方法。</p>

<p>好的，下面我们改写以前的代码，这次我们将使用Event类的对象完成以前的任务：</p>

<p>在MasterViewController.m文件中加入<code>#import "Event.h"</code>，然后将<code>insertNewObject:</code>方法替换如下</p>

<p>```
&ndash; (void)insertNewObject:(id)sender
{</p>

<pre><code>NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
NSEntityDescription *entity = [[self.fetchedResultsController fetchRequest] entity];
Event *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];

// If appropriate, configure the new managed object.
// Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
</code></pre>

<p>//    [newManagedObject setValue:[NSDate date] forKey:@&ldquo;timeStamp&rdquo;];</p>

<pre><code>newManagedObject.timeStamp = [NSDate date];
// Save the context.
NSError *error = nil;
if (![context save:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}
</code></pre>

<p>}
<code>``
嗯，英文注释还告诉我们通常你应该用访问器方法呢，还说但是现在在这用KVC就避免了向模板添加自定义类的需求，真逗啊  
依此类推，更改</code>prepareForSegue: sender:`方法：</p>

<p>```
&ndash; (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{</p>

<pre><code>if ([[segue identifier] isEqualToString:@"showDetail"]) {
    NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
    Event *object = [[self fetchedResultsController] objectAtIndexPath:indexPath];
    [[segue destinationViewController] setDetailItem:object];
}
</code></pre>

<p>}
```</p>

<p>还有<code>configureCell: atIndexPath:</code>方法：</p>

<p>```
&ndash; (void)configureCell:(UITableViewCell <em>)cell atIndexPath:(NSIndexPath </em>)indexPath
{</p>

<pre><code>Event *object = [self.fetchedResultsController objectAtIndexPath:indexPath];
</code></pre>

<p>//    cell.textLabel.text = [[object valueForKey:@&ldquo;timeStamp&rdquo;] description];</p>

<pre><code>cell.textLabel.text = [object.timeStamp description];
</code></pre>

<p>}
<code>``
相应地我们也可以针对</code>DetailViewController`进行改造：</p>

<p>DetailViewController.h:</p>

<p>```</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@class Event;
@interface DetailViewController : UIViewController</p>

<p>@property (strong, nonatomic) Event *detailItem;</p>

<p>@property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;
@end
```</p>

<p>DetailViewController.m:</p>

<p>```</p>

<h1>import &ldquo;DetailViewController.h&rdquo;</h1>

<h1>import &ldquo;Event.h&rdquo;</h1>

<p>@interface DetailViewController ()
&ndash; (void)configureView;
@end</p>

<p>@implementation DetailViewController</p>

<h1>pragma mark &ndash; Managing the detail item</h1>

<ul>
<li><p>(void)setDetailItem:(Event *)newDetailItem
{
  if (<em>detailItem != newDetailItem) {
      </em>detailItem = newDetailItem;</p>

<pre><code>  // Update the view.
  [self configureView];
</code></pre>

<p>  }
}</p></li>
<li><p>(void)configureView
{
  // Update the user interface for the detail item.</p>

<p>  if (self.detailItem) {
//        self.detailDescriptionLabel.text = [[self.detailItem valueForKey:@&ldquo;timeStamp&rdquo;] description];
      self.detailDescriptionLabel.text = [self.detailItem.timeStamp description];
  }
}</p></li>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];
  // Do any additional setup after loading the view, typically from a nib.
  [self configureView];
}</p></li>
<li><p>(void)didReceiveMemoryWarning
{
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}</p></li>
</ul>


<p>@end
```
这部分比较简单，就不详细解释了，运行程序，跟以前一样（不截图了）</p>

<p>如果想复用<code>MasterViewController</code>里面那些代码，需要做些大改动，具体可以参看<a href="http://objccn.io/issue-1-1/">更轻量的 View Controllers</a>这篇文章</p>

<h2>使用数据模型设计器</h2>

<p>点击MyCDDemo.xcdatamodeld文件进入数据模型设计器，点击下方的加号（Add Enity），添加一个Enity，将其名字改为Person。然后添加name和sex属性，类型为string，需要注意的是属性名需要首字母小写，而且我们无需像往常给数据库建表一样为其添加ID字段，因为Core Data中你不需要任何类型的唯一标识Id，也不需要处理表连接。Core Data将在后台自动处理。你所需要做的就是定义对象间的关系。Core Data框架将在后台决定如何生成最佳的底层机制。</p>

<p>与实体名一样，属性的命名也有很多的要求和约定。属性名不能以大写字母开头，不能包含空格，一般都是单数。对于Boolean类型属性，你应该遵循Objective-C实例变量的约定,比如指定一个CustomerOrder对象是否已经发货，那么应该命名属性为shipped，而不是isShipped、hasShipped等。</p>

<p>关于Core Data属性类型，我从网上摘抄了一段比较全面的解释：</p>

<ul>
<li><p>Undefined选项值是新创建的属性的默认类型；如果属性类型为undefined，项目将无法通过编译。</p></li>
<li><p>Integer 16/32/64只表示整数，没有小数点。所以如果10除以3，你将会得到3，而余数1会丢失。Integer 16/32/64之间唯一的区别是所表示的数值范围不同。因为Core Data使用符号数，所以起始范围是负数，而不是0。</p>

<ul>
<li><p>Integer 16 数值范围：-32768~32767；</p></li>
<li><p>Integer 32 数值范围：-2147483648~2147483647；</p></li>
<li><p>Integer 64 数值范围：–9223372036854775808~9223372036854775807。</p></li>
</ul>


<p>  标准整型数的最大值和最小值可以在stdint.h中找到。在任何类文件中输入INT32_MAX,选中右击，然后选择Jump To Definition，你将看到许多最大值最小值定义。<strong>实体的属性的类型是Integer 16/32/64，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSNumber</strong>。</p></li>
<li><p>Double和Float可以认为是有小数部分的整数。它们都是基于二进制数值系统，在CPU运算时很可能会发生舍入误差。比如1/5，如果使用十进制数值系统，可以精确表示为0.2.但在二进制数值系统中，只能表示一个大概，在小数部分你会得到大量数字。<strong>所以不要使用Integer、Double、Float表示货币值。</strong>计算精度越高则越加趋于准确值，但内存占用也会越大。一个Float数使用32bit进行存储，一个Double数使用64bit。它们都使用科学计数法进行存储，所以一个数包含尾数和指数部分。</p>

<p>  在iOS中，最大的Float值是340282346638528859811704183484516925440.000000，最小的Float值是340282346638528859811704183484516925440.000000Double和Float都有一个符号位。而Double比Float的数值范围更大。</p>

<p>  当你决定该选择Float还是Double时，想一下你的属性是否真的需要超过Float提供的7位精度，如果不是，你应该选择Float，因为它更加匹配64bit的iPhone 5S底层处理器。除此之外，如果你想增加浮点数的计算速度而精度并没有严格要求，Float也是最佳选择。<strong>实体的属性的类型是Float或Double，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSNumber。</strong></p></li>
<li><p><strong>Decimal（十进制）是处理货币值和其他需要十进制场合下最佳选择</strong>，Decimal提供了优秀的计算精度，也消除了计算过程中的舍入误差。因为CPU的本地数制是二进制，所以CPU在处理十进制数时，开销会多一点。<strong>实体的属性的类型是Decimal，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSDecimalNumber。</strong>当你使用NSDecimalNumber执行计算时(如加减乘除计算)，为了保证计算精度，你只能使用它提供的内建方法。更多关于NSDecimalNumber可参见这里。</p></li>
<li><p>String类型和Objective-C中的NSString类似，用于保存字符数组。当生成实体对应的NSManagedObject子类时，String属性被表示为NSString。</p></li>
<li><p>Boolean数据类型被用于表示YES/NO值。当生成实体对应的NSManagedObject子类时，Boolean数据类型会被表示为NSNumber。所以为了获取布尔值，你需要想NSNumber对象发送boolValue消息。</p></li>
<li><p>Date类型是自解释类型。用来存储日期和时间。<strong>当生成实体对应的NSManagedObject子类时，Date类型会被表示为NSDate。</strong></p></li>
<li><p>Binary Data用来表示照片，音频，或一些BLOB类型数据(&ldquo;Binary Large OBjects&rdquo; such as image and sound data)。<strong>当生成实体对应的NSManagedObject子类时，Binary Data数据类型会被表示为NSData。</strong></p></li>
<li><p>Transformable属性类型用于存储一个Objective-C对象。该属性类型允许你存储任何类的实例，比如你使用Transformable属性表示UIColor。<strong>当生成NSManagedObject子类时，Transformable类型会被表示为id。</strong>对于id对象的保存和解档需要使用一个NSValueTransformer的实例或子类的实例。由该类负责属性值与NSData之间的转换。但这也相当的简单，尤其是当属性值的类型已经实现了NSCoding协议，此时系统会自动提供一个默认的NSValueTransformer实例来完成归档和解档。</p></li>
</ul>


<p><img src="/images/blog/QQ20140503-1@2x.png" alt="" /></p>

<p>选择一个属性，在右侧的Data Model Inspector中可以对属性进行更为详细的设置，而且这些设置项会根据你所设置的属性类型不同而不同，大致分为以下几类：</p>

<ul>
<li>Transient（瞬时）选项表示属性不会存储到持久化存储文件中。Transient通常用在属性的值是由其他属性计算或合成而来（比如fullName属性是根据Persion类实例的firstName和lastName拼接而来）。</li>
<li>Optional（可选）选项表示当前属性的值允许为空。如果将属性指定为Optional，那么即使属性的值为空，实体的NSManagedObject实例也可被保存。如果该值是必选的（不选中Optional则为必选），如果属性值为空，NSManagedObject对象上下文将拒绝保存这个属性值不完整的NSManagedObject对象（当你尝试并保存上下文，你将接收到一个NSError对象）。所有的属性最初的状态都是Optinal。</li>
<li>Indexed选项表示底层的持久化存储文件应该为该属性生成一个索引；如果你使用基于多个属性的查询条件来提取对象，指定此类属性为Indexed，可以大幅提高提取速度。</li>
<li>Reg.Ex是Regular Expression的缩写，主要是用来验证属性值是否匹配特定的模式。此选项只对String类型有效。</li>
<li>Validation可以保证非法数据不被保存进持久化存储文件中。数值属性类型（Integer 16/32/64、Float、Double、Decimal）都有maximum和minimum最大值最小值设定。你也可以对String类型设置最大长度和最小长度。或对Date类型设置日期范围。不过最好的做法是当用户向UITextField中输入数据时就开始验证数据，而非等到向上下文发送save消息才验证数据。</li>
<li>除了Transformable和Binary Data类型以外，Default适用于所有属性类型。它被用来配置属性的默认值。</li>
<li>Allows External Storage允许大尺寸的二进制数据可以保存在持久化存储文件的外部。当你保存如照片，音频或视频时，建议是选中该选项， 这样Core Data就会对大于1MB的数据保存在持久化存储文件的外部。</li>
</ul>


<p>如果你细心的话，会发现无论是属性还是实体等选项，右侧的Data Model Inspector经常会出现User Info一栏。<br/>
在managed object model中很多元素，比如entities, attributes,和 relationships，有一个相关联的用户信息字典。你可以在用户信息字典中以键值对的形式放入你想要的任何信息。这里常用的信息有实体的版本详情，还有fetched property中谓词（predicate）用到的值。</p>

<p>说了一大堆，再添加两个实体吧：Teacher和Student，都继承自Person：</p>

<p><img src="/images/blog/QQ20140503-2@2x.png" alt="" /></p>

<p><img src="/images/blog/QQ20140503-3@2x.png" alt="" /></p>

<p>点击右下方的Editor Style切换到Graph模式：</p>

<p><img src="/images/blog/QQ20140503-4@2x.png" alt="" /></p>

<p>选中Teacher，长按Add Attribute会弹出所有的选项（同样你也可以试试长按Add Enity），选择Add Relationship，添加一个关系，命名为students，Type为To Many，目标为Student（一个老师教很多学生）：</p>

<p><img src="/images/blog/QQ20140503-5@2x.png" alt="" /></p>

<p><img src="/images/blog/QQ20140503-6@2x.png" alt="" /></p>

<p>我们再尝试一种添加关系的新方法：把以前在Teacher中建立的students删除，选中Student，按住Ctrl，鼠标拖至Teacher，这样一个双向的关系就建立起来了：</p>

<p><img src="/images/blog/QQ20140503-7@2x.png" alt="" /></p>

<p>分别编辑双方的关系，Tpye都是To Many：</p>

<p><img src="/images/blog/QQ20140503-8@2x.png" alt="" /></p>

<p>用上一节中提到的方法，建立这三个新建的Entity的<code>NSManagedObject</code>子类：</p>

<p><img src="/images/blog/QQ20140503-9@2x.png" alt="" /></p>

<p>因为创建顺序的问题，当Student创建的时候还不知道有<code>Teacher</code>类，于是其生成的一些方法将Teacher默认为<code>NSManagedObject</code>类：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<p>@interface Student : NSManagedObject</p>

<p>@property (nonatomic, retain) NSNumber * grade;
@property (nonatomic, retain) NSSet *teachers;
@end</p>

<p>@interface Student (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addTeachersObject:(NSManagedObject *)value;</li>
<li>(void)removeTeachersObject:(NSManagedObject *)value;</li>
<li>(void)addTeachers:(NSSet *)values;</li>
<li>(void)removeTeachers:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>而Teacher类创建的时候已经有了<code>Student</code>类，就不会出现上面的问题：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<p>@class Student;</p>

<p>@interface Teacher : NSManagedObject</p>

<p>@property (nonatomic, retain) NSString * course;
@property (nonatomic, retain) NSSet *students;
@end</p>

<p>@interface Teacher (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addStudentsObject:(Student *)value;</li>
<li>(void)removeStudentsObject:(Student *)value;</li>
<li>(void)addStudents:(NSSet *)values;</li>
<li>(void)removeStudents:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>虽然<code>Teacher</code>类认识<code>Student</code>类，因为它已经创建了，但是此时Persion类还没有创建，于是此时<code>Student</code>类和<code>Teacher</code>类继承的依然是<code>NSManagedObject</code>，这不是我们想要的结果。<br/>
解决方法是重新生成下这三个Entity对应的<code>NSManagedObject</code>子类，并覆盖原有的文件：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<h1>import &ldquo;Person.h&rdquo;</h1>

<p>@class Teacher;</p>

<p>@interface Student : Person</p>

<p>@property (nonatomic, retain) NSNumber * grade;
@property (nonatomic, retain) NSSet *teachers;
@end</p>

<p>@interface Student (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addTeachersObject:(Teacher *)value;</li>
<li>(void)removeTeachersObject:(Teacher *)value;</li>
<li>(void)addTeachers:(NSSet *)values;</li>
<li>(void)removeTeachers:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>你会发现多了一个<code>CoreDataGeneratedAccessors</code>类别，这个类别中的方法是Core Data框架根据你在数据模式编辑器中设置的实体关系自动生成的，你不需要实现它们，Core Data会在运行时实现这些方法<br/>
如果你偏要想看看其实现机理，在右下方的代码片段库中选择“Core Data To-Many Relationship Accessors”并拖拽到代码中</p>

<p><img src="/images/blog/QQ20140503-10@2x.png" alt="" /></p>

<p>生成的代码如下：</p>

<p>```
&ndash; (void)add&lt;#CapitalizedRelationshipName#>Object:(&lt;#relationship destination class#> *)value
{</p>

<pre><code>NSSet *changedObjects = [NSSet setWithObject:value];
[self willChangeValueForKey:@"&lt;#relationshipName#&gt;" withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects];
[[self primitiveValueForKey:@"&lt;#relationshipName#&gt;"] addObject:value];
[self didChangeValueForKey:@"&lt;#relationshipName#&gt;" withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)remove&lt;#CapitalizedRelationshipName#>Object:(&lt;#relationship destination class#> <em>)value
{
  NSSet </em>changedObjects = [NSSet setWithObject:value];
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] removeObject:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects];
}</p></li>
<li><p>(void)add&lt;#CapitalizedRelationshipName#>:(NSSet *)value
{  <br/>
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueUnionSetMutation usingObjects:value];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] unionSet:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueUnionSetMutation usingObjects:value];
}</p></li>
<li><p>(void)remove&lt;#CapitalizedRelationshipName#>:(NSSet *)value
{
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:value];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] minusSet:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:value];
}
```</p></li>
</ul>


<p>我们需要将&lt;#Capitalized relationship name#>, &lt;#Relationship destination class#> 和 &lt;#Relationship name#>替换为我们定义的连接名，对照下前面<code>CoreDataGeneratedAccessors</code>类别中的方法名，你就会明白了</p>

<p>同样以前标记为<code>@dynamic</code>的属性，其实现原理如下：</p>

<p>```
&ndash; (&lt;#propertyObjectType#> *)&lt;#propertyName#>
{</p>

<pre><code>[self willAccessValueForKey:@"&lt;#propertyName#&gt;"];
&lt;#propertyObjectType#&gt; *value = [self primitiveValueForKey:@"&lt;#propertyName#&gt;"];
[self didAccessValueForKey:@"&lt;#propertyName#&gt;"];
return value;
</code></pre>

<p>}</p>

<ul>
<li>(void)set&lt;#CapitalizedPropertyName#>:(&lt;#propertyObjectType#> *)value
{
  [self willChangeValueForKey:@&ldquo;&lt;#propertyName#>&rdquo;];
  [self setPrimitiveValue:value forKey:@&ldquo;&lt;#propertyName#>&rdquo;];
  [self didChangeValueForKey:@&ldquo;&lt;#propertyName#>&rdquo;];
}
```
现在，我们并不需要知道他们的实现方法是如何被动态生成的，估计是用到了block或者delegate。</li>
</ul>


<h2>探究Core Data在SQLite中的实现</h2>

<p>在上一节中我们创建了<code>Person</code>，<code>Teacher</code>和<code>Student</code>三个Entity和对应的<code>NSManagedObject</code>子类，下面我们需要在代码中对其进行“实战部署”，并观察它们是如何在SQLite数据库中保存的，这样更有利于理解Core Data机制。</p>

<p>为了简单测试，我直接在MasterViewController.m文件中的<code>insertNewObject:</code>方法中加入测试代码（其实关于测试应该利用好Xcode自带的单元测试工具<a href="http://yulingtianxia.com/blog/2014/04/28/iosdan-yuan-ce-shi-%5Bnil%5Dxctest/">XCTest</a>，我这里为了方便操作，用了以前添加数据的<code>insertNewObject:</code>方法，关于工程初始代码的讲解，请看我之前的一篇<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">教程</a>）</p>

<p>```
&ndash; (void)insertNewObject:(id)sender
{</p>

<pre><code>NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
NSEntityDescription *entity = [[self.fetchedResultsController fetchRequest] entity];
Event *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];

// If appropriate, configure the new managed object.
// Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
</code></pre>

<p>//    [newManagedObject setValue:[NSDate date] forKey:@&ldquo;timeStamp&rdquo;];</p>

<pre><code>newManagedObject.timeStamp = [NSDate date];
//新加的测试代码
Student *aStudent = [NSEntityDescription insertNewObjectForEntityForName:@"Student" inManagedObjectContext:context];
aStudent.name = @"LiLei";
aStudent.sex = @"male";
aStudent.grade = @1;
Teacher *aTeacher = [NSEntityDescription insertNewObjectForEntityForName:@"Teacher" inManagedObjectContext:context];
aTeacher.name = @"MissGao";
aTeacher.sex = @"female";
aTeacher.course = @"English";
[aTeacher addStudentsObject:aStudent];


// Save the context.
NSError *error = nil;
if (![context save:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}
</code></pre>

<p>}
```</p>

<p>我们建立了一名叫LiLei的一年级男生和一名叫MissGao的教英语的女教师，并将LiLei同学添加到高老师的学生名单中。</p>

<p>运行程序，打开MyCDDemo.sqlite文件，查看表结构：</p>

<p><img src="/images/blog/QQ20140503-11@2x.png" alt="" /></p>

<p>你会发现虽然Student和Teacher继承Person，但是Person表里面竟然也有grade和course字段</p>

<p>点击程序中的加号来添加一条数据：</p>

<p><img src="/images/blog/QQ20140503-12@2x.png" alt="" /></p>

<p>查看ZPERSON，Z_3TEACHERS，Z_PRIMARYKEY表内容：</p>

<p><img src="/images/blog/QQ20140503-13@2x.png" alt="" /></p>

<p><img src="/images/blog/QQ20140503-14@2x.png" alt="" /></p>

<p><img src="/images/blog/QQ20140503-15@2x.png" alt="" /></p>

<p>这次一目了然了：</p>

<p>ZPERSON表存储了子类所有字段数据，其Z_ENT字段标志着这条数据的类型，Z_ENT与类型名Z_NAME的映射关系储存在Z_PRIMARYKEY表中，而Z_3TEACHERS存储的则是ZPERSON表中数据项之间的关系，也就是之前我们建立的学生和老师的对应关系，其原理是将ZPERSON表中的Z_PK字段内容两个一组对应起来，这样就相当于把ZPERSON表中两条数据项关联起来了。之前我们在代码中只将LiLei同学添加到了MissGao老师的学生列表中，但是Core Data已经自动维护起了关系，让MissGao也存在于LiLei的老师列表中。Core Data把底层的数据库封装起来，通过简单的操作让程序员更高校的管理数据，所以SQLite这部分我们只是了解下就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Core Data(1)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/"/>
    <updated>2014-05-01T19:58:00+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1</id>
    <content type="html"><![CDATA[<p>本文内容：</p>

<ul>
<li>Core Data概述</li>
<li>新建一个Core Data工程</li>
<li>总结</li>
</ul>


<hr />

<!--more-->


<h2>Core Data概述</h2>

<p>Core Data本身既不是数据库也不是数据库访问框架。相反，Core Data是一个完整的数据模型解决方案。我简单理解为对持久层的封装，使得我们可以通过可视化建立数据模型，简化数据存取。有人会联想到Hibernate，其实Core Data比Hibernate强大得多，它不仅支持SQLite数据库，还能对XML文件、二进制文件、用户自定义文件进行操作。</p>

<p>即使不懂SQL语句，也依然可以使用Core Data。因为Core Data将底层的数据库SQL语句封装成了一套API，并可通过可视化操作来建立数据库的模型和表之间的关系，它甚至在数据变化时会帮你自动处理关系（比如删除了一门课程，所有选这门课程的学生也会自动解除与此门课程的关系），Core Data还能对非法数据进行过滤，还支持对数据操作的Undo/Redo功能。更重要的是，Core Data的<code>NSFetchRequest</code>类可以替代SQL中的Select语句，并提供了更高效的方法将查询结果显示在UITableView中。</p>

<p>iOS 3.0和Mac OS X10.5都支持Core Data，但iOS上不支持XML文件存储。Core Data对读取性能做了大量优化，其中惰性加载（Faulting）就是一个例子，毕竟设备的内存是有限切珍贵的。<br/>
在OSX上可以绑定利用KVO和KVC保持UI项与模型对象或属性之间的连接，无需编写任何代码，通过对象和数组控制器自动从Core Data存储区分批提取<code>NSManagedObject</code>对象。这就像在VS中用.Net构建基于SQLServer的桌面程序。<br/>
苹果公司单独为iOS平台的Core Data引入了<code>NSFetchedResultsController</code>类帮助视图与从持久化存储文件提取的数据之间的交互。它主要是用来充当<code>UITableiView</code>的数据源，负责调整<code>UITableiView</code>行与节（section）的显示数目，以及为各表格行提供内容。</p>

<h2>新建一个Core Data工程</h2>

<p>在Xcode5中，只有Master-Detail Application，Utility Application以及Empty Application支持创建时使用Core Data模板，我们选择带有UITableView的Master-Detail Application吧。</p>

<p><img src="/images/blog/QQ20140501-1@2x.png" alt="" /></p>

<p>一定要勾选Core Data选项，项目名称就叫MyCDDemo吧，嘿嘿</p>

<p><img src="/images/blog/QQ20140501-2@2x.png" alt="" /></p>

<p>项目建立后会发现Frameworks中已经有了<code>CoreData.framework</code>一项，并且还多了一个MyCDDemo.xcdatamodeld文件，该文件定义了数据模型结构，你可以使用XCode内置的可视化建模工具进行构建。点开它你会发现左侧有三项：Entities，Fetch Request、Configurations。</p>

<p><strong>Entities</strong></p>

<p>在系统的学习Core Data前，可以简单的将Entity理解为数据库中的一张表，在代码中一个<code>NSEntityDescription</code>类的对象就代表了一个Entity。Entity也像类一样可以继承，如果你有若干个相似的实体，就可以抽离出它们的共有特性作为一个“父实体”，就省去了在多个实体中都指定相同的属性。甚至可以勾选Abstract Entitiy让其成为抽象实体，就像抽象类一样。</p>

<p><img src="/images/blog/xcodeparententity_2x.png" alt="" /></p>

<p>现在已经有了一个现成的实体：Event，也就是在SQLite中有了一张叫做Event的表：</p>

<p><img src="/images/blog/QQ20140501-3@2x.png" alt="" /></p>

<p>Attributes就相当于一张表的列属性，可以设置其数据类型，默认值，最大最小值等，类似数据库可视化建表。需要注意的是这里的空值是NULL，不等同于OC中的nil，更不等同于0和空字符串@“”。Event实体中已经有了一个叫timeStamp的属性，类型为Date，这是模版自动生成的，暂且别修改它。</p>

<p>Relationships描述了Entity间的关系：多对一，一对一等。当你指定了一个关系后，苹果推荐我们也指定一个反转关系。比如A和B是多对多的关系，那么A指向B的关系Type为To Many，同时设定B指向A的关系Type为To Many。</p>

<p>Fetched Property表示了一种弱的、单向的关系。因为Core Data不支持在persistent store之间建立Relationships，所以Fetched Property可用于建立cross-store关系，还用于建立“松耦合”关系，相似暂时的分组。（a fetched property of a department might be &ldquo;recent hires&rdquo; (employees do not have an inverse to the recent hires relationship)）</p>

<p><strong>Fetch Request</strong></p>

<p>我们使用<code>NSFetchRequest</code>类来描述数据请求，利用数据请求从持久存储（persistent store）中获取对象。经常碰到的情形是你经常需要多次执行同样的请求，或是执行遵循一个给定模式的请求，但是其中包含变量（如查找条件）——这些变量经常由用户提供。例如，在运行程序的时候，你要根据用户需要获取某个作者在用户指定日期后出版的所有出版物。</p>

<p>你可以预定义请求，把它们作为模板存储在被管理对象模型中。预定义的模板在你需要的时候就可以取出使用。通常情况下，我们通过Xcode的data modeling tool工具创建请求模板。模板可以包含变量：</p>

<p><img src="/images/blog/variablelikepredicate_2x.png" alt="" /></p>

<p><strong>Configurations</strong></p>

<p>配置包含了一个名称和若干个相关的实体。实体的集合是可以重叠的——这就是说，一个实体可以出现在多个配置中。在代码中，我们使用<code>setEntities: forConfiguration:</code>的方法来指定配置。也可以用Xcode的建模工具来指定。要获取某项配置的实体，需要用<code>entitiesForConfiguration:</code>的方法。</p>

<p>一般说来，如果你想把不同的实体存放在不同的存储中去，就可能用到配置。一个持久化存储协调器（persistent store coordinator，你暂且理解为负责数据库连接的东东）只能有一个被管理对象模型（managed object model，也就是把xcdatamodeld文件加载到代码中的内容啦）。所以，默认情况下，和协调器关联的某个存储必须包含同样的实体。要想绕过这个限制，你可以创建一个包含所有实体并集的模型，然后在模型中为每一个你想使用的实体子集创建配置，这样一来，使用这个模型创建协调器，当你需要添加存储（persistent store）时，可根据不同的配置来指定对应的存储属性。当你创建配置的时候，需要记住，不能创建跨存储的关系（cross-store relationships）。</p>

<p>模版已经生成了一个叫Default的配置，但是在程序中并没有用到它（这在之后的内容会阐述）。</p>

<p>在了解了xcdatamodeld类型文件之后，你可能对Core Data如何描述一个数据库有了一定的概念，下一步我们准备阅读模版自动生成的代码，你会体会到xcdatamodeld文件在程序中是如何被加载和使用的。</p>

<p>先看看AppDelegate.h</p>

<p>``` objc</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface AppDelegate : UIResponder <UIApplicationDelegate></p>

<p>@property (strong, nonatomic) UIWindow *window;</p>

<p>@property (readonly, strong, nonatomic) NSManagedObjectContext <em>managedObjectContext;
@property (readonly, strong, nonatomic) NSManagedObjectModel </em>managedObjectModel;
@property (readonly, strong, nonatomic) NSPersistentStoreCoordinator *persistentStoreCoordinator;</p>

<ul>
<li>(void)saveContext;</li>
<li>(NSURL *)applicationDocumentsDirectory;</li>
</ul>


<p>@end
```
嗯，比平时的程序多出了三个属性嘛，而且后两个属性之前还提到过，这“三剑客“是Core Data中非常重要的三个类：</p>

<ul>
<li>Managed Object Model（管理数据模型）: 你可以将这个东西看作是数据库的轮廓，或者结构。这里包含了各个实体的定义信息，一般来说，你会使用我们刚刚看过的视觉编辑器来操作这个物体，添加属性，建立属性之间的关系等等，当然你也可以使用代码。</li>
<li>Persistent Store Coordinator （持久性数据协调器）： 你可以将这个东西看作是数据库连接库，在这里，你将设置数据存储的名字和位置，以及数据存储的时机。</li>
<li>Managed Object Context （管理数据内容）：你可以将这一部分看作是数据的实际内容，这也是整个数据库中对我们而言最重要的部分（这还用说），基本上，插入数据，查询数据，删除数据的工作都在这里完成。</li>
</ul>


<p>如果你还是不好理解，那么简单的把这“三剑客”理解为：数据定义语言 (DDL)、数据库连接（DBC）、数据操作语言 (DML)在Core Data中的另一种存在吧！</p>

<p>下面该看看AppDelegate.m，了解下“三剑客”实例化的过程：
首先是程序加载完毕的代理方法：</p>

<p>```
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>// Override point for customization after application launch.
UINavigationController *navigationController = (UINavigationController *)self.window.rootViewController;
MasterViewController *controller = (MasterViewController *)navigationController.topViewController;
controller.managedObjectContext = self.managedObjectContext;
return YES;
</code></pre>

<p>}
<code>``
我们暂且只看</code>controller.managedObjectContext = self.managedObjectContext;<code>这句，调用</code>managedObjectContext<code>的getter方法并赋给程序启动后出现的</code>MasterViewController<code>，那么我们就看一下</code>managedObjectContext`的getter方法：</p>

<p>```
// Returns the managed object context for the application.
// If the context doesn&rsquo;t already exist, it is created and bound to the persistent store coordinator for the application.
&ndash; (NSManagedObjectContext *)managedObjectContext
{</p>

<pre><code>if (_managedObjectContext != nil) {
    return _managedObjectContext;
}

NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];
if (coordinator != nil) {
    _managedObjectContext = [[NSManagedObjectContext alloc] init];
    [_managedObjectContext setPersistentStoreCoordinator:coordinator];
}
return _managedObjectContext;
</code></pre>

<p>}
```</p>

<p>嗯，英文注释不错，第一次调用的时候会实例化一个<code>NSManagedObjectContext</code>对象，并使用<code>persistentStoreCoordinator</code>方法返回的<code>NSPersistentStoreCoordinator</code>对象配置上下文，最后返回新实例化的<code>NSManagedObjectContext</code>对象。<br/>
顺藤摸瓜，我们再看看<code>persistentStoreCoordinator</code>的getter：</p>

<p>```
// Returns the persistent store coordinator for the application.
// If the coordinator doesn&rsquo;t already exist, it is created and the application&rsquo;s store added to it.
&ndash; (NSPersistentStoreCoordinator *)persistentStoreCoordinator
{</p>

<pre><code>if (_persistentStoreCoordinator != nil) {
    return _persistentStoreCoordinator;
}

NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@"MyCDDemo.sqlite"];

NSError *error = nil;
_persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];
if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&amp;error]) {
    /*
     Replace this implementation with code to handle the error appropriately.

     abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 

     Typical reasons for an error here include:
     * The persistent store is not accessible;
     * The schema for the persistent store is incompatible with current managed object model.
     Check the error message to determine what the actual problem was.


     If the persistent store is not accessible, there is typically something wrong with the file path. Often, a file URL is pointing into the application's resources directory instead of a writeable directory.

     If you encounter schema incompatibility errors during development, you can reduce their frequency by:
     * Simply deleting the existing store:
     [[NSFileManager defaultManager] removeItemAtURL:storeURL error:nil]

     * Performing automatic lightweight migration by passing the following dictionary as the options parameter:
     @{NSMigratePersistentStoresAutomaticallyOption:@YES, NSInferMappingModelAutomaticallyOption:@YES}

     Lightweight migration will only work for a limited set of schema changes; consult "Core Data Model Versioning and Data Migration Programming Guide" for details.

     */
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}    

return _persistentStoreCoordinator;
</code></pre>

<p>}
<code>``
为了访问documents目录中的SQLite存储文件MyCDDemo.sqlite，还定义了一个</code>applicationDocumentsDirectory`方法，它的作用是获取程序documents的路径，代码如下：</p>

<p>```
// Returns the URL to the application&rsquo;s Documents directory.
&ndash; (NSURL *)applicationDocumentsDirectory
{</p>

<pre><code>return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];
</code></pre>

<p>}
<code>``
MyCDDemo.sqlite文件是在编译MyCDDemo.xcdatamodeld时生成的，同样生成的还有MyCDDemo.momd文件，后面会提到。
</code>NSPersistentStoreCoordinator<code>初始化时需要传入</code>managedObjectModel<code>。</code>NSPersistentStoreCoordinator<code>对象在添加持久存储的时候不仅需要传入存储类型，还有配置，存储文件URL，选项以及错误类型。我们使用sqlite作为存储类型，配置为nil，还记得之前叫做default的配置么？这里我们只有一个持久存储，所以配置一项不需要。如果添加存储的时候出现错误，就会进入if判断，具体处理错误的细节可以看看模版生成的注释。  
既然</code>NSPersistentStoreCoordinator<code>又用到了</code>managedObjectModel<code>，我们再看看</code>managedObjectModel`方法吧：</p>

<p>```
// Returns the managed object model for the application.
// If the model doesn&rsquo;t already exist, it is created from the application&rsquo;s model.
&ndash; (NSManagedObjectModel *)managedObjectModel
{</p>

<pre><code>if (_managedObjectModel != nil) {
    return _managedObjectModel;
}
NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@"MyCDDemo" withExtension:@"momd"];
_managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
return _managedObjectModel;
</code></pre>

<p>}
<code>``
依然是跟之前一样的代码风格，这次</code>NSManagedObjectModel`类在初始化的时候用到了MyCDDemo.momd文件，前面提到过，当你编译项目时，MyCDDemo.xcdatamodeld数据模型将被编译成MyCDDemo.momd资源，并且保存到app的Bundle目录。</p>

<p>最后，在程序退出时，会调用代理<code>applicationWillTerminate:</code></p>

<p>```
&ndash; (void)applicationWillTerminate:(UIApplication *)application
{</p>

<pre><code>// Saves changes in the application's managed object context before the application terminates.
[self saveContext];
</code></pre>

<p>}
<code>``
它调用了</code>saveContext`方法：</p>

<p>```
&ndash; (void)saveContext
{</p>

<pre><code>NSError *error = nil;
NSManagedObjectContext *managedObjectContext = self.managedObjectContext;
if (managedObjectContext != nil) {
    if ([managedObjectContext hasChanges] &amp;&amp; ![managedObjectContext save:&amp;error]) {
         // Replace this implementation with code to handle the error appropriately.
         // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
        NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
        abort();
    } 
}
</code></pre>

<p>}
<code>``
</code>managedObjectContext<code>对象中的数据无论怎么修改，都是发生在内存中的，需要调用</code>save`方法来保存到存储文件当中。</p>

<p>按理说接下来应该看看<code>MasterViewController中</code>被传入的<code>managedObjectContext</code>对象是如何使用的，但在这之前，我们先运行下程序，看看这个App有什么功能：</p>

<p><img src="/images/blog/QQ20140501-4@2x.png" alt="" /></p>

<p>再普通不过的tableview了，点击加号便可添加一条记录，内容为时间戳，回想起之前看的名称为Event的Entity，是不是想起了什么，嘿嘿。再添加了四条记录后，不妨打开sqlite文件查看下，路径为<code>~/Library/Application Support/iPhone Simulator/[OS version]/Applications/[appGUID]/Documents/</code>，目录内包含了三个文件MyCDDemo.sqlite、MyCDDemo.sqlite-shm、MyCDDemo.sqlite-wal。如上文所述，根据AppDelegate.m文件中的<code>persistentStoreCoordinator</code>方法可知，时间戳记录被存储在MyCDDemo.sqlite文件中。我用Navicat Premium将其打开：</p>

<p><img src="/images/blog/QQ20140501-5@2x.png" alt="" /></p>

<p><img src="/images/blog/QQ20140501-6@2x.png" alt="" /></p>

<p>相信你对“三剑客”有了更深的理解，再附上一张图加深下印象：</p>

<p><img src="/images/blog/coredata1.png" alt="" /></p>

<p>一个<code>NSManagedObjectModel</code>对象处在<code>NSPersistentStoreCoordinator</code>对象和<code>NSManagedObjectContext</code>对象之间。Core Data根据<code>NSManagedObjectModel</code>对象确定如何将底层的持久化文件中的数据映射为<code>NSManagedObject</code>对象。一个<code>NSManagedObjectModel</code>对象用于表示数据的结构。<code>NSManagedObjectModel</code>对象也被称为对象图(object graph)。你可以简单的理解为：<strong>在数据库sqlite文件中，一张表中的一条数据（table row）就相当于代码中的一个NSManagedObject对象，他们之间的映射是通过<code>NSManagedObjectModel</code>对象完成的</strong></p>

<p>下面让我们进入到<code>MasterViewController</code>中来认识一下这个新出现的<code>NSManagedObject</code>“小弟”</p>

<p>既然数据库中的数据最终显示在了<code>UITableView</code>上，我们撇开<code>MasterViewController</code>中其他的方法，直奔<code>UITableViewDataSource</code>协议中已经实现的那几个方法：</p>

<p>```
&ndash; (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{</p>

<pre><code>return [[self.fetchedResultsController sections] count];
</code></pre>

<p>}</p>

<ul>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
  id <NSFetchedResultsSectionInfo> sectionInfo = [self.fetchedResultsController sections][section];
  return [sectionInfo numberOfObjects];
}</p></li>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
  UITableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:@&ldquo;Cell&rdquo; forIndexPath:indexPath];
  [self configureCell:cell atIndexPath:indexPath];
  return cell;
}</p></li>
<li><p>(BOOL)tableView:(UITableView <em>)tableView canEditRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  // Return NO if you do not want the specified item to be editable.
  return YES;
}</p></li>
<li><p>(void)tableView:(UITableView <em>)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  if (editingStyle == UITableViewCellEditingStyleDelete) {
      NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
      [context deleteObject:[self.fetchedResultsController objectAtIndexPath:indexPath]];</p>

<pre><code>  NSError *error = nil;
  if (![context save:&amp;error]) {
       // Replace this implementation with code to handle the error appropriately.
       // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
      NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
      abort();
  }
</code></pre>

<p>  } <br/>
}</p></li>
<li><p>(BOOL)tableView:(UITableView <em>)tableView canMoveRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  // The table view should not be re-orderable.
  return NO;
}
```</p></li>
</ul>


<p>如果你对<code>UITableView</code>的使用很有经验，一眼就可看出数据是由<code>fetchedResultsController</code>对象提供的。即使在<code>tableView: cellForRowAtIndexPath:</code>方法中没出现<code>fetchedResultsController</code>，但是在其调用的<code>configureCell: atIndexPath:</code>方法中依然用到了<code>fetchedResultsController</code>：</p>

<p>```
&ndash; (void)configureCell:(UITableViewCell <em>)cell atIndexPath:(NSIndexPath </em>)indexPath
{</p>

<pre><code>NSManagedObject *object = [self.fetchedResultsController objectAtIndexPath:indexPath];
cell.textLabel.text = [[object valueForKey:@"timeStamp"] description];
</code></pre>

<p>}
```
嗯看来NSManagedObject对象全都由这个fetchedResultsController提供咯，下面揭开它神秘的面纱：</p>

<p>```
&ndash; (NSFetchedResultsController *)fetchedResultsController
{</p>

<pre><code>if (_fetchedResultsController != nil) {
    return _fetchedResultsController;
}

NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
// Edit the entity name as appropriate.
NSEntityDescription *entity = [NSEntityDescription entityForName:@"Event" inManagedObjectContext:self.managedObjectContext];
[fetchRequest setEntity:entity];

// Set the batch size to a suitable number.
[fetchRequest setFetchBatchSize:20];

// Edit the sort key as appropriate.
NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"timeStamp" ascending:NO];
NSArray *sortDescriptors = @[sortDescriptor];

[fetchRequest setSortDescriptors:sortDescriptors];

// Edit the section name key path and cache name if appropriate.
// nil for section name key path means "no sections".
NSFetchedResultsController *aFetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedObjectContext sectionNameKeyPath:nil cacheName:@"Master"];
aFetchedResultsController.delegate = self;
self.fetchedResultsController = aFetchedResultsController;

NSError *error = nil;
if (![self.fetchedResultsController performFetch:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}

return _fetchedResultsController;
</code></pre>

<p>}
```</p>

<p>嗯，之前提到过，Core Data在iOS平台使用了<code>NSFetchedResultsController</code>对象来简化对提取结果和表格视图的处理。<code>NSFetchedResultsController</code>对象被惰性创建并只在表格视图数据源方法有需要时才提取数据。你会看到在<code>NSFetchRequest</code>对象的配置中，使用了Event实体，并提供了一个<code>NSSortDescriptor</code>对象以让提取结果按timeStamp进行排序。最后通过<code>NSFetchRequest</code>对象和<code>managedObjectContext</code>（在AppDelegate中传入的<code>NSManagedObjectContext</code>实例）作为参数传入<code>NSFetchedResultsController</code>的初始化方法。（<code>sectionNameKeyPath</code>参数传入nil时表示只有一个section，你会发现<code>NSFetchedResultsController</code>从数据库获取的结果跟<code>UITableView</code>需要的数据格式相同，都通过<code>NSIndexPath</code>地址来获取一条数据的内容）<br/>
<code>NSFetchedResultsController</code>也有它的代理，将<code>MasterViewController</code>设置为其代理，这样在fetched results 发生变化时，<code>MasterViewController</code>中实现的<code>NSFetchedResultsControllerDelegate</code>方法会被调用：</p>

<p>```
&ndash; (void)controllerWillChangeContent:(NSFetchedResultsController *)controller
{</p>

<pre><code>[self.tableView beginUpdates];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)controller:(NSFetchedResultsController *)controller didChangeSection:(id <NSFetchedResultsSectionInfo>)sectionInfo
         atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type
{
  switch(type) {
      case NSFetchedResultsChangeInsert:
          [self.tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade];
          break;</p>

<pre><code>  case NSFetchedResultsChangeDelete:
      [self.tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade];
      break;
</code></pre>

<p>  }
}</p></li>
<li><p>(void)controller:(NSFetchedResultsController <em>)controller didChangeObject:(id)anObject
     atIndexPath:(NSIndexPath </em>)indexPath forChangeType:(NSFetchedResultsChangeType)type
    newIndexPath:(NSIndexPath <em>)newIndexPath
{
  UITableView </em>tableView = self.tableView;</p>

<p>  switch(type) {
      case NSFetchedResultsChangeInsert:
          [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
          break;</p>

<pre><code>  case NSFetchedResultsChangeDelete:
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      break;

  case NSFetchedResultsChangeUpdate:
      [self configureCell:[tableView cellForRowAtIndexPath:indexPath] atIndexPath:indexPath];
      break;

  case NSFetchedResultsChangeMove:
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
      break;
</code></pre>

<p>  }
}</p></li>
<li><p>(void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
  [self.tableView endUpdates];
}</p></li>
</ul>


<p>/*
// Implementing the above methods to update the table view in response to individual changes may have performance implications if a large number of changes are made simultaneously. If this proves to be an issue, you can instead just implement controllerDidChangeContent: which notifies the delegate that all section and object changes have been processed.</p>

<ul>
<li>(void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
 // In the simplest, most efficient, case, reload the table view.
 [self.tableView reloadData];
}</li>
</ul>


<p>```</p>

<p>相对于之前<code>UITableViewDataSource</code>协议方法对<code>NSFetchedResultsController</code>对象中数据的修改（通过<code>NSManagedObject</code>对象做载体），<code>NSFetchedResultsControllerDelegate</code>协议方法会在察觉到数据修改后被调用，用于产生tableview操作数据后对应的动画效果。</p>

<p>可能你会觉得有些混乱，这里贴上几张图梳理下各个类的关系和结构：</p>

<p><img src="/images/blog/coredata_doc_management_2x.png" alt="" /></p>

<p><img src="/images/blog/fetch_request_2x.png" alt="" /></p>

<p><img src="/images/blog/advanced_persistence_stack_2x.png" alt="" /></p>

<p><img src="/images/blog/managed_object_model_2x.png" alt="" /></p>

<p><img src="/images/blog/entity_description_2x.png" alt="" /></p>

<p><img src="/images/blog/advanced_persistent_stack.jpg" alt="" /></p>

<p>最后，找到<code>insertNewObject</code>方法，当用户尝试加入一个对象到表视图时，该方法将被调用。接着你将看到如下的处理过程：</p>

<ul>
<li>获得一个<code>NSManagedObjectContext</code>对象；</li>
<li>决定创建新对象的实体；</li>
<li>根据实体名称创建一个新的<code>NSManagedObject</code>对象并将其插入到<code>NSManagedObjectContext</code>对象；</li>
<li>对新创建的<code>NSManagedObject</code>对象设置timeStamp属性值</li>
<li><code>NSManagedObjectContext</code>对象执行保存。</li>
</ul>


<p>当上下文执行保存，新的对象将被写到持久存储区中。这是如此简单！</p>

<p>DetailViewController的内容比较简单，不在叙述，到此结束，新建Core Data的模版工程代码已经解析完毕了。在下一期文章中将会亲手修改代码，探索Core Data更多的使用技巧。</p>

<h2>总结</h2>

<p>Core Data框架基本的5个类：：NSPersistentStoreCoordinator、NSManagedObjectContext、NSManagedObjectModel、NSEntityDescription、NSManagedObject。</p>

<ul>
<li><p>NSPersistentStoreCoordinator持久化存储协调器（简称协调器）：负责从磁盘加载数据和将数据写入磁盘。协调器可以处理多种格式的数据库文件（NSPersistentStore），如二进制文件，XML文件、SQLite文件。你也可以实现自己的数据库文件格式（使用NSAtomicStore和NSIncrementalStore类），理论上你可以实现打开World或Photoshop文件的协调器。</p></li>
<li><p>NSEntityDescription实体描述（简称实体）：实体可以被看做是NSManagedObject对象的“class”。实体定义了一个NSManagedObject对象所拥有的所有属性（NSAttributeDescription）,关系（NSRelationshipDescription），提取属性（NSFetchedPropertyDescription）。</p></li>
<li><p>NSManagedObjectContext托管对象上下文（简称上下文）：上下文是内存中的一块暂存区域。查询对象（使用NSFetchRequest），创建对象，删除对象等操作都是在上下文中进行。在上下文没有保存之前，对数据的任何修改都只记录在暂存区中，不会影响磁盘上的数据。你可以创建多个上下文，但整个程序只能创建一个NSPersstentStoreCoordinator对象。</p></li>
<li><p>NSManagedObject托管对象：Core Data的核心单元。模型对象的数据被持有在NSManagedObject对象中。每一个NSManagedObject对象都对应一个实体（就像每一个对象都有一个类）</p></li>
<li><p>NSManagedObjectModel托管对象模型：NSManagedObjectModel通常被定义在一个.mom文件中，文件中保存了所有实体的定义。NSManagedObjectModel and the NS*Description 类完整定义了Core Data模型应该/可以包含的内容。</p></li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Objective-C交叉引用解决方法]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/24/objective-cjiao-cha-yin-yong-jie-jue-fang-fa/"/>
    <updated>2014-04-24T20:25:00+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/24/objective-cjiao-cha-yin-yong-jie-jue-fang-fa</id>
    <content type="html"><![CDATA[<p>如果类A的头文件import了B，类B的头文件import了A，这样在编译时有可能产生一种错误：“can not find interface declaration”，这是因为Objective-C不允许交叉引用</p>

<!--more-->


<p>#import是GCC编译器提供的，XCode在编译Objective－C、C和C++程序时都会使用它。#import可保证头文件只被包含一次，而不论此命令实际上在那个文件中出现了多少次。<br/>
在C语言中，程序员通常使用基于#ifdef命令的方案来避免一个文件包含另一个文件，而后者又包含第一个文件的情况。<br/>
@class创建了一个向前引用。就是在告诉编译器：“相信我，以后你会知道这个类到底是什么。但是现在，你只需要知道这些。”<br/>
如果有循环依赖关系，@class也很有用。即A类使用B类，B类也使用A类。如果试图通过#import语句让这两个类互相引用，那么最后就会出现编译错误。但是如果在A.h中使用@class B，在B.h中使用@class A，那么这两个类就可以互相引用了。<br/>
<strong>所以最佳的解决方案是在头文件中使用@class，在.m文件中使用#import</strong></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Double Dispatch模式及其在iOS开发中实践]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/13/double-dispatchmo-shi-ji-qi-zai-ioskai-fa-zhong-shi-zhan/"/>
    <updated>2014-04-13T15:51:03+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/13/double-dispatchmo-shi-ji-qi-zai-ioskai-fa-zhong-shi-zhan</id>
    <content type="html"><![CDATA[<h2>引子</h2>

<p>在一个太空大战游戏中，导弹可以撞向飞船，也可能撞向行星，所以在碰撞检测的时候就需要判断碰撞的结果。假设游戏有四种物体：飞船，陨石，行星，导弹，那么就产生了<code>4*3/2+4</code>种情形（一枚导弹撞上另一枚导弹）。这种排列组合计算出的结果会随着物体种类N的增多爆炸性增长，如果这个时候还用一堆if－else来检测碰撞，那真是<code>Naive</code>了。这时我们可以利用面向对象语言的多态性质来在程序运行时动态绑定，因为碰撞检测是一种“双向选择”，所以我们需要<code>double dispatch</code>（双分派），<code>Visitor</code>模式就是<code>double dispatch</code>的一种应用。<br/>
<img src="/images/blog/doubledispatch.jpg" alt="Visitor模式" /></p>

<p>DD模式适合于处理多个对象之间的相互作用。假如不用DD模式的话，那么每个对象跟别的对象发生关系时，就必须辛辛苦苦的进行if&hellip;else&hellip;枚举，因为它并不知道对方是何神圣。DD模式的引入解决了这个问题，其实说白了就是利用语言内置的虚函数机制来替你干活，把工作移交给编译器去做了。</p>

<h2>本文内容</h2>

<ul>
<li>C++中的Double Dispatch实例</li>
<li>Java中的Double Dispatch实例</li>
<li>Objective-C中实现碰撞检测用到的Visitor模式</li>
</ul>


<!-- more-->


<h2>C++中的Double Dispatch实例</h2>

<p>本节内容摘自<a href="http://www.cnblogs.com/west-link/archive/2011/07/26/2116887.html">这里</a><br/>
我们先从字面上去理解它吧，直观地说，它指的是两次dispatch。这里的dispatch指的是什么呢？举个例子：</p>

<p>``` cpp
class Event
   {</p>

<pre><code>   public:
       virtual void PrintName()
       {
            cout&lt;&lt;"我是通用事件"&lt;&lt;endl;           
       }
</code></pre>

<p>   }</p>

<p>   class KeyEvent:public Event
   {</p>

<pre><code>  public:
       virtual void PrintName()
       {
            cout&lt;&lt;"我是按键事件"&lt;&lt;endl;           
       }
</code></pre>

<p>   }</p>

<p>   class ClickEvent:public Event
   {</p>

<pre><code>   public:
       virtual void PrintName()
       {
            cout&lt;&lt;"我是单击事件"&lt;&lt;endl;           
       }
</code></pre>

<p>   }
```</p>

<p>多态性是动态的，被调用的方法由对象的真正类型确定，这个过程就被称之为dispatch。例如在C++中，每个对象都有一个虚函数表，当用基类的类型引用子类对象时，虚函数指针指向的是子类的虚函数表，调用的虚函数都是子类中的版本，所以下面代码输出的是：“我是按键事件”，这就算是一次dispatch的过程，即根据对象类型来动态确定调用哪个函数的过程。</p>

<p><code>
Event* pEvent = new KeyEvent();
pEvent-&gt;PrintName();
</code></p>

<p>什么时候会用到两次dispatch呢? 继续往下看：</p>

<p>```
class EventRecorder
   {</p>

<pre><code>   public:
       virtual void RecordEvent(Event* event)
       {
           cout&lt;&lt;"使用EventRecorder记录通用事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(KeyEvent* event)
       {
           cout&lt;&lt;"使用EventRecorder记录按键事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(ClickEvent* event)
       {
           cout&lt;&lt;"使用EventRecorder记录单击事件"&lt;&lt; endl;           
       }
</code></pre>

<p>   }</p>

<p>   class AdvanceEventRecorder:public EventRecorder
   {</p>

<pre><code>   public:
       virtual void RecordEvent(Event* event)
       {
           cout&lt;&lt;"使用高级EventRecorder记录通用事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(KeyEvent* event)
       {
           cout&lt;&lt;"使用高级EventRecorder记录按键事件"&lt;&lt; endl;           
       }

       virtual void RecordEvent(ClickEvent* event)
       {
           cout&lt;&lt;"使用高级EventRecorder记录单击事件"&lt;&lt; endl;           
       }
</code></pre>

<p>   }
```</p>

<p>这两个类中分别包含三个重载函数，多态是动态的，而函数重载则是静态的，它在编译时期就确定下来了，所以，下面代码片段的运行结果并不是我们所期望的:</p>

<p>```</p>

<pre><code>EventRecorder* pRecorder = new AdvanceEventRecorder();
Event* pEvent = new KeyEvent();
pRecorder-&gt;RecordEvent(pEvent);
</code></pre>

<p>```
输出内容为：使用高级EventRecorder记录通用事件<br/>
实际上，在这个场景中，我们期望调用的是：AdvanceEventRecorder::RecordEvent(KeyEvent* event)<br/>
下面我们使用Double Dispatch设计模式来达到上面的代码片段的目的，在所有Event对象中增加下面的函数：</p>

<p>```
   virtual void RecordEvent(EventRecorder* recorder)
   {</p>

<pre><code>  recorder-&gt;RecordEvent(this);
</code></pre>

<p>   }
```
下面的代码片段将输出：使用高级EventRecorder记录按键事件</p>

<p>```</p>

<pre><code>EventRecorder* pRecorder = new AdvanceEventRecorder();
Event* pEvent = new KeyEvent();
pEvent-&gt;RecordEvent(pRecorder);
</code></pre>

<p><code>``
可以看出，第一次dispatch正确地找到了</code>KeyEvent<code>的</code>RecordEvent(EventRecorder<em> recorder)<code>，第二次dispatch找到了</code>AdvanceEventRecorder<code>的</code>RecordEvent(KeyEvent</em> event)`。
   Visitor模式就是对Double Dispatch的应用，另外，在碰撞检测算法中也会经常用到。</p>

<h2>Java中的Double Dispatch实例</h2>

<p>本节参考自<a href="http://www.blogjava.net/chaocai/archive/2009/02/19/255640.html">这里</a>
相对于C++中使用继承来说，Java提供的接口和函数重载让Double Dispatch模式更容易实现</p>

<h3>1 根据对象来选择行为问题</h3>

<p><code>java
public interface Event {
}
public class BlueEvent implements Event {
}
public class RedEvent implements Event {
}
public class Handler {
public void handle(Event event){
System.out.println("It is event");
}
public void handle(RedEvent event){
System.out.println("It is RedEvent");
}
public void handle(BlueEvent event){
System.out.println("It is BlueEvent");
}
}
public class Main {
public static void main(String[] args) {
Event evt=new BlueEvent();
new Handler().handle(evt);
}
}
</code></p>

<p>你认为运行结果是什么呢？<br/>
结果：It is event<br/>
是不是有点出乎意料，不是It is BlueEvent，<strong>这是因为Overload并不支持在运行时根据参数的运行时类型来绑定方法</strong>，所以要执行哪个方法是在编译时就选定了的。</p>

<h3>2 Double Dispatch Pattern</h3>

<p>由于Java,C++及C#都具有上述局限，通常我们只能通过Switch或if结构来实现，当然这种实现方式既不优雅而且影响代码的可维护性。<br/>
通过以下的Double Dispatch Pattern便可以优雅的实现。</p>

<p><code>
public interface Event {
public void injectHandler(EventHandler v);
}
public class BlueEvent implements Event {
public void injectHandler(EventHandler v) {
v.handle(this);
}
}
public class RedEvent implements Event {
public void injectHandler(EventHandler v) {
v.handle(this);
}
}
public class EventHandler {
public void handle(BlueEvent e){
System.out.println("It is BlueEvent");
}
public void handle(RedEvent e){
System.out.println("It is RedEvent");
}
}
public class Main {
public static void main(String[] args) {
Event evt=new BlueEvent();
evt.injectHandler(new EventHandler());
}
}
</code></p>

<h2>Objective-C中实现碰撞检测用到的Visitor模式</h2>

<p>虽然OC不支持函数重载，但是其独有的SEL类型可以很好的解决这个问题<br/>
感谢kouky提供的iOS上碰撞检测的<a href="https://github.com/kouky/iOS-SpriteKit-Pong">Demo</a>，这里他用到了Visitor模式<br/>
由于判断物体类型是用一个32位掩码来标记，所以这里不可避免的要用到if语句，这不代表它不是动态绑定，因为if语句是在初始化方法<code>+ (id)contactVisitorWithBody:(SKPhysicsBody *)body forContact:(SKPhysicsContact *)contact</code>中其作用的，只是为了判断物体类型，而不是判断碰撞两者的组合类型<br/>
可以参考我写的例子<a href="https://github.com/yulingtianxia/MyFirstGame/tree/master/ColorAtom">ColorAtom</a></p>

<p>首先新建一个访问者基本类<code>ContactVisitor</code>，其本质为对SKPhysicsBody和SKPhysicsContact对象的封装，而SKPhysicsContact在本例中虽未用到（因为碰撞检测后啥也没干，只输出了碰撞双方name），但其保存着碰撞坐标等信息，也很重要。两次dispatch都是在访问者基本类实现的，而碰撞后具体操作则卸载了访问者具体类（如AtomNodeContactVisitor）</p>

<p>``` objc</p>

<p>//  ContactVisitor.h
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;SpriteKit/SpriteKit.h></h1>

<p>@interface ContactVisitor : NSObject</p>

<p>@property (nonatomic,readonly, strong) SKPhysicsBody <em>body;
@property (nonatomic, readonly, strong) SKPhysicsContact </em>contact;</p>

<ul>
<li>(id)contactVisitorWithBody:(SKPhysicsBody <em>)body forContact:(SKPhysicsContact </em>)contact;</li>
<li>(void)visit:(SKPhysicsBody *)body;</li>
</ul>


<p>@end
```</p>

<p>属性body即为访问者的SKPhysicsBody，而方法<code>visit:</code>的参数为被访问者的SKPhysicsBody<br/>
<code>contactVisitorWithBody:forContact:</code>方法的作用是根据掩码类型初始化对应类型的访问者具体类</p>

<p>```
//
//  ContactVisitor.m
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;ContactVisitor.h&rdquo;</h1>

<h1>import &lt;objc/runtime.h></h1>

<h1>import &ldquo;NodeCategories.h&rdquo;</h1>

<h1>import &ldquo;AtomNodeContactVisitor.h&rdquo;</h1>

<h1>import &ldquo;PlayFieldSceneContactVisitor.h&rdquo;</h1>

<p>@implementation ContactVisitor
+ (id)contactVisitorWithBody:(SKPhysicsBody <em>)body forContact:(SKPhysicsContact </em>)contact
{</p>

<pre><code>//第一次dispatch，通过node类别返回对应的实例
if ((body.categoryBitMask&amp;AtomCategory)!=0) {
    return [[AtomNodeContactVisitor alloc] initWithBody:body forContact:contact];
}
if ((body.categoryBitMask&amp;PlayFieldCategory)!=0) {
    return [[PlayFieldSceneContactVisitor alloc] initWithBody:body forContact:contact];
}
else{
    return nil;
}
</code></pre>

<p>}</p>

<ul>
<li><p>(id)initWithBody:(SKPhysicsBody <em>)body forContact:(SKPhysicsContact </em>)contact
{
  self = [super init];
  if (self) {
      <em>contact = contact;
      </em>body = body;
  }
  return self;
}</p></li>
<li><p>(void)visit:(SKPhysicsBody <em>)body
{
  //第二次dispatch，通过构造方法名来执行对应方法
  // 生成node的名字，比如"AtomNode"
  NSString </em>bodyClassName = [NSString stringWithUTF8String:class_getName(body.node.class)];</p>

<p>  // 生成方法名，比如"visitAtomBody"
  NSMutableString *contactSelectorString = [NSMutableString stringWithFormat:@&ldquo;visit&rdquo;];
  [contactSelectorString appendString:bodyClassName];
  [contactSelectorString appendString:@&ldquo;:&rdquo;];</p>

<p>  SEL selector = NSSelectorFromString(contactSelectorString);
  //判断是否存在此方法
  if ([self respondsToSelector:selector]) {
      [self performSelector:selector withObject:body];
  }</p></li>
</ul>


<p>}</p>

<p>```</p>

<p>以访问者具体类以<code>AtomNodeContactVisitor</code>类为例，它继承自访问者基本类ContactVisitor</p>

<p>```</p>

<p>//
//  AtomNodeContactVisitor.h
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;ContactVisitor.h&rdquo;</h1>

<p>@interface AtomNodeContactVisitor : ContactVisitor</p>

<p>/<em>Atom访问了Atom，同类碰撞</em>/
&ndash;(void) visitAtomNode:(SKPhysicsBody<em>) anotherAtomBody;
/</em>Atom访问了边界，也就是球撞墙上了<em>/
&ndash;(void) visitPlayFieldScene:(SKPhysicsBody</em>) playfieldBody;
@end</p>

<p>```</p>

<p>在处理碰撞后的visitXXX方法中，我将碰撞双方的访问者和被访问者的关系输出</p>

<p>```
//
//  AtomNodeContactVisitor.m
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;AtomNodeContactVisitor.h&rdquo;</h1>

<h1>import &ldquo;AtomNode.h&rdquo;</h1>

<h1>import &ldquo;PlayFieldScene.h&rdquo;</h1>

<p>@implementation AtomNodeContactVisitor
&ndash;(void) visitAtomNode:(SKPhysicsBody*) anotherAtomBody
{</p>

<pre><code>AtomNode *thisAtom = (AtomNode*)self.body.node;
AtomNode *anotherAtom = (AtomNode*)anotherAtomBody.node;
//处理碰撞后的结果
NSLog(@"%@-&gt;%@",thisAtom.name,anotherAtom.name);
</code></pre>

<p>}
&ndash;(void) visitPlayFieldScene:(SKPhysicsBody*) playfieldBody
{</p>

<pre><code>AtomNode *atom = (AtomNode*)self.body.node;
PlayFieldScene *playfield = (PlayFieldScene*) playfieldBody.node;
NSLog(@"%@-&gt;%@",atom.name,playfield.name);
</code></pre>

<p>}
@end
```
下面建立被访问者类，其本质就是对SKPhysicsBody的封装，并接受Visitor的注入</p>

<p>```
//
//  VisitablePhysicsBody.h
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &ldquo;ContactVisitor.h&rdquo;</h1>

<p>@interface VisitablePhysicsBody : NSObject
@property (nonatomic, readonly, strong) SKPhysicsBody *body;</p>

<ul>
<li>(id) initWithBody:(SKPhysicsBody *)body;</li>
<li>(void) acceptVisitor:(ContactVisitor *)visitor;</li>
</ul>


<p>@end
```</p>

<p>关键的一步：在<code>acceptVisitor:</code>方法中调用访问者的<code>visit:</code>方法</p>

<p>```
//
//  VisitablePhysicsBody.m
//  ColorAtom
//
//  Created by 杨萧玉 on 14-4-13.
//  Copyright &copy; 2014年 杨萧玉. All rights reserved.
//</p>

<h1>import &ldquo;VisitablePhysicsBody.h&rdquo;</h1>

<p>@implementation VisitablePhysicsBody
&ndash; (id)initWithBody:(SKPhysicsBody *)body
{</p>

<pre><code>self = [super init];
if (self) {
    _body = body;
}
return self;
</code></pre>

<p>}</p>

<ul>
<li>(void)acceptVisitor:(ContactVisitor *)visitor
{
  [visitor visit:self.body];
}</li>
</ul>


<p>@end</p>

<p>```</p>

<p>可能有人会有疑问，<code>visit:</code>方法穿入的参数类型永远是<code>SKPhysicsBody</code>，这哪里是动态绑定啊，其实是由于本例的特殊性，碰撞检测时区分物体类型不是靠<code>SKPhysicsBody</code>子类化来区分和绑定，而是靠SKPhysicsBody类中的<code>categoryBitMask</code>属性来区分，这也就免不了需要在<code>ContactVisitor</code>初始化的时候通过if语句来判断具体初始化哪个子类<br/>
最后，在Scene实现SKPhysicsContactDelegate协议</p>

<p>```</p>

<h1>pragma mark SKPhysicsContactDelegate</h1>

<p>&ndash;(void)didBeginContact:(SKPhysicsContact *)contact
{</p>

<pre><code>//A-&gt;B
ContactVisitor *visitorA = [ContactVisitor contactVisitorWithBody:contact.bodyA forContact:contact];
VisitablePhysicsBody *visitableBodyB = [[VisitablePhysicsBody alloc] initWithBody:contact.bodyB];
[visitableBodyB acceptVisitor:visitorA];
//B-&gt;A
ContactVisitor *visitorB = [ContactVisitor contactVisitorWithBody:contact.bodyB forContact:contact];
VisitablePhysicsBody *visitableBodyA = [[VisitablePhysicsBody alloc] initWithBody:contact.bodyA];
[visitableBodyA acceptVisitor:visitorB];
</code></pre>

<p>}
```
物理老师总说力的作用时相互的，所以我们需要两次访问：A访问B和B访问A，但是这样会调用两次visitXXX方法，原则上这两个逻辑上对称的方法我们只需要实现其中一个就可以，但必须得像上面代码一样，A->B和B->A缺一不可，因为碰撞的时候我们不知道bodyA和bodyB的类型，也就无法判断visitXXX方法是A->B时能调用还是B->A时能调用到<br/>
当然，你也可以两个visit方法都实现，但只对visitor的node做操作，或只对visitable的node操作，总之仁者见仁智者见智啦</p>
]]></content>
  </entry>
  
</feed>
