<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-07-15T20:21:15+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift中的位运算符合溢出运算符]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/11/bitwise-and-overflow-operators-in-swift/"/>
    <updated>2014-07-11T15:15:59+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/11/bitwise-and-overflow-operators-in-swift</id>
    <content type="html"><![CDATA[<p>位运算符（Bitwise Operators），在各种语言中都存在，虽然用的有些少，但是在诸如类别判断，类型检测等方案中经常用位运算来实现。很多枚举类型的成员都是将<code>0x1</code>左移位来赋值，而不是从0递增，这其中就蕴含着位运算。而数值运算中的溢出也是一个不常遇到但又值得注意的地方，虽然很少有人用<code>Int8</code>来存储大数，但了解下Swift处理溢出的这一特性也是很有用的。</p>

<!--more-->


<h2>基本位运算符</h2>

<p><code>~</code>,<code>&amp;</code>,<code>|</code>,<code>^</code>分别为取反，与，或，异或运算：</p>

<p><code>
let firstBit: UInt8 = 0b10000000
let lastBit: UInt8  = 0b00000001
let invertedBits = ~lastBit  // 等于 0b11111110
let noneBit = firstBit &amp; lastBit  // 等于 0b00000000
let twoSideBits = firstBit | lastBit //等于 0b10000001
let middleSixBits = firstBit ^ lastBit //等于 0b10000001
</code>
左移运算符<code>&lt;&lt;</code>和右移运算符<code>&gt;&gt;</code>分别扮演着乘2和除2的角色，对于<code>UInt</code>来讲很简单，只需要填充0就行：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftUnsigned_2x.png" alt="" /></p>

<p>但对于有符号整型数，移位时需要考虑到符号位，第一个比特位表达这个整数是正数还是负数。0代表正数，1代表负数。也就是说<code>Int8</code>最大是127，因为只有7位存储实际值，而且负数采用补码来表示。</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedFour_2x.png" alt="" /></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFour_2x.png" alt="" /></p>

<p>正数的补码是原码；负数的补码是符号位不变，数值位各位取反，最后整个数加1，补码之所以被机器采用是因为它符合机器的架构设计，只用加法就能算减法：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedAddition_2x.png" alt="" /></p>

<p>有符号整型右移运算时用符号位填充：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSigned_2x.png" alt="" /></p>

<p>这就确保了在右移的过程中，有符整型的符号不会发生变化。这称为算术移位。</p>

<h2>溢出运算符</h2>

<p>Swift中如果计算结果超出了它的类型能承载的范围，那么就会发生溢出错误，除非你已经使用溢出运算符来进行操作：</p>

<ul>
<li>溢出加法 <code>&amp;+</code></li>
<li>溢出减法 <code>&amp;-</code></li>
<li>溢出乘法 <code>&amp;*</code></li>
<li>溢出除法 <code>&amp;/</code></li>
<li>溢出求余 <code>&amp;%</code></li>
</ul>


<h3>值的上溢出</h3>

<p><code>
var willOverflow = UInt8.max
// willOverflow 等于UInt8的最大整数 255
willOverflow = willOverflow &amp;+ 1
// 此时 willOverflow 等于 0
</code></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowAddition_2x.png" alt="" /></p>

<h3>值的下溢出</h3>

<p><code>
var willUnderflow = UInt8.min
// willUnderflow 等于UInt8的最小值0
willUnderflow = willUnderflow &amp;- 1
// 此时 willUnderflow 等于 255
</code></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowUnsignedSubtraction_2x.png" alt="" /></p>

<p>有符整型也有类似的下溢出</p>

<p><code>
var signedUnderflow = Int8.min
// signedUnderflow 等于最小的有符整数 -128
signedUnderflow = signedUnderflow &amp;- 1
// 此时 signedUnderflow 等于 127
</code></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowSignedSubtraction_2x.png" alt="" /></p>

<h3>除零溢出</h3>

<p>一个数除以0，或者对0求余数，就会产生一个错误；使用它们对应的可溢出的版本的运算符<code>&amp;/</code>和<code>&amp;%</code>进行除0操作时就会得到0值。</p>

<p><code>
let x = 1
let y = x &amp;/ 0
// y 等于 0
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Core Data(3)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3/"/>
    <updated>2014-07-03T10:28:28+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3</id>
    <content type="html"><![CDATA[<p>在Swift发布后，我尝试用Swift和Core Data做了一个小Demo，名字叫“HardChoice”。它用于帮助人们随机生成一个问题的结果，当然结果是预设好的，并可以加入权值。本文将通过这个Demo来进一步阐述Core Data的知识。</p>

<p>本文包含以下内容：</p>

<ul>
<li>建立数据模型</li>
<li>Swift与Objective-C桥接</li>
<li>NSFetchedResultsController</li>
<li>UITextField键盘响应</li>
<li>随机选择算法</li>
</ul>


<!--more-->


<p>你可以在<a href="https://github.com/yulingtianxia/HardChoice">GitHub</a>上下载HardChoice的代码</p>

<p>在没弄懂Core Data的基础知识之前，我建议你先阅读我之前的两篇博文：</p>

<p><a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a><br/>
<a href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/">初识Core Data(2)</a></p>

<p>如果你不懂Swift也没关系，只要了解OC和Core Data，总是能看懂的</p>

<p>在写代码前先了解下我们要做什么：<br/>
<img src="http://wal8.com/64224622" alt="" />
<img src="http://wal8.com/64224623" alt="" /></p>

<p>先在第一个页面添加问题（吃啥？），然后点击问题进入到第二个添加选项（鸭子，蛋，猪）的页面。每个选项左边是选项名，右边是该选项的权值。摇动手机就能随机从所有选项中选出答案（就像第二张图那样）。</p>

<h2>建立数据模型</h2>

<p>还是像以前那样新建一个Master-Detail Application，勾选Use Core Data选项，语言选择Swift，然后Xcode会自动生成一个具有<code>UITableView</code>的Demo，这些内容之前说过。下面我们需要打开xcdatamodeld文件来建立我们的数据模型：</p>

<p><img src="http://byetz.img41.wal8.com/img41/425047_20140623222918/140436356516.png" alt="" /></p>

<p><code>Question</code>这个实体只具有一个属性，那就是问题内容<code>content</code>，类型为<code>String</code>；<code>Choice</code>实体有一个类型为<code>String</code>的<code>name</code>属性和一个类型为<code>Integer32</code>的<code>weight</code>属性，分别代表问题选项的名字和权重。</p>

<p>下面我们来建立<code>Question</code>和<code>Choice</code>这两个实体之间的关系：</p>

<p>假设每个问题都对应多个选项，也可以没有选项：</p>

<p><img src="http://byetz.img41.wal8.com/img41/425047_20140623222918/14043675716.png" alt="" /></p>

<p><code>Optional</code>被打钩是因为问题可以没有任何选项，在Tpye那里我们选择<code>To Many</code></p>

<p>相反，每个选项一定会对应一个问题，并且是唯一的问题：</p>

<p><img src="http://byetz.img41.wal8.com/img41/425047_20140623222918/140436793089.png" alt="" /></p>

<p><code>Optional</code>那里不打钩是为了避免关系的目标为空，在<code>Tpye</code>那里我们选择了<code>To One</code></p>

<p><strong>关于<code>Delete Rule</code>的选择</strong></p>

<p>下面会通过部门与员工的例子来阐述<code>Delete Rule</code>的用法</p>

<ul>
<li><strong><code>Deny</code></strong> 如果关系指向的目标仍然有对象，那么关系的源对象就不会被删除，比如你想删除一个部门，必须先确保该部门所有员工已经调到其他部门（或被解雇），否则这个部门就不会被删除。</li>
<li><strong><code>Nullify</code></strong> 将被删除对象反向关系的目标设为null，比如如果你删除了一个部门，那么将这个部门所有成员的department关系目标设为null。需要注意的是员工的department关系应该被勾选为Optional，或者是在删除部门之后马上给该部门员工设置一个新的部门。</li>
<li><strong><code>Cascade</code></strong> 顾名思义它会传递删除命令，删除一个对象会导致这个对象关系中所指向的所有目标对象也被删除。比如如果你删除了一个部门那么这个部门所有员工都会被立即删除。</li>
<li><strong><code>No Action</code></strong> 无为而治。比如如果你删除了一个部门，那么这个部门底下的所有员工什么都不知道，他们还以为自己还属于这个部门。</li>
</ul>


<p>回到我们的例子，因为<code>Question</code>指向<code>Choice</code>的<code>choices</code>关系具有从属的性质，问题被删除后<code>choices</code>所指向的选项也应该被删除，所以<code>choices</code>关系中的<code>Delete Rule</code>我们选择<code>Cascade</code>；而<code>Choice</code>指向<code>Question</code>的<code>question</code>关系中<code>Delete Rule</code>被设置成了<code>Nullify</code>，也就是解除了<code>Question</code>与这个<code>Choice</code>的关系，并且我们之前已经设置<code>Question</code>的<code>choices</code>关系设置为<code>Optional</code>来满足<code>Nullify</code>这一选项的要求。</p>

<p><strong>注意：每当你修改过数据模型后，需要将以前生成好的APP删除后再重新Run一下，这样才不会发生错误。这是因为手动删除APP会连同将其数据一起删除，然后重新Run一下会将新的数据表结构安装在模拟器或真机上</strong></p>

<p>如果你对建立数据模型的过程生疏，建议回到<a href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/">初识Core Data(2)</a>中复习下“使用数据模型设计器”一节</p>

<h2>Swift与Objective-C桥接</h2>

<p>在使用Xcode6 Beta2生成<code>NSManagedObject</code>子类的时候，生成的代码依然是Objective-C的代码（即使我的工程是用Swift语言建立的），这就涉及到在Swift工程中调用Objective-C类的问题。苹果给我们提供了一个比较简单的解决方案。在你向工程中加入OC文件时，Xcode会自动弹出消息问你是否需要生成一个桥接头文件（“工程名-Bridging-Header.h”），然后我们在这个头文件中加入想要在Swift中调用的OC类的头文件：</p>

<p>``` objc
//
//  Use this file to import your target&rsquo;s public headers that you would like to expose to Swift.
//</p>

<h1>import &ldquo;Question.h&rdquo;</h1>

<h1>import &ldquo;Choice.h&rdquo;</h1>

<h1>import &ldquo;CustomIOS7AlertView.h&rdquo;</h1>

<p>```</p>

<p><code>Question</code>和<code>Choice</code>这两个类是用之前数据模型中同名实例创建的<code>NSManagedObject</code>子类，<code>CustomIOS7AlertView</code>类是本项目用到的一个自定义AlertView（iOS7之后苹果不再允许自定义<code>UIAlertView</code>了）</p>

<p>这样在Swift文件中不用<code>import</code>任何东西就可以直接使用上面被引入的OC类了</p>

<p>有关Swift和OC在同一项目中混合使用的方法详见<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/Swift%20and%20Objective-C%20in%20the%20Same%20Project.md">这里</a></p>

<h2>NSFetchedResultsController</h2>

<p>在<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a>中我们提到过<code>NSFetchedResultsController</code>的作用，简单地说，<code>NSFetchedResultsController</code>的作用就是有效率的管理从CoreData获取请求的数据结果，并将结果提供给<code>UITableView</code>作为数据源。</p>

<p>在<code>MasterViewController.swift</code>文件中，Xcode生成了两个<code>NSFetchedResultsController</code>属性：一个只读计算属性<code>fetchedResultsController</code>和一个可选存储属性<code>_fetchedResultsController</code>，通过两者搭配来实现setter，这里不再多说，将计算属性<code>fetchedResultsController</code>的定义替换如下：</p>

<p>``` js</p>

<pre><code>var fetchedResultsController: NSFetchedResultsController {
    if _fetchedResultsController != nil {
        return _fetchedResultsController!
    }

    let fetchRequest = NSFetchRequest()
    // Edit the entity name as appropriate.
    let entity = NSEntityDescription.entityForName("Question", inManagedObjectContext: self.managedObjectContext)
    fetchRequest.entity = entity

    // Set the batch size to a suitable number.
    fetchRequest.fetchBatchSize = 20

    // Edit the sort key as appropriate.
    let sortDescriptor = NSSortDescriptor(key: "content", ascending: true)
    let sortDescriptors = [sortDescriptor]

    fetchRequest.sortDescriptors = sortDescriptors

    // Edit the section name key path and cache name if appropriate.
    // nil for section name key path means "no sections".
    let aFetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: self.managedObjectContext, sectionNameKeyPath: nil, cacheName: "Master")
    aFetchedResultsController.delegate = self
    _fetchedResultsController = aFetchedResultsController

    var error: NSError? = nil
    if !_fetchedResultsController!.performFetch(&amp;error) {
         // Replace this implementation with code to handle the error appropriately.
         // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
         //println("Unresolved error \(error), \(error.userInfo)")
         abort()
    }

    return _fetchedResultsController!
}
</code></pre>

<p>```</p>

<p><code>NSFetchRequest</code>对象描述了从数据持久层获取数据的标准，也就是相当于SQL中的from和where等条件语句，它是初始化<code>NSFetchedResultsController</code>的必要参数之一，因为它规定了从<code>NSManagedObjectContext</code>实例中获取什么样的数据。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353389167.png" alt="" /></p>

<p><code>NSFetchRequest</code>的属性<code>NSEntityDescription</code>，<code>predicate</code>和<code>sortDescriptors</code>分别对应着SQL中的from，where和order by语句，只不过<code>NSFetchRequest</code>把复杂的SQL语句进行了简化，查抄条件和排序方法更加灵活。</p>

<p>在上面的<code>fetchedResultsController</code>属性中我们设置了<code>NSFetchRequest</code>实例：获取所有<code>Question</code>实体对应的数据，并将结果按照<code>content</code>属性的升序排列。</p>

<p><code>init(fetchRequest: NSFetchRequest!, managedObjectContext context: NSManagedObjectContext!, sectionNameKeyPath: String!, cacheName name: String!)</code>是<code>NSFetchedResultsController</code>的指定构造器，除了刚才提到的<code>fetchRequest</code>参数外，还需传入一个必要参数<code>managedObjectContext</code>，在这里我们传入的<code>managedObjectContext</code>是来自<code>AppDelegate</code>的<code>managedObjectContext</code>属性。有关<code>NSManagedObjectContext</code>的知识参见<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a>，这里不再赘述。<strong>当构造器执行结束后，你就不能再修改<code>NSFetchedResultsController</code>的<code>fetchRequest</code>属性了</strong>。</p>

<p><code>sectionNameKeyPath</code>参数是用来指定抓取数据结果的<code>section</code>信息的，这样<code>UITableView</code>的<code>section</code>信息此时已经预编译好了。因为我们的程序只需要一个<code>section</code>，所以只需传入<code>nil</code>；<code>cacheName</code>参数用于指定缓存<code>section</code>预编译信息的文件名，我们不需要缓存<code>section</code>信息，所以传入<code>nil</code>。</p>

<p>当执行<code>performFetch(error: NSErrorPointer) -&gt; Bool</code>方法成功后，你可以通过<code>NSFetchedResultsController</code>的<code>fetchedObjects</code>属性来获取数据结果，如果为<code>UITableView</code>提供数据，可以用<code>objectAtIndexPath(indexPath: NSIndexPath!) -&gt; AnyObject!</code>方法来更加便捷的将数据与<code>NSIndexPath</code>对接上。在我们的例子中，会把数据结果转化为<code>NSManagedObject</code>的子类<code>Question</code>或<code>Choice</code>类：</p>

<p>```</p>

<pre><code>func configureCell(cell: UITableViewCell, atIndexPath indexPath: NSIndexPath) {
    let object = self.fetchedResultsController.objectAtIndexPath(indexPath) as Question
    cell.textLabel.text = object.content
}
</code></pre>

<p>```</p>

<p>下面修改<code>insertNewObject</code>方法来添加新的<code>Question</code>：</p>

<p>```</p>

<pre><code>var addAV = CustomIOS7AlertView()
func insertNewObject(sender: AnyObject) {
    let textField = UITextField(frame:CGRectMake(0,0,290,50))
    textField.becomeFirstResponder()
    textField.placeholder = "question"
    textField.keyboardType = .Default
    textField.returnKeyType = .Done
    textField.delegate = self
    addAV.containerView = textField
    addAV.buttonTitles = ["OK","Cancel"]
    addAV.delegate = self
    addAV.useMotionEffects = true
    addAV.show()

}
</code></pre>

<p>```</p>

<p>有了添加<code>Question</code>功能，当然还会有修改功能：</p>

<p>```</p>

<pre><code>var modifyAV = CustomIOS7AlertView()
func modifyObject(indexPath:NSIndexPath){
    let question = self.fetchedResultsController.objectAtIndexPath(indexPath) as Question
    let textField = UITextField(frame:CGRectMake(0,0,290,50))
    textField.becomeFirstResponder()
    textField.placeholder = "question"
    textField.keyboardType = .Default
    textField.returnKeyType = .Done
    textField.delegate = self
    modifyAV.containerView = textField
    modifyAV.buttonTitles = ["OK","Cancel"]
    modifyAV.delegate = self
    modifyAV.useMotionEffects = true
    (modifyAV.containerView as UITextField).text = question.content
    modifyAV.show()
}
</code></pre>

<p>```</p>

<p><code>CustomIOS7AlertView</code>是一个第三方的开源AlertView，它允许我们自定义AlertView的内容，并提供了<code>CustomIOS7AlertViewDelegate</code>协议来用于按钮点击的回调，我们将这两个<code>CustomIOS7AlertView</code>实例的<code>delegate</code>属性都设置为<code>self</code>，然后在<code>MasterViewController</code>中的实现协议中唯一的方法<code>customIOS7dialogButtonTouchUpInside(alertView:AnyObject!, clickedButtonAtIndex buttonIndex:Int)</code>：</p>

<p>```</p>

<pre><code>func customIOS7dialogButtonTouchUpInside(alertView:AnyObject!, clickedButtonAtIndex buttonIndex:Int){
    switch buttonIndex{
        case 0:
        let context = self.fetchedResultsController.managedObjectContext
        let entity = self.fetchedResultsController.fetchRequest.entity
        var newManagedObject:Question!
        let av = alertView as CustomIOS7AlertView
        if addAV == av{
            newManagedObject = NSEntityDescription.insertNewObjectForEntityForName(entity.name, inManagedObjectContext: context) as Question
        }
        if modifyAV == av{
            newManagedObject = self.fetchedResultsController.objectAtIndexPath(selectedIndexPath) as Question
        }
        // If appropriate, configure the new managed object.
        // Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
        newManagedObject.content = (av.containerView as UITextField).text

        // Save the context.
        var error: NSError? = nil
        if !context.save(&amp;error) {
            // Replace this implementation with code to handle the error appropriately.
            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
            //println("Unresolved error \(error), \(error.userInfo)")
            abort()
        }
        alertView.close()
        default:
        alertView.close()
    }
}
</code></pre>

<p>```</p>

<p>当用户点击<code>alertView</code>的OK按钮时，判断<code>alertView</code>对象是<code>addAV</code>还是<code>modifyAV</code>，然后对应通过不同途径（新插入到<code>ManagedObjectContext</code>还是从<code>ManagedObjectContext</code>中取出）产生<code>Question</code>实例<code>newManagedObject</code>，最后的结果会保存回<code>ManagedObjectContext</code>中，最后关闭<code>alertView</code>。</p>

<p>添加<code>Question</code>时使用的<code>insertNewObjectForEntityForName(entityName: String!, inManagedObjectContext context: NSManagedObjectContext!) -&gt; AnyObject!</code>方法是一个配置和添加实体，并返回该实体对应<code>NSManagedObject</code>子类（在这里是<code>Question</code>类）的便捷方法，这是一个很强大的类方法，我们无需知道创建<code>Question</code>类的细节就能创建并添加一个<code>Question</code>实例到<code>NSManagedObjectContext</code>中，在保存前我们还可以对这个方法返回的<code>Question</code>实例做修改，然后再通过<code>save(error: NSErrorPointer) -&gt; Bool</code>方法保存。</p>

<p>修改<code>Question</code>的过程其实就是先通过<code>objectAtIndexPath(indexPath: NSIndexPath!) -&gt; AnyObject!</code>方法取出数据请求结果当中的某一项并转换成<code>Question</code>对象，对其进行修改后再保存。在界面中通过点击cell右侧带有字母i的蓝色圆圈来修改<code>Question</code>内容：</p>

<p><img src="http://byetz.img41.wal8.com/img41/425047_20140623222918/140438530596.png" alt="" /></p>

<p>上图的中的蓝色圆圈是<code>AccessoryButton</code>，需要在IB中设置<code>TableViewCell</code>的<code>Identifier</code>为<code>QuestionCell</code>，<code>Accessory</code>为<code>Detail Disclosure</code>，这样我们就能在<code>UITableViewDelegate</code>的<code>tableView(tableView: UITableView!, accessoryButtonTappedForRowWithIndexPath indexPath: NSIndexPath!)</code>方法中响应<code>AccessoryButton</code>了：</p>

<p>```</p>

<pre><code>override func tableView(tableView: UITableView!, accessoryButtonTappedForRowWithIndexPath indexPath: NSIndexPath!){
    selectedIndexPath = indexPath
    modifyObject(indexPath)

}
</code></pre>

<p>```</p>

<p>导航栏右侧的添加<code>Question</code>按钮已经通过下面的代码配置了响应函数：</p>

<p><code>
let addButton = UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: "insertNewObject:")
self.navigationItem.rightBarButtonItem = addButton
</code>
在<code>UITableViewDelegate</code>中删除<code>Question</code>的代码如下：</p>

<p>```</p>

<pre><code>override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
    if editingStyle == .Delete {
        let context = self.fetchedResultsController.managedObjectContext
        context.deleteObject(self.fetchedResultsController.objectAtIndexPath(indexPath) as NSManagedObject)

        var error: NSError? = nil
        if !context.save(&amp;error) {
            // Replace this implementation with code to handle the error appropriately.
            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
            //println("Unresolved error \(error), \(error.userInfo)")
            abort()
        }
    }
}
</code></pre>

<p>```</p>

<p>这里多说一嘴，如果你想打印出错误信息的话，不要直接反注释那行<code>println</code>代码，还需要在<code>error</code>后加上感叹号，因为<code>error</code>是可选类型，需要强制解析：</p>

<p><code>
println("Unresolved error \(error!), \(error!.userInfo)")
</code></p>

<h2>UITextField键盘响应</h2>

<p>在将<code>UITextField</code>实例赋值给<code>CustomIOS7AlertView</code>的<code>containerView</code>属性前需要先让其获取当前焦点，并将<code>UITextField</code>的<code>delegate</code>属性设为<code>self</code>：</p>

<p>```</p>

<pre><code>var addAV = CustomIOS7AlertView()
func insertNewObject(sender: AnyObject) {
    let textField = UITextField(frame:CGRectMake(0,0,290,50))
    textField.becomeFirstResponder()//获取当前焦点
    textField.placeholder = "question"
    textField.keyboardType = .Default
    textField.returnKeyType = .Done
    textField.delegate = self
    addAV.containerView = textField
    addAV.buttonTitles = ["OK","Cancel"]
    addAV.delegate = self
    addAV.useMotionEffects = true
    addAV.show()

}
</code></pre>

<p>```</p>

<p>然后让<code>MasterViewController</code>遵循<code>UITextFieldDelegate</code>协议，并实现下面两个协议中的方法：</p>

<p>```</p>

<pre><code>func textFieldDidBeginEditing(textField: UITextField!){
    let animationDuration:NSTimeInterval  = 1
    var frame = self.view.frame;
    frame.origin.y-=116
    frame.size.height+=116
    self.view.frame = frame;
    UIView.animateWithDuration(animationDuration){
        self.view.frame = frame;
    }
}

func textFieldShouldEndEditing(textField: UITextField!) -&gt; Bool{
    let animationDuration:NSTimeInterval  = 1
    var frame = self.view.frame;
    frame.origin.y+=116;
    frame.size.height-=116;
    self.view.frame = frame;
    //self.view移回原位置
    UIView.animateWithDuration(animationDuration){
        self.view.frame = frame;
    }
    textField.resignFirstResponder();
    return true
}
</code></pre>

<p>```</p>

<p>这里我将键盘高度硬编码为116，当<code>UITextField</code>开始编辑时获取焦点键盘弹出，背景上移；当其结束编辑时键盘消失，背景移回原位。</p>

<p>在Xcode6 beta2中的模拟器不是很好使，经常不能弹出键盘，这里给出的代码有很多疏漏，只提供个参考，主要是处理<code>UITextField</code>代理的思想</p>

<h2>随机选择算法</h2>

<p><code>DetailViewController</code>的内容跟<code>MasterViewController</code>内容很像，最大的区别在于多了一个从<code>Choice</code>数据中随机抽选的一个方法。因为是通过摇一摇的方式来触发随机算法，所以我们重载<code>motionBegan(motion: UIEventSubtype, withEvent event: UIEvent!)</code>方法来响应手机摇动：</p>

<p>```
override func motionBegan(motion: UIEventSubtype, withEvent event: UIEvent!) {</p>

<pre><code>    if motion == .MotionShake{

        let count = self.fetchedResultsController.fetchedObjects.count
        var arr = fetchedResultsController.fetchedObjects
        var sum:Int = 0
        for object : AnyObject in arr{
            sum+=(object as Choice).weight.integerValue
        }
        if sum&gt;0{
            var lucknum = arc4random()%UInt32(sum)
</code></pre>

<p>//                println(&ldquo;(lucknum)&rdquo;)</p>

<pre><code>            var num = 0
            var n:UInt32 = 0
            while lucknum&gt;0{
                if lucknum &lt;= n{
                    break
                }
                else{
                    num++
                    lucknum-=n
                    if num&gt;=count{
                        break
                    }
                    n = UInt32((arr[num] as Choice).weight.integerValue)
                }
            }
</code></pre>

<p>//                println(&ldquo;(num)&rdquo;)</p>

<pre><code>            var alertView = UIAlertView()
            alertView.alertViewStyle = .Default
            alertView.title = "恭喜"
            alertView.message = "\(detailItem!.content)的答案是：\n\((arr[num] as Choice).name)"
            alertView.addButtonWithTitle("OK")
            alertView.show()
        }

    }
}
</code></pre>

<p>```</p>

<p>前面提到过<code>NSFetchedResultsController</code>对象在执行<code>performFetch(error: NSErrorPointer) -&gt; Bool</code>方法后会将获取的数据存在<code>fetchedObjects</code>数组中，上面这段代码首先获取该问题对应的选项数量，并通过加权运算得到总的权重，然后通过随机数算法生成一个幸运数字，最后计算幸运数字落在哪个选项上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Initialization in Swift]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/24/initialization-in-swift/"/>
    <updated>2014-06-24T09:50:23+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/24/initialization-in-swift</id>
    <content type="html"><![CDATA[<p>本文参考自Swift文档，主要包括以下内容：</p>

<ul>
<li>简介</li>
<li>自定义构造过程</li>
<li>默认构造器</li>
<li>值类型的构造器代理</li>
<li>类的继承和构造过程</li>
<li>通过闭包和函数来设置属性的默认值</li>
</ul>


<!--more-->


<h2>简介</h2>

<p>构造过程是为了使用某个类、结构体或枚举类型的实例而进行的准备过程。这个过程包含了为实例中的每个属性设置初始值和为其执行必要的准备和初始化任务。</p>

<p>Swift中的构造器不像Objective-C那样有返回值，但是跟C++有点像：所有的构造器都以<code>init</code>命名，用参数列表来区分各个构造器</p>

<p>``` js
struct Fahrenheit {</p>

<pre><code>var temperature = 16.0
init() {
    temperature = 32.0
}
</code></pre>

<p>}
var f = Fahrenheit()
```</p>

<p><code>Fahrenheit</code>是一个结构体，与类一样，Swift中的值类型也有构造器和普通方法。上面的代码先是定义了<code>temperature</code>属性的默认值，然后又在构造器中将其赋值，最后<code>temperature</code>属性的值为32。对于<code>temperature</code>这种存储型属性，无论定义默认值还是在构造器中赋值，最终它们实现的效果是一样的。</p>

<p><strong>给存储型类型属性赋默认值或在初始构造器中设置初始值时，此属性的属性观察者不会被调用</strong></p>

<h2>自定义构造过程</h2>

<p>你可以定义一些带参数的构造器</p>

<p>```
struct Celsius {</p>

<pre><code>var temperatureInCelsius: Double = 0.0
init(fromFahrenheit fahrenheit: Double) {
    temperatureInCelsius = (fahrenheit - 32.0) / 1.8
}
init(fromKelvin kelvin: Double) {
    temperatureInCelsius = kelvin - 273.15
}
</code></pre>

<p>}
```
构造器的参数也跟Swift中的方法定义（注意不是函数）一样，也分内部和外部参数名。上面代码中两个构造器外部参数名不同，调用构造器的时候也是通过外部参数名来区分的：</p>

<p><code>
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius 是 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius 是 0.0”
</code>
如果不写外部参数名那么外部参数名就等于内部参数名。如果你不希望为构造器的某个参数提供外部名字，你还可以使用下划线<code>_</code>来显示描述它的外部名：</p>

<p>```
struct Color {</p>

<pre><code>let red = 0.0, green = 0.0, blue = 0.0
init(red: Double, green: Double, blue: Double) {
    self.red   = red
    self.green = green
    self.blue  = blue
}
</code></pre>

<p>}
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
<code>``
你会发现构造器的第一个内部参数名也会默认作为其外部参数名供调用，这一点与方法不同（方法不会默认将第一个内部参数名作为外部参数名使用），因为方法名可以在结尾加上介词来烘托出第一个参数的名字，这样就不需要为第一个参数弄一个外部参数名了，但是构造器只能用</code>init`关键字来定义。</p>

<p>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性&mdash;不管是因为它无法在初始化时赋值，还是因为它可以在之后某个时间点可以赋值为空&mdash;你都需要将它定义为可选类型<code>optional type</code>。可选类型的属性将自动初始化为空<code>nil</code>，表示这个属性是故意在初始化时设置为空的。</p>

<p>```
class SurveyQuestion {</p>

<pre><code>let text: String
var response: String?
init(text: String) {
    self.text = text
}
func ask() {
    println(text)
}
</code></pre>

<p>}
let cheeseQuestion = SurveyQuestion(text: &ldquo;Do you like cheese?&rdquo;)
cheeseQuestion.ask()
// 输出 &ldquo;Do you like cheese?&rdquo;
cheeseQuestion.response = &ldquo;Yes, I do like cheese.
```</p>

<p>调查问题在问题提出之后，我们才能得到回答。所以我们将属性回答response声明为String?类型，或者说是可选字符串类型optional String。当SurveyQuestion实例化时，它将自动赋值为空nil，表明暂时还不存在此字符串。<br/>
只要在构造过程结束前常量的值能确定，你可以在构造过程中的任意时间点修改常量属性的值。尽管text属性是常量，我们仍然可以在其类的构造器中设置它的值。<strong>对某个类实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</strong></p>

<h2>默认构造器</h2>

<p>Swift将为所有属性已提供默认值的且自身没有定义任何构造器的结构体或基类，提供一个默认的构造器。这个默认构造器将简单的创建一个所有属性值都设置为默认值的实例：</p>

<p>```
class ShoppingListItem {</p>

<pre><code>var name: String?
var quantity = 1
var purchased = false
</code></pre>

<p>}
var item = ShoppingListItem()
<code>``
</code>ShoppingListItem<code>类没有父类（是基类），所有属性都有默认值（可选属性默认值为</code>nil`），所以可以直接调用默认的无参数构造器来初始化。<br/>
除上面提到的默认构造器，如果结构体对所有存储型属性提供了默认值且自身没有提供定制的构造器，它们能自动获得一个<strong>逐一成员构造器（Memberwise Initializers）</strong>：</p>

<p>```
struct Size {</p>

<pre><code>var width = 0.0, height = 0.0
</code></pre>

<p>}
let twoByTwo = Size(width: 2.0, height: 2.0)
```
逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>

<h2>值类型的构造器代理</h2>

<p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复：</p>

<p>```
struct Size {</p>

<pre><code>var width = 0.0, height = 0.0
</code></pre>

<p>}
struct Point {</p>

<pre><code>var x = 0.0, y = 0.0
</code></pre>

<p>}
struct Rect {</p>

<pre><code>var origin = Point()
var size = Size()
init() {}
init(origin: Point, size: Size) {
    self.origin = origin
    self.size = size
}
init(center: Point, size: Size) {
    let originX = center.x - (size.width / 2)
    let originY = center.y - (size.height / 2)
    self.init(origin: Point(x: originX, y: originY), size: size)
}
</code></pre>

<p>}
<code>``
在值类型中，如果你添加了自定义构造器（如</code>init(center: Point, size: Size)<code>），Swift不会再为结构体生成一个默认构造器和逐一成员构造器，所以我们自己定义了</code>init()<code>和</code>init(origin: Point, size: Size)<code>，他们与自动生成的默认构造器和逐一成员构造器是一样的。这样子会显得很麻烦，我们可以将自定义构造器</code>init(center: Point, size: Size)<code>写在结构体</code>Rect<code>的扩展（</code>extension`）里，这样就不用自己把默认构造器和逐一成员构造器写一遍了。</p>

<p>构造器<code>init(center:size:)</code>先通过<code>center</code>和<code>size</code>的值计算出<code>origin</code>的坐标。然后再调用（或代理给）<code>init(origin:size:)</code>构造器来将新的<code>origin</code>和<code>size</code>值赋值到对应的属性中。因为值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给本身提供的其它构造器：你只能在构造器内部调用<code>self.init</code></p>

<h2>类的继承和构造过程</h2>

<p>类里面的所有存储型属性&mdash;包括所有继承自父类的属性&mdash;都必须在构造过程中设置初始值。</p>

<p>Swift 提供了两种类型的类构造器来确保所有类实例中存储型属性都能获得初始值，它们分别是指定构造器(<code>Designated Initializers</code>)和便利构造器(<code>Convenience Initializers</code>)。</p>

<h3>指定构造器和便利构造器</h3>

<p>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。<strong>每一个类都必须拥有至少一个指定构造器。</strong></p>

<p>便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入的实例。</p>

<p>类的指定构造器的写法跟值类型简单构造器一样，便利构造器也采用相同样式的写法，但需要在init关键字之前放置convenience关键字：</p>

<p>```
convenience init(parameters) {</p>

<pre><code>statements
</code></pre>

<p>}
```</p>

<h3>构造器链</h3>

<p>为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：</p>

<ol>
<li>指定构造器必须调用其直接父类的的指定构造器。</li>
<li>便利构造器必须调用同一类中定义的其它构造器。</li>
<li>便利构造器必须最终以调用一个指定构造器结束。</li>
</ol>


<p>一个更方便记忆的方法是:</p>

<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializerDelegation01_2x.png" alt="" />
举个栗子：</p>

<p>```
class Food {</p>

<pre><code>var name: String
init(name: String) {
    self.name = name
}
convenience init() {
    self.init(name: "[Unnamed]")
}
</code></pre>

<p>}
let namedMeat = Food(name: &ldquo;Bacon&rdquo;)
// namedMeat 的名字是 &ldquo;Bacon”
let mysteryMeat = Food()
// mysteryMeat 的名字是 [Unnamed]
```</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample01_2x.png" alt="" /></p>

<h3>两段式构造过程</h3>

<p>Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性通过引入它们的类的构造器来设置初始值。当每一个存储型属性值被确定后，第二阶段开始，它给每个类一次机会在新实例准备使用之前进一步定制它们的存储型属性。<br/>
下图展示了在假定的子类和父类之间构造的阶段1：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/twoPhaseInitialization01_2x.png" alt="" /></p>

<p>指定构造器将确保所有子类的属性都有值，然后它将调用父类的指定构造器，并沿着造器链一直往上完成父类的构建过程。一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，而阶段1也已完成。</p>

<p>以下展示了相同构造过程的阶段2：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/twoPhaseInitialization02_2x.png" alt="" /></p>

<p>父类中的指定构造器现在有机会进一步来定制实例（尽管它没有这种必要）。</p>

<p>一旦父类中的指定构造器完成调用，子类的构指定构造器可以执行更多的定制操作（同样，它也没有这种必要）。</p>

<p>最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。</p>

<p>两段式构造过程是基于<strong>安全检查</strong>的，可以简单的理解为：</p>

<ul>
<li>指定构造器初始化顺序：初始化类自己引入的属性->向上代理调用父类指定构造器->为继承的属性设置新值</li>
<li>便利构造器初始化顺序：代理调用同一类中的其它构造器->为任意属性赋新值</li>
<li>构造器在第一阶段构造完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用self的值。</li>
</ul>


<h3>构造器的继承和重载</h3>

<p><strong>跟 Objective-C 中的子类不同，Swift 中的子类不会默认继承父类的构造器。</strong>这是为了防止你想初始化一个很牛逼的类，但是调用的却是它继承于父类的菜逼构造器，那将会是个悲剧。</p>

<p><strong>但是如果特定条件可以满足，父类构造器是可以被自动继承的：</strong></p>

<ol>
<li>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</li>
<li>如果子类提供了所有父类指定构造器的实现&mdash;不管是通过规则1继承过来的，还是通过自定义实现的&mdash;它将自动继承所有父类的便利构造器。</li>
</ol>


<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。子类可以通过定义便利构造器来实现父类中的指定构造器，来部分满足规则2</p>

<p>如果你需要重写一个跟父类一样的构造器，无论是指定构造器还是便利构造器，不同于重载方法、属性和下标，在重载构造器时你没有必要使用关键字<code>override</code></p>

<p>还记得之前指定的<code>Food</code>类吧，现在它多了一个子类<code>RecipeIngredient</code>:</p>

<p>```
class RecipeIngredient: Food {</p>

<pre><code>var quantity: Int
init(name: String, quantity: Int) {
    self.quantity = quantity
    super.init(name: name)
}
convenience init(name: String) {
    self.init(name: name, quantity: 1)
}
</code></pre>

<p>}
<code>``
可以看出来</code>RecipeIngredient<code>类的指定构造器和便利构造器都符合两段式构造安全检查，并且便利构造器跟</code>Food<code>类中的指定构造器具有相同的参数，尽管</code>RecipeIngredient<code>这个构造器是便利构造器，</code>RecipeIngredient<code>依然提供了对所有父类指定构造器的实现。因此，</code>RecipeIngredient<code>也能自动继承了所有父类的便利构造器(也就是</code>init()`):</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample02_2x.png" alt="" /></p>

<p>上图中<code>RecipeIngredient</code>类继承的init()函数版本跟Food提供的版本是一样的，除了它是将任务代理给RecipeIngredient版本的init(name: String)而不是Food提供的版本。</p>

<p>食材都已经建立好了，下面开始采购吧！我们需要一个购物单，购物单中每一项是这样子的：</p>

<p>```
class ShoppingListItem: RecipeIngredient {</p>

<pre><code>var purchased = false
var description: String {
var output = "\(quantity) x \(name.lowercaseString)"
    output += purchased ? " ✔" : " ✘"
    return output
}
</code></pre>

<p>}
```</p>

<p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，ShoppingListItem将自动继承所有父类中的指定构造器和便利构造器。</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample03_2x.png" alt="" /></p>

<p>你可以使用全部三个继承来的构造器来创建ShoppingListItem的新实例：</p>

<p>```
var breakfastList = [</p>

<pre><code>ShoppingListItem(),
ShoppingListItem(name: "Bacon"),
ShoppingListItem(name: "Eggs", quantity: 6),
</code></pre>

<p>]
breakfastList[0].name = &ldquo;Orange juice&rdquo;
breakfastList[0].purchased = true
for item in breakfastList {</p>

<pre><code>println(item.description)
</code></pre>

<p>}
// 1 x orange juice ✔
// 1 x bacon ✘
// 6 x eggs ✘
```</p>

<h2>通过闭包和函数来设置属性的默认值</h2>

<p>如果某个存储型属性的默认值需要特别的定制或准备，你就可以使用闭包或全局函数来为其属性提供定制的默认值。每当某个属性所属的新类型实例创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p>

<p>```
class SomeClass {</p>

<pre><code>let someProperty: SomeType = {
    // 在这个闭包中给 someProperty 创建一个默认值
    // someValue 必须和 SomeType 类型相同
    return someValue
    }()
</code></pre>

<p>}
```</p>

<p>注意闭包结尾的大括号后面接了一对空的小括号。这是用来告诉 Swift 需要立刻执行此闭包。如果你忽略了这对括号，相当于是将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>

<p>如果你使用闭包来初始化属性的值，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能够在闭包里访问其它的属性，就算这个属性有默认值也不允许。同样，你也不能使用隐式的self属性，或者调用其它的实例方法。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Optionals and Optional Chaining in Swift]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/17/optionals-and-optional-chaining-in-swift/"/>
    <updated>2014-06-17T20:42:17+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/17/optionals-and-optional-chaining-in-swift</id>
    <content type="html"><![CDATA[<p>可选类型（<code>Optionals</code>）在Swift中用于处理值可能缺失的情况，也就是说可能存在没有值的情况。C 和 Objective-C 中并没有可选类型这个概念。但在Objective-C中，一个方法的返回值可以是一个对象或<code>nil</code>值（<code>nil</code>表示缺少一个合法对象），而对象只是针对类而言，结构体、基本C类型和枚举并不适用<code>nil</code>来表示值的缺失，对于这些类型，Objective-C 方法一般会返回一个特殊值（比如<code>NSNotFound</code>）来暗示值缺失。这种表示“值缺失”方法不统一的局面使得调用方法的程序员蛋疼了-需要针对不同情况进行处理-但随着可选类型的诞生，这种情形在Swift中得到解决，<code>Optionals</code>可以表示任意类型值的缺失。</p>

<!--more-->


<h2>可选类型（Optionals）</h2>

<p>在Swift中，有时候需要把内容为数字的字符串转化成数字：</p>

<p><code>js
let possibleNumber = "123"
let convertedNumber = possibleNumber.toInt()
// convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int"
</code>
因为Swift是类型安全的语言，为了保证转化过程中不出错，<code>toInt()</code>方法返回的是一个<code>Optional&lt;Int&gt;</code>(也可写成<code>Int?</code>)类型的实例。如果被转化的字符串不是一个数字（比如是“hello world”），那样<code>toInt()</code>返回的内容将不含有<code>Int</code>值。这保证了整个过程不报错，下面我们可以“优雅的”检查下<code>convertedNumber</code>是否有<code>Int</code>值：</p>

<p>```
if convertedNumber {</p>

<pre><code>println("\(possibleNumber) has an integer value of \(convertedNumber!)")
</code></pre>

<p>} else {</p>

<pre><code>println("\(possibleNumber) could not be converted to an integer")
</code></pre>

<p>}
// 输出 &ldquo;123 has an integer value of 123&rdquo;
```
当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）</p>

<p>这里细心的同学可能看不懂了：<code>convertedNumber</code>不是应该是一个可选的整型值么，怎么还能作为条件判断的逻辑值（Bool）呢？让我们来分析下<code>Optional</code>类型的真身：</p>

<p>```
enum Optional<T> : LogicValue, Reflectable {</p>

<pre><code>case None
case Some(T)
init()
init(_ some: T)

/// Allow use in a Boolean context.
func getLogicValue() -&gt; Bool

/// Haskell's fmap, which was mis-named
func map&lt;U&gt;(f: (T) -&gt; U) -&gt; U?
func getMirror() -&gt; Mirror
</code></pre>

<p>}
```</p>

<p>原来可选类型是本质是一个枚举类型，包含两个成员：<code>None</code>和<code>Some</code>，其中<code>Some</code>成员还有一个类型为泛型<code>T</code>的关联值（Associated Values）。它之所以能够当做条件判断语句是因为它遵循了<code>LogicValue</code>协议：</p>

<p><code>``
/// Protocol describing types that can be used as logical values within
/// a condition.
///
/// Types that conform to the</code>LogicValue<code>protocol can be used as
/// condition in various control statements (</code>if<code>,</code>while<code>, C-style
///</code>for<code>) as well as other logical value contexts (e.g.,</code>case`
/// statement guards).
protocol LogicValue {</p>

<pre><code>func getLogicValue() -&gt; Bool
</code></pre>

<p>}
<code>``
看了Swift对</code>LogicValue<code>协议的描述，这下子应该明白了吧。光凭猜测大约知道：当可选类型有值的时候其实是</code>Some<code>成员，并在构造器</code>init(_ some: T)<code>调用时将值存储在</code>Some<code>成员的关联值中，此时</code>getLogicValue()<code>方法返回true；当可选类型没有值的时候其实是</code>None<code>成员，并在构造器</code>init()<code>调用时将</code>nil<code>给了</code>None<code>成员，具体细节不是很清楚。  
看得出可选类型的设计借鉴了Haskell语言，至于</code>nil`到底是什么：</p>

<p><code>
/// A null sentinel value.
var nil: NilType { get }
</code>
<code>nil</code>是<code>NilType</code>类型唯一的实例，好特殊啊。Swift 的<code>nil</code>和 Objective-C 中的<code>nil</code>并不一样。在 Objective-C 中，<code>nil</code>是一个指向不存在对象的指针。在 Swift 中，<code>nil</code>不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为<code>nil</code>，不只是对象类型。</p>

<p><strong>在Xcode6Beta3发布后，Swift中的nil类型被修改为字面量了，不再是NilType的实例</strong></p>

<p><strong>可选类型默认值为<code>nil</code></strong></p>

<p>除了用if语句判断和强制解析来获取可选类型中的值，还可以用可选绑定的方式来来判断可选类型是否包含值：</p>

<p>```
if let constantName = someOptional {</p>

<pre><code>statements
</code></pre>

<p>}
```
于是之前的例子可以可以改写为：</p>

<p>```
if let actualNumber = possibleNumber.toInt() {</p>

<pre><code>println("\(possibleNumber) has an integer value of \(actualNumber)")
</code></pre>

<p>} else {</p>

<pre><code>println("\(possibleNumber) could not be converted to an integer")
</code></pre>

<p>}
// 输出 &ldquo;123 has an integer value of 123&rdquo;
```</p>

<p>如果<code>possibleNumber.toInt</code>返回的可选<code>Int</code>包含一个值，创建一个叫做<code>actualNumber</code>的新常量并将可选包含的值赋给它。它已经被可选类型包含的值初始化过，所以不需要再使用<code>!</code>后缀来获取它的值。</p>

<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。这种类型的可选状态被定义为<strong>隐式解析可选类型</strong>（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型。</p>

<p><code>
let possibleString: String? = "An optional string."
println(possibleString!) // 需要惊叹号来获取值
// 输出 "An optional string."
let assumedString: String! = "An implicitly unwrapped optional string."
println(assumedString)  // 不需要感叹号
// 输出 "An implicitly unwrapped optional string."
</code>
你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：</p>

<p>```
if assumedString {</p>

<pre><code>println(assumedString)
</code></pre>

<p>}
// 输出 &ldquo;An implicitly unwrapped optional string.&rdquo;
```
你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：</p>

<p>```
if let definiteString = assumedString {</p>

<pre><code>println(definiteString)
</code></pre>

<p>}
// 输出 &ldquo;An implicitly unwrapped optional string.&rdquo;
<code>``
可能看到这里你会觉得隐式解析可选类型的存在意义是什么？为何不直接用普通的非可选类型呢？其实</code>Implicitly Unwrapped Optionals`被用于类的初始化方法中，避免循环引用:</p>

<p>```
class Country {</p>

<pre><code>let name: String
let capitalCity: City!
init(name: String, capitalName: String) {
    self.name = name
    self.capitalCity = City(name: capitalName, country: self)
}
</code></pre>

<p>}</p>

<p>class City {</p>

<pre><code>let name: String
unowned let country: Country
init(name: String, country: Country) {
    self.name = name
    self.country = country
}
</code></pre>

<p>}</p>

<p>var country = Country(name: &ldquo;Canada&rdquo;, capitalName: &ldquo;Ottawa&rdquo;)
println(&ldquo;(country.name)&rsquo;s capital city is called (country.capitalCity.name)&rdquo;)
// prints &ldquo;Canada&rsquo;s capital city is called Ottawa”</p>

<p>```</p>

<p>因为编译器会将其认为默认<code>nil</code>，不需赋值就可以完成类的初始化，在例子中<code>capitalCity</code>还没被赋值时<code>Country</code>类就已经初始化并可以被引用；这样就能实现一行代码建立<code>Country</code>和<code>City</code>实例而不造成强引用循环。有关ARC的更多知识可以看看这篇<a href="http://yulingtianxia.com/blog/2014/06/17/swiftzhong-de-arc/">文章</a></p>

<h2>可选链（Optional Chaining）</h2>

<p>可选链（Optional Chaining）是一种可以请求和调用属性、方法及下标的过程，它的可选性体现于请求或调用的目标当前可能为空（nil）。如果可选的目标有值，那么调用就会成功；相反，如果选择的目标为空（nil），则这种调用将返回空（nil）。多次请求或调用可以被链接在一起形成一个链，如果任何一个节点为空（nil）将导致整个链失效。</p>

<p>可能官方的定义不接地气，先来个例子做铺垫：</p>

<p>```
class Person {</p>

<pre><code>var residence: Residence?
</code></pre>

<p>}</p>

<p>class Residence {</p>

<pre><code>var rooms = Room[]()
var numberOfRooms: Int {
return rooms.count
}
subscript(i: Int) -&gt; Room {
    return rooms[i]
}
func printNumberOfRooms() {
    println("The number of rooms is \(numberOfRooms)")
}
var address: Address?
</code></pre>

<p>}</p>

<p>class Room {</p>

<pre><code>let name: String
init(name: String) { self.name = name }
</code></pre>

<p>}</p>

<p>class Address {</p>

<pre><code>var buildingName: String?
var buildingNumber: String?
var street: String?
func buildingIdentifier() -&gt; String? {
    if buildingName {
        return buildingName
    } else if buildingNumber {
        return buildingNumber
    } else {
        return nil
    }
}
</code></pre>

<p>}
```</p>

<p>人（<code>Person</code>）可能会拥有住所（<code>Residence</code>），一个住所肯定会有一些带名字的房间（<code>Room</code>），还有可能注明所在地址（<code>Address</code>）。住所还提供了获取房间数目的方法，并能通过下标访问某个房间，而地址包含了一些可选的信息。</p>

<p>PS：不要嫌我墨迹，官方文档比我墨迹多了。。。</p>

<p>现在我造个人（邪恶的孩子面壁思过去！），就叫john</p>

<p><code>
let john = Person()
</code>
如果我们想知道john同学家房子大不大，有几个房间啊？但是直接问不太好，万一john家里穷漂泊不定四海为家，那不就玩脱了么？</p>

<p><code>
let roomCount = john.residence!.numberOfRooms
//将导致运行时错误
</code></p>

<p>所以还是先问问他家有没有房子吧：</p>

<p>```
if let roomCount = john.residence?.numberOfRooms {</p>

<pre><code>println("John's residence has \(roomCount) room(s).")
</code></pre>

<p>} else {</p>

<pre><code>println("我造john的时候没给他分房子，这可怜孩子！")
</code></pre>

<p>}
// 打印 &ldquo;我造john的时候没给他分房子，这可怜孩子！&rdquo;
<code>``
可选链提供了一种另一种获得</code>numberOfRooms<code>的方法。利用可选链，使用</code>?<code>来代替原来</code>!<code>的位置，因为这种尝试获得</code>numberOfRooms<code>的操作有可能失败，可选链会返回</code>Int?<code>类型值。要注意的是，虽然</code>numberOfRooms<code>是非可选</code>Int<code>，这一点也成立。只要是通过可选链的请求就意味着最后</code>numberOfRooms<code>总是返回一个</code>Int?<code>而不是</code>Int`。</p>

<p>我们也可以在可选链上调用方法：</p>

<p>```
if john.residence?.printNumberOfRooms() {</p>

<pre><code>println("It was possible to print the number of rooms.")
</code></pre>

<p>} else {</p>

<pre><code>println("It was not possible to print the number of rooms.")
</code></pre>

<p>}
// 打印 &ldquo;It was not possible to print the number of rooms.&rdquo;
```</p>

<p>虽然<code>printNumberOfRooms</code>方法无返回值，但是它有一个隐式的返回类型<code>Void</code>，在可选链上调用后返回类型就成了<code>Void?</code>，既然是可选类型，就可以放到if语句条件判断中啦！</p>

<p>现在想看看john家第一间房子名字叫啥，但却怕人家没房子遭遇尴尬，不用怕：</p>

<p>```
if let firstRoomName = john.residence?[0].name {</p>

<pre><code>println("The first room name is \(firstRoomName).")
</code></pre>

<p>} else {</p>

<pre><code>println("连房子都没有更别提第一间房间名了！")
</code></pre>

<p>}
// 打印 &ldquo;连房子都没有更别提第一间房间名了！&rdquo;
<code>``
在下标调用中可选链的问号直接跟在</code>john.residence<code>的后面，在下标中括号的前面，因为</code>john.residence<code>才是可选链试图获得的可选值。（关键是</code>Person<code>不一定有</code>residence<code>，但</code>Residence<code>肯定有</code>rooms`）</p>

<p>造个john玩了人家这么久，还不快给人家分套房子！（其实是为了演示后面的<code>Address</code>）</p>

<p>```
let johnsHouse = Residence()
johnsHouse.rooms += Room(name: &ldquo;Living Room&rdquo;)
johnsHouse.rooms += Room(name: &ldquo;Kitchen&rdquo;)
john.residence = johnsHouse</p>

<p>if let firstRoomName = john.residence?[0].name {</p>

<pre><code>println("The first room name is \(firstRoomName).")
</code></pre>

<p>} else {</p>

<pre><code>println("Unable to retrieve the first room name.")
</code></pre>

<p>}
// 打印 &ldquo;The first room name is Living Room."。
```</p>

<p>现在john乔迁新居奔小康了，快问问他家地址，好串个门</p>

<p>```
let johnsAddress = Address()
johnsAddress.buildingName = &ldquo;The Larches&rdquo;
johnsAddress.street = &ldquo;Laurel Street&rdquo;
john.residence!.address = johnsAddress
if let johnsStreet = john.residence?.address?.street {</p>

<pre><code>println("John's street name is \(johnsStreet).")
</code></pre>

<p>} else {</p>

<pre><code>println("Unable to retrieve the address.")
</code></pre>

<p>}
// 打印 &ldquo;John&rsquo;s street name is Laurel Street.&rdquo;
<code>``
值得注意的是</code>john.residence<code>属性是一个可选类型并且已经不为</code>nil<code>(刚刚奔小康了嘛)，因此你需要在它获取</code>address<code>属性之前使用</code>!`强制解析以获得它的实际值。</p>

<p>虽然这条可选链上有两个问号（两层可选链），但其返回类型依然是可选类型（<code>String?</code>），而不是可选类型的嵌套（<code>String??</code>即<code>Optional&lt;Optional&lt;String&gt;&gt;</code>）。你可以将多层可选链连接在一起，可以掘取模型内更下层的属性方法和下标。然而多层可选链不能再添加比已经返回的可选值更多的层。 也就是说：</p>

<p><strong>如果你试图获得的类型不是可选类型，由于使用了可选链它将变成可选类型。 如果你试图获得的类型已经是可选类型，由于可选链它也不会提高可选性。</strong></p>

<p>前面的例子解释了如何通过可选链来获得可选类型属性值。你也可以通过可选链调用一个返回可选类型值的方法并按需链接该方法的返回值。 如上所述，<code>buildingIdentifier</code>方法在可选链调用后最终的返回值类型依然是<code>String?</code>:</p>

<p>```
if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {</p>

<pre><code>println("John's building identifier is \(buildingIdentifier).")
</code></pre>

<p>}
// 打印 &ldquo;John&rsquo;s building identifier is The Larches.&rdquo;
```
如果你还想进一步对方法返回值执行可选链，将可选链问号符放在方法括号的后面：</p>

<p>```
if let upper = john.residence?.address?.buildingIdentifier()?.uppercaseString {</p>

<pre><code>println("John's uppercase building identifier is \(upper).")
</code></pre>

<p>}
// 打印 &ldquo;John&rsquo;s uppercase building identifier is THE LARCHES.&rdquo;
<code>``
你将可选链问号符放在括号后面是因为你想要链接的可选值是</code>buildingIdentifier<code>方法的返回值，不是</code>buildingIdentifier`方法本身。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中的ARC]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/17/swiftzhong-de-arc/"/>
    <updated>2014-06-17T10:32:38+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/17/swiftzhong-de-arc</id>
    <content type="html"><![CDATA[<p>Objective-C中的ARC被Swift很好的继承下来了，本文参考自Swift文档网上的翻译，主要重点记录下Swift中的ARC与OC对比需要注意的地方。</p>

<!--more-->


<h2>简介</h2>

<p>当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>

<h2>类实例之间强引用循环的产生</h2>

<p>如果你对OC中的强引用循环很了解，可以直接跳过这节。</p>

<p>但是如果两个类的实例之间互相引用，这样就产生了强引用循环。下面展示了一个不经意产生强引用循环的例子。例子定义了两个类：<code>Person</code>和<code>Apartment</code>，用来建模公寓和它其中的居民:</p>

<p>``` js
class Person {</p>

<pre><code>let name: String
init(name: String) { self.name = name }
var apartment: Apartment?
deinit { println("\(name) is being deinitialized") }
</code></pre>

<p>}</p>

<p>class Apartment {</p>

<pre><code>let number: Int
init(number: Int) { self.number = number }
var tenant: Person?
deinit { println("Apartment #\(number) is being deinitialized") }
</code></pre>

<p>}
```</p>

<p>接下来的代码片段定义了两个可选类型的变量<code>john</code>和<code>number73</code>,并分别被设定为下面的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为<code>nil</code>，并为可选的（让它们可选是为了以后能销毁，为了演示程序）：</p>

<p><code>
var john: Person?
var number73: Apartment?
</code></p>

<p>现在你可以创建特定的<code>Person</code>和<code>Apartment</code>实例并将类实例赋值给<code>john</code>和<code>number73</code>变量：</p>

<p><code>
john = Person(name: "John Appleseed")
number73 = Apartment(number: 73)
</code></p>

<p>在<code>john</code>和<code>number73</code>互相引用之前，它们的强引用关系是这样的：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png" alt="" /></p>

<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来强制解析可选变量<code>john</code>和<code>number73</code>中的实例：</p>

<p><code>
john!.apartment = number73
number73!.tenant = john
</code>
在将两个实例联系在一起之后，强引用的关系变成了这样：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png" alt="" /></p>

<p>这样即使让<code>john</code>和<code>number73</code>断开它们持有的强引用，内存中的那两个<code>Person</code>和<code>Apartment</code>实例并不会销毁，因为它们互相引用，引用计数都为1：</p>

<p><code>
john = nil
number73 = nil
</code>
当你把这两个变量设为<code>nil</code>时，没有任何一个析构函数被调用。强引用循环阻止了<code>Person</code>和<code>Apartment</code>类实例的销毁，并在你的应用程序中造成了内存泄漏。</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png" alt="" /></p>

<h2>如何解决实例间强引用循环</h2>

<h3>弱引用</h3>

<p>跟OC中的弱引用相似，声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。弱引用不会牢牢保持住引用的实例，并且不会阻止 ARC 销毁被引用的实例。因为弱引用的值会变化并可能为<code>nil</code>，所以弱引用不能是常量，必须是可选类型（Optional）。因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。</p>

<p>下面的例子跟上面<code>Person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>属性被声明为弱引用：</p>

<p>```
class Person {</p>

<pre><code>let name: String
init(name: String) { self.name = name }
var apartment: Apartment?
deinit { println("\(name) is being deinitialized") }
</code></pre>

<p>}
class Apartment {</p>

<pre><code>let number: Int
init(number: Int) { self.number = number }
weak var tenant: Person?
deinit { println("Apartment #\(number) is being deinitialized") }
</code></pre>

<p>}
<code>``
然后跟之前一样，建立两个变量（</code>john<code>和</code>number73`）之间的强引用，并关联两个实例：</p>

<p>```
var john: Person?
var number73: Apartment?</p>

<p>john = Person(name: &ldquo;John Appleseed&rdquo;)
number73 = Apartment(number: 73)</p>

<p>john!.apartment = number73
number73!.tenant = john
```
现在的引用关系如下：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png" alt="" /></p>

<p>当<code>john</code>的强引用断开后，引用关系变成了这样子：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png" alt="" /></p>

<p>因为没有强引用指向<code>Person</code>实例，它的引用计数为0，所以该实例会被销毁。因此<code>number73</code>指向的<code>Apartment</code>实例的的引用计数会变为1，因为<code>Person</code>实例销毁后，其<code>apartment</code>属性对<code>Apartment</code>实例的强引用也会断开。此时如果再断开<code>number73</code>对<code>Apartment</code>实例的强引用：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png" alt="" /></p>

<p><code>Apartment</code>实例因为引用计数为0，会被销毁，到此为止强引用循环被打破。</p>

<h3>无主引用</h3>

<p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的（不能为<code>nil</code>）。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字<code>unowned</code>表示这是一个无主引用。</p>

<p>下面的例子定义了两个类，<code>Customer</code>和<code>CreditCard</code>，模拟了银行客户和客户的信用卡。一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。所以<code>Customer</code>类的<code>card</code>属性可以为<code>nil</code>，但是<code>CreditCard</code>类的<code>customer</code>属性不能为<code>nil</code>，所以创建CreditCard实例的时候必须给<code>customer</code>属性赋值避免其为<code>nil</code>。将<code>customer</code>属性定义为无主引用，用以避免循环强引用：</p>

<p>```
class Customer {</p>

<pre><code>let name: String
var card: CreditCard?
init(name: String) {
    self.name = name
}
deinit { println("\(name) is being deinitialized") }
</code></pre>

<p>}
class CreditCard {</p>

<pre><code>let number: Int
unowned let customer: Customer
init(number: Int, customer: Customer) {
    self.number = number
    self.customer = customer
}
deinit { println("Card #\(number) is being deinitialized") }
</code></pre>

<p>}
var john: Customer?
john = Customer(name: &ldquo;John Appleseed&rdquo;)
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
```
关联两个实例后，引用关系如下：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png" alt="" /></p>

<p>由于<code>customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png" alt="" /></p>

<p>于是<code>Customer</code>实例被销毁，这样又导致没有强引用指向<code>CreditCard</code>实例，最后<code>CreditCard</code>实例也被销毁了，这样说明强引用循环被打破了。</p>

<h3>无主引用以及隐式解析可选属性</h3>

<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，而每一个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>country</code>属性：</p>

<p>```
class Country {</p>

<pre><code>let name: String
let capitalCity: City!
init(name: String, capitalName: String) {
    self.name = name
    self.capitalCity = City(name: capitalName, country: self)
}
</code></pre>

<p>}
class City {</p>

<pre><code>let name: String
unowned let country: Country
init(name: String, country: Country) {
    self.name = name
    self.country = country
}
</code></pre>

<p>}
<code>``
在这种场景中，两个属性都必须有值，并且初始化完成后不能为</code>nil`。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>

<p>隐式解析可选(<code>Implicitly Unwrapped Optionals</code>)被用于类的初始化方法中，避免循环引用，因为编译器会将其认为默认<code>nil</code>，不需赋值就可以完成类的初始化，在例子中一旦<code>name</code>属性被赋值后(但<code>capitalCity</code>还没被赋值时)<code>Country</code>类就已经初始化并且自身（<code>self</code>）可以被引用；这样就能实现一行代码建立<code>Country</code>和<code>City</code>实例而不造成强引用循环。</p>

<p><code>
var country = Country(name: "Canada", capitalName: "Ottawa")
println("\(country.name)'s capital city is called \(country.capitalCity.name)")
// prints "Canada's capital city is called Ottawa"
</code>
使用隐式解析可选值的意义在于满足了两个类构造函数的需求。<code>capitalCity</code>属性在初始化完成后，能像非可选值一样使用和存取同时还避免了循环强引用。</p>

<h3>总结</h3>

<p><code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>

<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>，而另一个属性的值不允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合通过无主引用来解决。</p>

<p><code>Country</code>和<code>City</code>的例子展示了两个属性的值都不允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>

<h2>闭包引起的强引用循环</h2>

<p>强引用循环还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如<code>self.someMethod</code>。这两种情况都导致了闭包 “捕获" <code>self</code>，因为闭包也是引用类型，从而产生了强引用循环。在Swift中闭包如果想使用外部的实例，不必像OC中的Block那样在外部实例前加<code>__block</code>加以修饰，而是可以直接用“值捕获”的方式捕获到闭包外面的实例。Swift 会决定捕获引用还是拷贝值，并负责管理内存释放。</p>

<p>Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod（而不只是someProperty或someMethod）。这提醒你可能会不小心就捕获了self。</p>

<p>在OC中也存在<code>Block</code>中引用<code>self</code>或<code>self</code>的属性而导致<code>self</code>被<code>Block</code> retain，进而产生引用循环，这也是为什么代理属性都被声明为<code>weak</code>的原因。</p>

<p>下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 中的一个单独的元素：</p>

<p>```
class HTMLElement {</p>

<pre><code>let name: String
let text: String?

@lazy var asHTML: () -&gt; String = {
    if let text = self.text {
        return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
    } else {
        return "&lt;\(self.name) /&gt;"
    }
}

init(name: String, text: String? = nil) {
    self.name = name
    self.text = text
}

deinit {
    println("\(name) is being deinitialized")
}
</code></pre>

<p>}
```</p>

<p><code>HTMLElement</code>定义了一个<code>lazy</code>属性<code>asHTML</code>。这个属性引用了一个闭包，将<code>name</code>和<code>text</code>组合成 HTML 字符串片段。该属性是<code>() -&gt; String</code>类型，或者可以理解为“一个没有参数，返回<code>String</code>的函数”。因为该闭包无参数并可推断出返回值类型，所以采取了简写，省略了关键字<code>in</code>和闭包的参数和返回值类型声明。</p>

<p><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要处理为HTML输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>

<p>下面的代码展示了如何用HTMLElement类创建实例并打印消息</p>

<p><code>
var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
println(paragraph!.asHTML())
// prints"hello, world"
</code></p>

<p>不幸的是，上面写的HTMLElement类产生了类实例和asHTML默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png" alt="" /></p>

<p>虽然闭包多次使用了<code>self</code>，它只捕获<code>HTMLElement</code>实例的一个强引用。如果设置<code>paragraph</code>变量为<code>nil</code>，打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMLElement</code>实例和它的闭包都不会被销毁，也是因为强引用循环</p>

<h2>解决闭包引起的循环强引用</h2>

<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包捕获列表（closuer capture list）</p>

<h3>定义捕获列表</h3>

<p>捕获列表放置在闭包参数列表和返回类型之前，列表中每项都是由weak或unowned关键字和实例的引用（如self或someInstance）成对组成。每项都通过逗号分开写在方括号中。</p>

<p>```
@lazy var someClosure: (Int, String) &ndash;> String = {</p>

<pre><code>[unowned self] (index: Int, stringToProcess: String) -&gt; String in
// closure body goes here
</code></pre>

<p>}
<code>``
如果闭包没有指定参数列表或者返回类型，则可以通过上下文推断，那么可以捕获列表放在闭包开始的地方，跟着是关键字</code>in`：</p>

<p>```
@lazy var someClosure: () &ndash;> String = {</p>

<pre><code>[unowned self] in
// closure body goes here
</code></pre>

<p>}
```</p>

<h3>捕获列表中的弱引用和无主引用</h3>

<p>当捕获引用有时可能会是nil时，将闭包内的捕获定义为弱引用。<br/>
当闭包和捕获的实例总是互相引用时并且总是同时销毁时，将闭包内的捕获定义为无主引用。<br/>
如果捕获的引用绝对不会置为nil，应该用无主引用，而不是弱引用。</p>

<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法。这样编写<code>HTMLElement</code>类来避免循环强引用：</p>

<p>```
class HTMLElement {</p>

<pre><code>let name: String
let text: String?

@lazy var asHTML: () -&gt; String = {
    [unowned self] in
    if let text = self.text {
        return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
    } else {
        return "&lt;\(self.name) /&gt;"
    }
}

init(name: String, text: String? = nil) {
    self.name = name
    self.text = text
}

deinit {
    println("\(name) is being deinitialized")
}
</code></pre>

<p>}
```</p>

<p>上面的例子只是多了一个捕获列表并增加关键字<code>in</code>，使用捕获列表后引用关系如下图所示：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png" alt="" /></p>

<p>这一次，闭包以无主引用的形式捕获<code>self</code>，并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为<code>nil</code>，<code>HTMLElement</code>实例将会被销毁，并能看到它的析构函数打印出的消息。</p>

<p><code>
paragraph = nil
// prints "p is being deinitialized"
</code></p>
]]></content>
  </entry>
  
</feed>
