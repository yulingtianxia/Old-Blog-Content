<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-06-17T14:10:02+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Swift中的ARC]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/17/swiftzhong-de-arc/"/>
    <updated>2014-06-17T10:32:38+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/17/swiftzhong-de-arc</id>
    <content type="html"><![CDATA[<p>Objective-C中的ARC被Swift很好的继承下来了，本文参考自Swift文档网上的翻译，主要重点记录下Swift中的ARC与OC对比需要注意的地方。</p>

<!--more-->


<h2>简介</h2>

<p>当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>

<h2>类实例之间强引用循环的产生</h2>

<p>如果你对OC中的强引用循环很了解，可以直接跳过这节。</p>

<p>但是如果两个类的实例之间互相引用，这样就产生了强引用循环。下面展示了一个不经意产生强引用循环的例子。例子定义了两个类：<code>Person</code>和<code>Apartment</code>，用来建模公寓和它其中的居民:</p>

<p>``` js
class Person {</p>

<pre><code>let name: String
init(name: String) { self.name = name }
var apartment: Apartment?
deinit { println("\(name) is being deinitialized") }
</code></pre>

<p>}</p>

<p>class Apartment {</p>

<pre><code>let number: Int
init(number: Int) { self.number = number }
var tenant: Person?
deinit { println("Apartment #\(number) is being deinitialized") }
</code></pre>

<p>}
```</p>

<p>接下来的代码片段定义了两个可选类型的变量<code>john</code>和<code>number73</code>,并分别被设定为下面的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为<code>nil</code>，并为可选的（让它们可选是为了以后能销毁，为了演示程序）：</p>

<p><code>
var john: Person?
var number73: Apartment?
</code></p>

<p>现在你可以创建特定的<code>Person</code>和<code>Apartment</code>实例并将类实例赋值给<code>john</code>和<code>number73</code>变量：</p>

<p><code>
john = Person(name: "John Appleseed")
number73 = Apartment(number: 73)
</code></p>

<p>在<code>john</code>和<code>number73</code>互相引用之前，它们的强引用关系是这样的：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png" alt="" /></p>

<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来强制解析可选变量<code>john</code>和<code>number73</code>中的实例：</p>

<p><code>
john!.apartment = number73
number73!.tenant = john
</code>
在将两个实例联系在一起之后，强引用的关系变成了这样：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png" alt="" /></p>

<p>这样即使让<code>john</code>和<code>number73</code>断开它们持有的强引用，内存中的那两个<code>Person</code>和<code>Apartment</code>实例并不会销毁，因为它们互相引用，引用计数都为1：</p>

<p><code>
john = nil
number73 = nil
</code>
当你把这两个变量设为<code>nil</code>时，没有任何一个析构函数被调用。强引用循环阻止了<code>Person</code>和<code>Apartment</code>类实例的销毁，并在你的应用程序中造成了内存泄漏。</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png" alt="" /></p>

<h2>如何解决实例间强引用循环</h2>

<h3>弱引用</h3>

<p>跟OC中的弱引用相似，声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。弱引用不会牢牢保持住引用的实例，并且不会阻止 ARC 销毁被引用的实例。因为弱引用的值会变化并可能为<code>nil</code>，所以弱引用不能是常量，必须是可选类型（Optional）。因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。</p>

<p>下面的例子跟上面<code>Person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>属性被声明为弱引用：</p>

<p>```
class Person {</p>

<pre><code>let name: String
init(name: String) { self.name = name }
var apartment: Apartment?
deinit { println("\(name) is being deinitialized") }
</code></pre>

<p>}
class Apartment {</p>

<pre><code>let number: Int
init(number: Int) { self.number = number }
weak var tenant: Person?
deinit { println("Apartment #\(number) is being deinitialized") }
</code></pre>

<p>}
<code>``
然后跟之前一样，建立两个变量（</code>john<code>和</code>number73`）之间的强引用，并关联两个实例：</p>

<p>```
var john: Person?
var number73: Apartment?</p>

<p>john = Person(name: &ldquo;John Appleseed&rdquo;)
number73 = Apartment(number: 73)</p>

<p>john!.apartment = number73
number73!.tenant = john
```
现在的引用关系如下：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png" alt="" /></p>

<p>当<code>john</code>的强引用断开后，引用关系变成了这样子：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png" alt="" /></p>

<p>因为没有强引用指向<code>Person</code>实例，它的引用计数为0，所以该实例会被销毁。因此<code>number73</code>指向的<code>Apartment</code>实例的的引用计数会变为1，因为<code>Person</code>实例销毁后，其<code>apartment</code>属性对<code>Apartment</code>实例的强引用也会断开。此时如果再断开<code>number73</code>对<code>Apartment</code>实例的强引用：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png" alt="" /></p>

<p><code>Apartment</code>实例因为引用计数为0，会被销毁，到此为止强引用循环被打破。</p>

<h3>无主引用</h3>

<p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的（不能为<code>nil</code>）。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字<code>unowned</code>表示这是一个无主引用。</p>

<p>下面的例子定义了两个类，<code>Customer</code>和<code>CreditCard</code>，模拟了银行客户和客户的信用卡。一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。所以<code>Customer</code>类的<code>card</code>属性可以为<code>nil</code>，但是<code>CreditCard</code>类的<code>customer</code>属性不能为<code>nil</code>，所以创建CreditCard实例的时候必须给<code>customer</code>属性赋值避免其为<code>nil</code>。将<code>customer</code>属性定义为无主引用，用以避免循环强引用：</p>

<p>```
class Customer {</p>

<pre><code>let name: String
var card: CreditCard?
init(name: String) {
    self.name = name
}
deinit { println("\(name) is being deinitialized") }
</code></pre>

<p>}
class CreditCard {</p>

<pre><code>let number: Int
unowned let customer: Customer
init(number: Int, customer: Customer) {
    self.number = number
    self.customer = customer
}
deinit { println("Card #\(number) is being deinitialized") }
</code></pre>

<p>}
var john: Customer?
john = Customer(name: &ldquo;John Appleseed&rdquo;)
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
```
关联两个实例后，引用关系如下：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png" alt="" /></p>

<p>由于<code>customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png" alt="" /></p>

<p>于是<code>Customer</code>实例被销毁，这样又导致没有强引用指向<code>CreditCard</code>实例，最后<code>CreditCard</code>实例也被销毁了，这样说明强引用循环被打破了。</p>

<h3>无主引用以及隐式解析可选属性</h3>

<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，而每一个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>country</code>属性：</p>

<p>```
class Country {</p>

<pre><code>let name: String
let capitalCity: City!
init(name: String, capitalName: String) {
    self.name = name
    self.capitalCity = City(name: capitalName, country: self)
}
</code></pre>

<p>}
class City {</p>

<pre><code>let name: String
unowned let country: Country
init(name: String, country: Country) {
    self.name = name
    self.country = country
}
</code></pre>

<p>}
<code>``
在这种场景中，两个属性都必须有值，并且初始化完成后不能为</code>nil`。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>

<p>隐式解析可选(<code>Implicitly Unwrapped Optionals</code>)被用于类的初始化方法中，避免循环引用，因为编译器会将其认为默认<code>nil</code>，不需赋值就可以完成类的初始化，在例子中一旦<code>name</code>属性被赋值后(但<code>capitalCity</code>还没被赋值时)<code>Country</code>类就已经初始化并且自身（<code>self</code>）可以被引用；这样就能实现一行代码建立<code>Country</code>和<code>City</code>实例而不造成强引用循环。</p>

<p><code>
var country = Country(name: "Canada", capitalName: "Ottawa")
println("\(country.name)'s capital city is called \(country.capitalCity.name)")
// prints "Canada's capital city is called Ottawa"
</code>
使用隐式解析可选值的意义在于满足了两个类构造函数的需求。<code>capitalCity</code>属性在初始化完成后，能像非可选值一样使用和存取同时还避免了循环强引用。</p>

<h3>总结</h3>

<p><code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>

<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>，而另一个属性的值不允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合通过无主引用来解决。</p>

<p><code>Country</code>和<code>City</code>的例子展示了两个属性的值都不允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>

<h2>闭包引起的强引用循环</h2>

<p>强引用循环还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如<code>self.someMethod</code>。这两种情况都导致了闭包 “捕获" <code>self</code>，因为闭包也是引用类型，从而产生了强引用循环。在Swift中闭包如果想使用外部的实例，不必像OC中的Block那样在外部实例前加<code>__block</code>加以修饰，而是可以直接用“值捕获”的方式捕获到闭包外面的实例。Swift 会决定捕获引用还是拷贝值，并负责管理内存释放。</p>

<p>Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod（而不只是someProperty或someMethod）。这提醒你可能会不小心就捕获了self。</p>

<p>在OC中也存在<code>Block</code>中引用<code>self</code>或<code>self</code>的属性而导致<code>self</code>被<code>Block</code> retain，进而产生引用循环，这也是为什么代理属性都被声明为<code>weak</code>的原因。</p>

<p>下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 中的一个单独的元素：</p>

<p>```
class HTMLElement {</p>

<pre><code>let name: String
let text: String?

@lazy var asHTML: () -&gt; String = {
    if let text = self.text {
        return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
    } else {
        return "&lt;\(self.name) /&gt;"
    }
}

init(name: String, text: String? = nil) {
    self.name = name
    self.text = text
}

deinit {
    println("\(name) is being deinitialized")
}
</code></pre>

<p>}
```</p>

<p><code>HTMLElement</code>定义了一个<code>lazy</code>属性<code>asHTML</code>。这个属性引用了一个闭包，将<code>name</code>和<code>text</code>组合成 HTML 字符串片段。该属性是<code>() -&gt; String</code>类型，或者可以理解为“一个没有参数，返回<code>String</code>的函数”。因为该闭包无参数并可推断出返回值类型，所以采取了简写，省略了关键字<code>in</code>和闭包的参数和返回值类型声明。</p>

<p><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要处理为HTML输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>

<p>下面的代码展示了如何用HTMLElement类创建实例并打印消息</p>

<p><code>
var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
println(paragraph!.asHTML())
// prints"hello, world"
</code></p>

<p>不幸的是，上面写的HTMLElement类产生了类实例和asHTML默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png" alt="" /></p>

<p>虽然闭包多次使用了<code>self</code>，它只捕获<code>HTMLElement</code>实例的一个强引用。如果设置<code>paragraph</code>变量为<code>nil</code>，打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMLElement</code>实例和它的闭包都不会被销毁，也是因为强引用循环</p>

<h2>解决闭包引起的循环强引用</h2>

<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包占用列表（closuer capture list）</p>

<h3>定义捕获列表</h3>

<p>捕获列表放置在闭包参数列表和返回类型之前，列表中每项都是由weak或unowned关键字和实例的引用（如self或someInstance）成对组成。每项都通过逗号分开写在方括号中。</p>

<p>```
@lazy var someClosure: (Int, String) &ndash;> String = {</p>

<pre><code>[unowned self] (index: Int, stringToProcess: String) -&gt; String in
// closure body goes here
</code></pre>

<p>}
<code>``
如果闭包没有指定参数列表或者返回类型，则可以通过上下文推断，那么可以捕获列表放在闭包开始的地方，跟着是关键字</code>in`：</p>

<p>```
@lazy var someClosure: () &ndash;> String = {</p>

<pre><code>[unowned self] in
// closure body goes here
</code></pre>

<p>}
```</p>

<h3>捕获列表中的弱引用和无主引用</h3>

<p>当捕获引用有时可能会是nil时，将闭包内的捕获定义为弱引用。<br/>
当闭包和捕获的实例总是互相引用时并且总是同时销毁时，将闭包内的捕获定义为无主引用。<br/>
如果捕获的引用绝对不会置为nil，应该用无主引用，而不是弱引用。</p>

<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法。这样编写<code>HTMLElement</code>类来避免循环强引用：</p>

<p>```
class HTMLElement {</p>

<pre><code>let name: String
let text: String?

@lazy var asHTML: () -&gt; String = {
    [unowned self] in
    if let text = self.text {
        return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
    } else {
        return "&lt;\(self.name) /&gt;"
    }
}

init(name: String, text: String? = nil) {
    self.name = name
    self.text = text
}

deinit {
    println("\(name) is being deinitialized")
}
</code></pre>

<p>}
```</p>

<p>上面的例子只是多了一个捕获列表并增加关键字<code>in</code>，使用捕获列表后引用关系如下图所示：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png" alt="" /></p>

<p>这一次，闭包以无主引用的形式捕获<code>self</code>，并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为<code>nil</code>，<code>HTMLElement</code>实例将会被销毁，并能看到它的析构函数打印出的消息。</p>

<p><code>
paragraph = nil
// prints "p is being deinitialized"
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift重载和自定义运算符]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/16/swiftzhong-zai-yun-suan-fu/"/>
    <updated>2014-06-16T20:45:20+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/16/swiftzhong-zai-yun-suan-fu</id>
    <content type="html"><![CDATA[<p>最近一直边忙毕设边学Swift，终于看完了官方的教程（语言参考暂不打算看），在iBooks上做了一些笔记（看英文伤不起），感觉Swift是一门大杂烩类型的语言，我会记录一些我自认为以前遇到较少或者需要重点记忆的语法特性，在此作为分享，这次是运算符的重载，几乎每门语言都有，只是语法不一样罢了。</p>

<!--more-->


<h2>运算符重载</h2>

<p>在Swift的官方文档中运算符重载叫做运算符函数（Operator Functions），顾名思义就是对已经有的运算符覆盖定义自己的函数实现。三元运算符（a？b：c）和默认的默认的赋值符(=)是不可重载的。</p>

<h3>中缀运算符的重载</h3>

<p>在<code>func</code>关键字前使用属性<code>@infix</code>来重载中缀运算符，函数名为想要重载的中缀运算符：</p>

<p>``` js
struct Vector2D {</p>

<pre><code>var x = 0.0, y = 0.0
</code></pre>

<p>}
@infix func + (left: Vector2D, right: Vector2D) &ndash;> Vector2D {</p>

<pre><code>return Vector2D(x: left.x + right.x, y: left.y + right.y)
</code></pre>

<p>}
<code>``
上面的代码是对结构体</code>Vector2D<code>之间双目运算符</code>+<code>的重载，下面可以直接使用</code>+<code>对</code>Vector2D`进行操作了：</p>

<p><code>
let vector = Vector2D(x: 3.0, y: 1.0)
let anotherVector = Vector2D(x: 2.0, y: 4.0)
let combinedVector = vector + anotherVector
// combinedVector 是一个新的Vector2D, 值为 (5.0, 5.0)
</code></p>

<p>除了对双目运算符的重载，还有对比较运算符的重载</p>

<p>```
@infix func == (left: Vector2D, right: Vector2D) &ndash;> Bool {</p>

<pre><code>return (left.x == right.x) &amp;&amp; (left.y == right.y)
</code></pre>

<p>}</p>

<p>@infix func != (left: Vector2D, right: Vector2D) &ndash;> Bool {</p>

<pre><code>return !(left == right)
</code></pre>

<p>}
```</p>

<p>现在我们可以使用这两个运算符来判断两个Vector2D对象是否相等</p>

<p>```
let twoThree = Vector2D(x: 2.0, y: 3.0)
let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)
if twoThree == anotherTwoThree {</p>

<pre><code>println("这两个向量是相等的.")
</code></pre>

<p>}
// prints &ldquo;这两个向量是相等的.&rdquo;
```</p>

<h3>前缀和后缀运算符的重载</h3>

<p>前缀和后缀运算符重载跟中缀运算符重载类似，只是将<code>func</code>关键字前的属性替换成<code>@prefix</code>和<code>@postfix</code>，比如：</p>

<p>```
@prefix func &ndash; (vector: Vector2D) &ndash;> Vector2D {</p>

<pre><code>return Vector2D(x: -vector.x, y: -vector.y)
</code></pre>

<p>}
```</p>

<p>这段代码为<code>Vector2D</code>类型提供了单目减运算，并且是前缀，也就是取负操作。</p>

<p><code>
let positive = Vector2D(x: 3.0, y: 4.0)
let negative = -positive
// negative 为 (-3.0, -4.0)
let alsoPositive = -negative
// alsoPositive 为 (3.0, 4.0)
</code></p>

<h3>组合赋值运算符的重载</h3>

<p>组合赋值是其他运算符和赋值运算符一起执行的运算。如<code>+=</code>把加运算和赋值运算组合成一个操作。实现一个组合赋值符号需要使用<code>@assignment</code>属性，还需要把运算符的左参数设置成<code>inout</code>，因为这个参数会在运算符函数内直接修改它的值。</p>

<p>```
@assignment func += (inout left: Vector2D, right: Vector2D) {</p>

<pre><code>left = left + right
</code></pre>

<p>}
```</p>

<p>因为加法运算在之前定义过了，这里无需重新定义。所以，加赋运算符函数使用已经存在的高级加法运算符函数来执行左值加右值的运算。</p>

<p><code>
var original = Vector2D(x: 1.0, y: 2.0)
let vectorToAdd = Vector2D(x: 3.0, y: 4.0)
original += vectorToAdd
// original 现在为 (4.0, 6.0)
</code>
你可以将<code>@assignment</code>属性和 <code>@prefix</code> 或 <code>@postfix</code> 属性起来组合，实现一个<code>Vector2D</code>的前缀运算符。</p>

<p>```
@prefix @assignment func ++ (inout vector: Vector2D) &ndash;> Vector2D {</p>

<pre><code>vector += Vector2D(x: 1.0, y: 1.0)
return vector
</code></pre>

<p>}
<code>``
这个前缀使用了已经定义好的高级加赋运算，将自己加上一个值为</code> (1.0，1.0) `的对象然后赋给自己，然后再将自己返回。</p>

<p><code>
var toIncrement = Vector2D(x: 3.0, y: 4.0)
let afterIncrement = ++toIncrement
// toIncrement 现在是 (4.0, 5.0)
// afterIncrement 现在也是 (4.0, 5.0)
</code></p>

<h2>自定义运算符</h2>

<p>标准的运算符不够玩，那你可以声明一些个性的运算符，但个性的运算符只能使用这些字符 <code>/ = - + * % &lt; &gt;！&amp; | ^。~</code>  <br/>
新的运算符声明需在全局域使用<code>operator</code>关键字声明，可以声明为前缀，中缀或后缀的。</p>

<p><code>
operator prefix +++ {}
</code>
这段代码定义了一个新的前缀运算符叫<code>+++</code>，此前Swift并不存在这个运算符。此处为了演示，我们让<code>+++</code>对<code>Vector2D</code>对象的操作定义为“双自增”（prefix doubling incrementer） 这样一个独有的操作，这个操作使用了之前定义的加赋运算（<code>+=</code>）实现了自已加上自己然后返回的运算。</p>

<p>```
@prefix @assignment func +++ (inout vector: Vector2D) &ndash;> Vector2D {</p>

<pre><code>vector += vector
return vector
</code></pre>

<p>}
```</p>

<p><code>+++</code>运算的实现是把自己再加上自己</p>

<p><code>
var toBeDoubled = Vector2D(x: 1.0, y: 4.0)
let afterDoubling = +++toBeDoubled
// toBeDoubled 现在是 (2.0, 8.0)
// afterDoubling 现在也是 (2.0, 8.0)
</code>
此外还可以定义运算符的结合性(associativity)和优先级(precedence)，结合性(associativity)的值可取的值有left，right和none。左结合运算符跟其他优先级相同的左结合运算符写在一起时，会跟左边的操作数结合。同理，右结合运算符会跟右边的操作数结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。<br/>
结合性(associativity)的值默认为none，优先级(precedence)默认为100。</p>

<p>```
operator infix +&ndash; { associativity left precedence 140 }
func +&ndash; (left: Vector2D, right: Vector2D) &ndash;> Vector2D {</p>

<pre><code>return Vector2D(x: left.x + right.x, y: left.y - right.y)
</code></pre>

<p>}
let firstVector = Vector2D(x: 1.0, y: 2.0)
let secondVector = Vector2D(x: 3.0, y: 4.0)
let plusMinusVector = firstVector +&ndash; secondVector
// plusMinusVector 此时的值为 (4.0, -2.0)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XCode,Swift和Objective-C Cheat Sheet]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/06/xcodehe-objective-c-cheat-sheet/"/>
    <updated>2014-04-06T18:38:24+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/06/xcodehe-objective-c-cheat-sheet</id>
    <content type="html"><![CDATA[<p>关于XCode,Swift和OC的速查，方便记忆，以后会更新</p>

<!-- more-->


<p>XCode5 Cheat Sheet:(<a href="http://www.git-tower.com/blog/xcode-cheat-sheet/">作者</a>)</p>

<p><img src="/images/blog/xcode-cheat-sheet<em>页面</em>1.jpg"></p>

<p><img src="/images/blog/xcode-cheat-sheet<em>页面</em>2.jpg"></p>

<p>Objective-C Cheat Sheet and Quick Reference Updated for Xcode 5:(摘自<a href="http://www.raywenderlich.com/54099/objective-c-cheat-sheet-and-quick-reference-updated-for-xcode-5">raywenderlich</a>)</p>

<p><img src="/images/blog/RW-Objective-C-Cheatsheet-v-1-5.jpg"></p>

<p>Swift Cheat Sheet and Quick Reference:(摘自<a href="http://www.raywenderlich.com/73967/swift-cheat-sheet-and-quick-reference">raywenderlich</a>)</p>

<p><img src="/images/blog/RW-Swift-Cheatsheet.png" alt="" /></p>
]]></content>
  </entry>
  
</feed>
