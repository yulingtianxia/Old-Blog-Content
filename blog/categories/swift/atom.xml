<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-09-26T18:54:38+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[在Swift中创建assert(), 第二部分: `__FILE__` and `__LINE__`]]></title>
    <link href="http://yulingtianxia.com/blog/2014/09/26/building-assert-in-swift-2/"/>
    <updated>2014-09-26T16:23:21+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/09/26/building-assert-in-swift-2</id>
    <content type="html"><![CDATA[<p><code>__FILE__</code> 和 <code>__LINE__</code>这两个神奇的宏定义是C语言中偶尔有用的特性。他们被构建在预处理程序中，并在C语言语法分析程序运行前被展开。尽管Swift没有预处理程序，它却提供了名称相似的类似功能，但隐藏着极其不同的实现方式。</p>

<h2>内建的标识符</h2>

<p>就像在<a href="https://developer.apple.com/library/ios/documentation/swift/conceptual/swift_programming_language/LexicalStructure.html">the Swift programming guide</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Swift和SpriteKit开发iOS游戏]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/17/a-ios-game-developed-by-swift-and-spritekit/"/>
    <updated>2014-07-17T12:54:13+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/17/a-ios-game-developed-by-swift-and-spritekit</id>
    <content type="html"><![CDATA[<p>之前用SpriteKit做过一个叫做<a href="https://github.com/yulingtianxia/ColorAtom">ColorAtom</a>的小游戏，用了访问者模式处理碰撞检测，还用了SpriteKit中的粒子系统、连接体、力场和动画等，可以说是一个学习SpriteKit比较不错的Demo，随着Swift的火热，我也用Swift和SpriteKit写了一个更为简单的小游戏<a href="https://github.com/yulingtianxia/Spiral">Spiral</a></p>

<!--more-->


<p>附上Spiral的动图：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140557437844.gif" alt="" /></p>

<p>游戏规则是：玩家是五角星小球，小球自动沿着陀螺线向外运动，当玩家点击屏幕时五角星小球会跳跃到内层螺旋，当五角星小球碰到红色旋风或滚动到螺旋线终点时游戏结束。玩家吃掉绿色旋风来得2分，吃到紫色三角得一分并获得保护罩，保护罩用来抵挡一次红色旋风。随着分数的增加游戏会升级，速度加快。游戏结束后可以截屏分享到社交网络，也可以选择重玩。</p>

<p>以下是本文内容：</p>

<ol>
<li>准备工作</li>
<li>绘制基本界面</li>
<li>Swift中用访问者模式处理碰撞</li>
<li>界面数据显示</li>
<li>按钮的绘制和截图分享</li>
</ol>


<h2>准备工作</h2>

<p>SpriteKit是苹果iOS7新推出的2D游戏引擎，这里不再过多介绍。我们新建工程的时候选取iOS中的Game，然后选择SpriteKit作为游戏引擎，语言选择Swift，Xcode6会为我们自动创建一个游戏场景<code>GameScene</code>，它包含<code>GameScene.swift</code>和<code>GameScene.sks</code>两个文件，<code>sks</code>文件可以让我们可视化拖拽游戏控件到场景上，然后再代码中加载<code>sks</code>文件来完成场景的初始化：</p>

<p>``` js</p>

<p>extension SKNode {</p>

<pre><code>class func unarchiveFromFile(file : NSString) -&gt; SKNode? {

    let path = NSBundle.mainBundle().pathForResource(file, ofType: "sks")

    var sceneData = NSData.dataWithContentsOfFile(path, options: .DataReadingMappedIfSafe, error: nil)
    var archiver = NSKeyedUnarchiver(forReadingWithData: sceneData)

    archiver.setClass(self.classForKeyedUnarchiver(), forClassName: "SKScene")
    let scene = archiver.decodeObjectForKey(NSKeyedArchiveRootObjectKey) as GameScene
    archiver.finishDecoding()
    return scene
}
</code></pre>

<p>}
```</p>

<p>但我比较喜欢纯写代码的方式来搭接面，因为<code>sks</code>文件作为游戏场景布局还不成熟，它是iOS8新加入的功能，以前在iOS7的时候<code>sks</code>文件只是作为粒子系统的可视化编辑文件。</p>

<p>所以我们修改<code>GameViewController.swift</code>文件的<code>viewDidLoad()</code>函数，像以前那样直接用代码加载游戏场景：</p>

<p>```
override func viewDidLoad() {</p>

<pre><code>    super.viewDidLoad()
    // Configure the view.
    let skView = self.view as SKView
    /* Sprite Kit applies additional optimizations to improve rendering performance */
    skView.ignoresSiblingOrder = true
    let scene = GameScene(size: skView.bounds.size)
    /* Set the scale mode to scale to fit the window */
    scene.scaleMode = .AspectFill
    skView.presentScene(scene)

}
</code></pre>

<p>```</p>

<p><code>GameScene</code>虽然是Xcode自动生成的，但是只是个空架子，我们需要把它生成的没用的代码删掉，比如初始化函数里内容为“HelloWorld”的<code>SKLabelNode</code>，还有<code>touchesBegan(touches: NSSet, withEvent event: UIEvent)</code>方法中绘制飞船的代码。把这些删光后，我们还需要有图片素材来绘制这四类精灵节点：<code>Player</code>（五角星），<code>Killer</code>（红色旋风），<code>Score</code>（绿色旋风）和<code>Shield</code>（紫色三角）。我是用Sketch来绘制这些矢量图形的，文件名为<code>spiral.sketch</code>，随同工程文件一同放到GitHub上了。当然你不需要手动导出图片到工程，直接下载工程文件就好了：</p>

<p><a href="https://github.com/yulingtianxia/Spiral">https://github.com/yulingtianxia/Spiral</a></p>

<h2>绘制基本界面</h2>

<p>这部分的工作主要是绘制出螺旋线作为地图，并让四种精灵节点动起来。</p>

<h3>螺旋线的绘制</h3>

<p><code>SKNode</code>有一个子类<code>SKShapeNode</code>，专门用于绘制线条的，我们新建一个<code>Map</code>类，继承<code>SKShapeNode</code>。下面我们需要生成一个<code>CGPath</code>来赋值给<code>Map</code>的<code>path</code>属性：</p>

<p>```
import UIKit
import SpriteKit
class Map: SKShapeNode {</p>

<pre><code>let spacing:CGFloat = 35
var points:[CGPoint] = []
convenience init(origin:CGPoint,layer:CGFloat){

    var x:CGFloat = origin.x
    var y:CGFloat = origin.y
    var path = CGPathCreateMutable()
    self.init()
    CGPathMoveToPoint(path, nil, x, y)
    points.append(CGPointMake(x, y))
    for index in 1..&lt;layer{
        y-=spacing*(2*index-1)
        CGPathAddLineToPoint(path, nil , x, y)
        points.append(CGPointMake(x, y))
        x-=spacing*(2*index-1)
        CGPathAddLineToPoint(path, nil , x, y)
        points.append(CGPointMake(x, y))
        y+=spacing*2*index
        CGPathAddLineToPoint(path, nil , x, y)
        points.append(CGPointMake(x, y))
        x+=spacing*2*index
        CGPathAddLineToPoint(path, nil , x, y)
        points.append(CGPointMake(x, y))
    }
    self.path = path
    self.glowWidth = 1
    self.antialiased = true
    CGPathGetCurrentPoint(path)
}
</code></pre>

<p>}
```</p>

<p>算法很简单，就是顺时针计算点坐标然后画线，这里把每一步的坐标都存入了<code>points</code>数组里，是为了以后计算其他数据时方便。因为这部分算法不难而且不是我们的重点，这里不过多介绍了。</p>

<h3>四种精灵的绘制</h3>

<p>因为四种精灵都是沿着<code>Map</code>类的路径来顺时针运动，它们的动画绘制是相似的，所以我建立了一个<code>Shape</code>类作为基类来绘制动画，它继承于<code>SKSpriteKit</code>类，并拥有半径（<code>radius</code>）、移动速度（<code>moveSpeed</code>）和线段计数（<code>lineNum</code>）这三个属性。其中<code>lineNum</code>是用于标记精灵在螺旋线第几条线段上的，这样比较方便计算动画的参数。</p>

<p>```
class Shape: SKSpriteNode {</p>

<pre><code>let radius:CGFloat = 10
var moveSpeed:CGFloat = 50
var lineNum = 0
init(name:String,imageName:String){
    super.init(texture: SKTexture(imageNamed: imageName),color:SKColor.clearColor(), size: CGSizeMake(radius*2, radius*2))
    self.physicsBody = SKPhysicsBody(circleOfRadius: radius)
    self.physicsBody.usesPreciseCollisionDetection = true
    self.physicsBody.collisionBitMask = 0
    self.physicsBody.contactTestBitMask = playerCategory|killerCategory|scoreCategory
    moveSpeed += CGFloat(Data.speedScale) * self.moveSpeed
    self.name = name
    self.physicsBody.angularDamping = 0

}
</code></pre>

<p>}
```</p>

<p>构造函数中设定了<code>Shape</code>类的一些物理参数，比如物理体的形状大小，碰撞检测掩码等。这里设定<code>usesPreciseCollisionDetection</code>为<code>true</code>是为了增加碰撞检测的精度，常用于体积小速度快的物体。<code>collisionBitMask</code>属性标记了需要模拟物理碰撞的类别，<code>contactTestBitMask</code>属性标记了需要检测到碰撞的类别。这里说的“类别”指的是物体的类别：</p>

<p><code>
let playerCategory:UInt32      =  0x1 &lt;&lt; 0;
let killerCategory:UInt32      =  0x1 &lt;&lt; 1;
let scoreCategory:UInt32       =  0x1 &lt;&lt; 2;
let shieldCategory:UInt32      =  0x1 &lt;&lt; 3;
</code>
这种用位运算来判断和存储物体类别的方式很常用，上面这段代码写在了<code>NodeCategories.swift</code>文件中。</p>

<p>为了描述<code>Shape</code>的速度随着游戏等级上升而增加，这里速度的计算公式含有<code>Data.speedScale</code>作为参数，关于<code>Data</code>“类”在后面会讲到。</p>

<p>为了让精灵动起来，需要知道动画的移动目的地是什么。虽然<code>SKAction</code>有<code>followPath(path: CGPath?, speed: CGFloat)</code>方法，但是在这里并不实用，因为<code>Player</code>会经常改变路线，所以我写了一个<code>runInMap(map:Map)</code>方法让精灵每次只移动到路径上的下一个节点（之前<code>Map</code>类存储的<code>points</code>属性用到了吧！嘿嘿）</p>

<p>```
func runInMap(map:Map){</p>

<pre><code>    let distance = calDistanceInMap(map)
    let duration = distance/moveSpeed
    let rotate = SKAction.rotateByAngle(distance/10, duration: duration)
    let move = SKAction.moveTo(map.points[lineNum+1], duration: duration)
    let group = SKAction.group([rotate,move])
    self.runAction(group, completion: {
        self.lineNum++
        if self.lineNum==map.points.count-1 {
            if self is Player{
                Data.gameOver = true
            }
            if self is Killer{
                self.removeFromParent()
            }
            if self is Score{
                self.removeFromParent()
            }
            if self is Shield{
                self.removeFromParent()
            }
        }
        else {
            self.runInMap(map)
        }
        })
}
</code></pre>

<p>```</p>

<p>上面的代码先是调用<code>calDistanceInMap(map:Map)-&gt;CGFloat</code>方法计算精灵距离下一个节点的距离（也就是需要移动的距离），然后计算精灵需要旋转动画时间和移动动画时间，最后将两个动画作为一个<code>group</code>来运行，在动画运行结束后判断精灵是否运行到了最后一个节点，也就是螺旋线的终点：如果到终点了则移除精灵，否则开始递归调用方法，来开始下一段动画（奔向下一个节点）。</p>

<p>计算距离的<code>calDistanceInMap(map:Map)-&gt;CGFloat</code>方法代码如下：</p>

<p>```
func calDistanceInMap(map:Map)&ndash;>CGFloat{</p>

<pre><code>    if self.lineNum==map.points.count {
        return 0
    }
    switch lineNum%4{
    case 0:
        return position.y-map.points[lineNum+1].y
    case 1:
        return position.x-map.points[lineNum+1].x
    case 2:
        return map.points[lineNum+1].y-position.y
    case 3:
        return map.points[lineNum+1].x-position.x
    default:
        return 0
    }
}
</code></pre>

<p>```</p>

<p>到此为止<code>Shape</code>类完成了，<code>Killer</code>、<code>Score</code>和<code>Shield</code>类比较简单，继承<code>Shape</code>类并设置自身纹理和类别即可：</p>

<p>```
class Killer: Shape {</p>

<pre><code>convenience init() {
    self.init(name:"Killer",imageName:"killer")
    self.physicsBody.categoryBitMask = killerCategory
}
</code></pre>

<p>}
class Score: Shape {</p>

<pre><code>convenience init() {
    self.init(name:"Score",imageName:"score")
    self.physicsBody.categoryBitMask = scoreCategory
}
</code></pre>

<p>}
class Shield: Shape {</p>

<pre><code>convenience init() {
    self.init(name:"Shield",imageName:"shield")
    self.physicsBody.categoryBitMask = shieldCategory
}
</code></pre>

<p>}
```</p>

<p>而<code>Player</code>因为有护盾状态并可以在螺旋线上跳跃到内层，所以稍微复杂些：</p>

<p>```
class Player: Shape {</p>

<pre><code>var jump = false
var shield:Bool = false {
willSet{
    if newValue{
        self.texture = SKTexture(imageNamed: "player0")
    }
    else{
        self.texture = SKTexture(imageNamed: "player")
    }
}
}
convenience init() {
    self.init(name:"Player",imageName:"player")
    self.physicsBody.categoryBitMask = playerCategory
    self.moveSpeed = 70
    self.lineNum = 3
}
func restart(map:Map) {
    self.alpha = 1
    self.removeAllActions()
    self.lineNum = 3
    self.moveSpeed = 70
    self.jump = false
    self.shield = false
    self.position = map.points[self.lineNum]
    self.runInMap(map)
}
</code></pre>

<p>}
```</p>

<p><code>Player</code>类的初始位置是螺旋线第四个节点，而且移动速度要略快于其他三种精灵，所以在这里设置为70（<code>Shape</code>默认速度50）。<code>jump</code>和<code>shield</code>是用来标记<code>Player</code>当前状态的属性，其中<code>shield</code>属性还定义了属性监察器，这是Swift中存储属性具有的响应机制，类似于<code>KVO</code>。在<code>shield</code>状态改变时也同时改变<code>Player</code>的纹理。<strong>需要注意的是构造器中对属性的改变并不会调用属性检查器，在<code>willSet</code>和<code>didSet</code>中改变自身属性也不会调用属性检查器，因为那样会造成死循环。</strong></p>

<p><code>restart(map:Map)</code>方法用于在游戏重新开始时重置<code>Player</code>的相关数据。</p>

<h2>Swift中用访问者模式处理碰撞</h2>

<p>访问者模式是双分派（Double Dispatch）模式的一种实现，关于双分派模式的详细解释，参考我的另一篇文章：<a href="http://yulingtianxia.com/blog/2014/04/13/double-dispatchmo-shi-ji-qi-zai-ioskai-fa-zhong-shi-zhan/">Double Dispatch模式及其在iOS开发中实践</a>，里面包含了C++，Java和Obje-C的实现，这次我们用Swift实现访问者模式。</p>

<p>因为SpriteKit中物理碰撞检测到的都是<code>SKPhysicsBody</code>，所以我们的被访问者需要包含一个<code>SKPhysicsBody</code>对象：</p>

<p>```
class VisitablePhysicsBody{</p>

<pre><code>let body:SKPhysicsBody
init(body:SKPhysicsBody){
    self.body = body
}
func acceptVisitor(visitor:ContactVisitor){
    visitor.visitBody(body)
}
</code></pre>

<p>}
```</p>

<p><code>acceptVisitor</code>方法传入的是一个<code>ContactVisitor</code>类，它是访问者的基类（也相当于接口），访问者的<code>visitBody(body:SKPhysicsBody)</code>方法会根据传入的<code>body</code>实例来推断出被访问者的真实类别，然后调用对应的方法来处理碰撞：</p>

<p>```
func visitBody(body:SKPhysicsBody){</p>

<pre><code>    //第二次dispatch，通过构造方法名来执行对应方法
    // 生成方法名，比如"visitPlayer"
    var contactSelectorString = "visit" + body.node.name + ":"
    let selector = NSSelectorFromString(contactSelectorString)
    if self.respondsToSelector(selector){
        dispatch_after(0, dispatch_get_main_queue(), {
            NSThread.detachNewThreadSelector(selector, toTarget:self, withObject: body)
            })
    }

}
</code></pre>

<p>```</p>

<p>Swift废弃了<code>performSelector</code>方法，所以这里耍了个小聪明来将消息传给具体的访问者。有关Swift中替代<code>performSelector</code>的方案，参见<a href="http://www.cnblogs.com/yangzhou1030/p/3830592.html">这里</a></p>

<p>下面让<code>GameScene</code>实现<code>SKPhysicsContactDelegate</code>协议：</p>

<p>```
func didBeginContact(contact:SKPhysicsContact){</p>

<pre><code>    //A-&gt;B
    let visitorA = ContactVisitor.contactVisitorWithBody(contact.bodyA, forContact: contact)
    let visitableBodyB = VisitablePhysicsBody(body: contact.bodyB)
    visitableBodyB.acceptVisitor(visitorA)
    //B-&gt;A
    let visitorB = ContactVisitor.contactVisitorWithBody(contact.bodyB, forContact: contact)
    let visitableBodyA = VisitablePhysicsBody(body: contact.bodyA)
    visitableBodyA.acceptVisitor(visitorB)
}
</code></pre>

<p><code>``
跟Objective-C中实现访问者模式类似，也是通过</code>ContactVisitor<code>类的工厂方法返回一个对应的子类实例来作为访问者，然后实例化一个被访问者，被访问者接受访问者的访问。A访问B和B访问A在大多数场合是相同的，但是你不知道谁是A谁是B，所以需要两种情况都调用。下面是</code>ContactVisitor`类的工厂方法和构造器：</p>

<p>```
class ContactVisitor:NSObject{</p>

<pre><code>let body:SKPhysicsBody!
let contact:SKPhysicsContact!
class func contactVisitorWithBody(body:SKPhysicsBody,forContact contact:SKPhysicsContact)-&gt;ContactVisitor!{
    //第一次dispatch，通过node类别返回对应的实例
    if 0 != body.categoryBitMask&amp;playerCategory {
        return PlayerContactVisitor(body: body, forContact: contact)
    }
    if 0 != body.categoryBitMask&amp;killerCategory {
        return KillerContactVisitor(body: body, forContact: contact)
    }
    if 0 != body.categoryBitMask&amp;scoreCategory {
        return ScoreContactVisitor(body: body, forContact: contact)
    }
    if 0 != body.categoryBitMask&amp;shieldCategory {
        return ShieldContactVisitor(body: body, forContact: contact)
    }
    return nil

}
init(body:SKPhysicsBody, forContact contact:SKPhysicsContact){
    self.body = body
    self.contact = contact
    super.init()

}
</code></pre>

<p>}
```</p>

<p>PS：上面的代码省略了已经提到过的<code>visitBody(body:SKPhysicsBody)</code>方法</p>

<p>因为这个游戏逻辑比较简单，所有碰撞后的逻辑都写到了<code>PlayerContactVisitor</code>类里：</p>

<p>```
func visitKiller(body:SKPhysicsBody){</p>

<pre><code>    let thisNode = self.body.node as Player
    let otherNode = body.node
</code></pre>

<p>//        println(thisNode.name+&ldquo;&ndash;>&rdquo;+otherNode.name)</p>

<pre><code>    if thisNode.shield {
        otherNode.removeFromParent()
        thisNode.shield = false
    }
    else {
        Data.gameOver = true
    }
}
func visitScore(body:SKPhysicsBody){
    let thisNode = self.body.node
    let otherNode = body.node
</code></pre>

<p>//        println(thisNode.name+&ldquo;&ndash;>&rdquo;+otherNode.name)</p>

<pre><code>    otherNode.removeFromParent()
    Data.score += 2
}
func visitShield(body:SKPhysicsBody){
    let thisNode = self.body.node as Player
    let otherNode = body.node
    otherNode.removeFromParent()
    thisNode.shield = true
    Data.score++
    //        println(thisNode.name+"-&gt;"+otherNode.name)
}
</code></pre>

<p>```</p>

<p>上面的方法都是“visit+类名”格式的，处理的是<code>Player</code>碰撞到其他三种精灵的逻辑。而其他三种精灵之间的碰撞不需要处理，所以<code>KillerContactVisitor</code>、<code>ScoreContactVisitor</code>和<code>ShieldContactVisitor</code>这三个<code>ContactVisitor</code>的子类很空旷，这里不再赘述。</p>

<p>我们设置<code>Player</code>碰撞到<code>Killer</code>游戏结束，碰撞到<code>Score</code>加两分，碰撞到<code>Shield</code>加一分并获得护甲（shield属性设为true）。可以看到这里大量用到了<code>Data</code>“类“”，它其实是一个存储并管理全局数据的结构体，它里面存储了一些静态的成员属性，也可看做非线程安全的单例。</p>

<h2>界面数据显示</h2>

<p>这部分很简单，主要是将<code>Data</code>结构体中存储的分数和等级等数据通过<code>SKLabelNode</code>显示在界面上，只不过我封装了一个<code>Display</code>类来将所有的<code>SKLabelNode</code>统一管理，并让其实现我定义的<code>DisplayData</code>协议来让<code>Data</code>中的数据变化驱动界面更新：</p>

<p>```
protocol DisplayData{</p>

<pre><code>func updateData()
func levelUp()
func gameOver()
func restart()
</code></pre>

<p>}
```</p>

<p>下面是Data结构体代码，大量使用了存储属性的监察器来响应数据变化：</p>

<p>```
struct Data{</p>

<pre><code>static var display:DisplayData?
static var updateScore:Int = 5
static var score:Int = 0{
willSet{
    if newValue&gt;=updateScore{
        updateScore+=5 * ++level
    }
}
didSet{
    display?.updateData()
}
}
static var highScore:Int = 0
static var gameOver:Bool = false {
willSet{
    if newValue {
        let standardDefaults = NSUserDefaults.standardUserDefaults()
        Data.highScore = standardDefaults.integerForKey("highscore")
        if Data.highScore &lt; Data.score {
            Data.highScore = Data.score
            standardDefaults.setInteger(Data.score, forKey: "highscore")
            standardDefaults.synchronize()
        }
        display?.gameOver()
    }
    else {
        display?.restart()
    }
}
didSet{

}
}
static var level:Int = 1{
willSet{
    speedScale = Float(newValue)*0.1
    if newValue != 1{
        display?.levelUp()
    }
}
didSet{
    display?.updateData()

}
}
static var speedScale:Float = 0{
willSet{

}
didSet{

}
}

static func restart(){
    Data.updateScore = 5
    Data.score = 0
    Data.level = 1
    Data.speedScale = 0
}
</code></pre>

<p>}
```</p>

<p>这里不得不提到一个更新界面时遇到的一个坑，当我想通过名字遍历<code>GameScene</code>子节点的时候，一般会用到<code>enumerateChildNodesWithName(name: String?, usingBlock: ((SKNode!, UnsafePointer&lt;ObjCBool&gt;) -&gt; Void)?)</code>方法，但是这个方法在Xcode6Beta3更新后经常会抛异常强退，这让我很费解，恰巧遇到此问题的不只是我一个人，所以还是老老实实的自己写循环遍历加判断吧。</p>

<h2>按钮的绘制和截图分享</h2>

<p>参考我的另外两篇文章：<a href="http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button/">在游戏的SKScene中添加Button</a>和<a href="http://yulingtianxia.com/blog/2014/04/22/spritekitjie-ping-bing-fen-xiang-zhi-she-jiao-wang-luo/">SpriteKit截屏并分享至社交网络</a></p>

<p>在本工程中只有<code>ShareButton</code>和<code>ReplayButton</code>两个按钮，Swift版本的代码很简洁，而我通过<code>Social.Framework</code>中的<code>UIActivityViewController</code>来分享得分，这部分代码写在了<code>ShareButton.swift</code>中：</p>

<p>```
let scene = self.scene as GameScene</p>

<pre><code>    let image = scene.imageFromNode(scene)
    let text = "我在Spiral游戏中得了\(Data.score)分，快来追逐我的步伐吧！"
    let activityItems = [image,text]
    let activityController = UIActivityViewController(activityItems: activityItems, applicationActivities: nil)
    (scene.view.nextResponder() as UIViewController).presentViewController(activityController, animated: true, completion: nil)
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中的位运算符和溢出运算符]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/11/bitwise-and-overflow-operators-in-swift/"/>
    <updated>2014-07-11T15:15:59+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/11/bitwise-and-overflow-operators-in-swift</id>
    <content type="html"><![CDATA[<p>位运算符（Bitwise Operators），在各种语言中都存在，虽然用的有些少，但是在诸如类别判断，类型检测等方案中经常用位运算来实现。很多枚举类型的成员都是将<code>0x1</code>左移位来赋值，而不是从0递增，这其中就蕴含着位运算。而数值运算中的溢出也是一个不常遇到但又值得注意的地方，虽然很少有人用<code>Int8</code>来存储大数，但了解下Swift处理溢出的这一特性也是很有用的。</p>

<!--more-->


<h2>基本位运算符</h2>

<p><code>~</code>,<code>&amp;</code>,<code>|</code>,<code>^</code>分别为取反，与，或，异或运算：</p>

<p><code>
let firstBit: UInt8 = 0b10000000
let lastBit: UInt8  = 0b00000001
let invertedBits = ~lastBit  // 等于 0b11111110
let noneBit = firstBit &amp; lastBit  // 等于 0b00000000
let twoSideBits = firstBit | lastBit //等于 0b10000001
let middleSixBits = firstBit ^ lastBit //等于 0b10000001
</code>
左移运算符<code>&lt;&lt;</code>和右移运算符<code>&gt;&gt;</code>分别扮演着乘2和除2的角色，对于<code>UInt</code>来讲很简单，只需要填充0就行：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftUnsigned_2x.png" alt="" /></p>

<p>但对于有符号整型数，移位时需要考虑到符号位，第一个比特位表达这个整数是正数还是负数。0代表正数，1代表负数。也就是说<code>Int8</code>最大是127，因为只有7位存储实际值，而且负数采用补码来表示。</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedFour_2x.png" alt="" /></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedMinusFour_2x.png" alt="" /></p>

<p>正数的补码是原码；负数的补码是符号位不变，数值位各位取反，最后整个数加1，补码之所以被机器采用是因为它符合机器的架构设计，只用加法就能算减法：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSignedAddition_2x.png" alt="" /></p>

<p>有符号整型右移运算时用符号位填充：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/bitshiftSigned_2x.png" alt="" /></p>

<p>这就确保了在右移的过程中，有符整型的符号不会发生变化。这称为算术移位。</p>

<h2>溢出运算符</h2>

<p>Swift中如果计算结果超出了它的类型能承载的范围，那么就会发生溢出错误，除非你已经使用溢出运算符来进行操作：</p>

<ul>
<li>溢出加法 <code>&amp;+</code></li>
<li>溢出减法 <code>&amp;-</code></li>
<li>溢出乘法 <code>&amp;*</code></li>
<li>溢出除法 <code>&amp;/</code></li>
<li>溢出求余 <code>&amp;%</code></li>
</ul>


<h3>值的上溢出</h3>

<p><code>
var willOverflow = UInt8.max
// willOverflow 等于UInt8的最大整数 255
willOverflow = willOverflow &amp;+ 1
// 此时 willOverflow 等于 0
</code></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowAddition_2x.png" alt="" /></p>

<h3>值的下溢出</h3>

<p><code>
var willUnderflow = UInt8.min
// willUnderflow 等于UInt8的最小值0
willUnderflow = willUnderflow &amp;- 1
// 此时 willUnderflow 等于 255
</code></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowUnsignedSubtraction_2x.png" alt="" /></p>

<p>有符整型也有类似的下溢出</p>

<p><code>
var signedUnderflow = Int8.min
// signedUnderflow 等于最小的有符整数 -128
signedUnderflow = signedUnderflow &amp;- 1
// 此时 signedUnderflow 等于 127
</code></p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/overflowSignedSubtraction_2x.png" alt="" /></p>

<h3>除零溢出</h3>

<p>一个数除以0，或者对0求余数，就会产生一个错误；使用它们对应的可溢出的版本的运算符<code>&amp;/</code>和<code>&amp;%</code>进行除0操作时就会得到0值。</p>

<p><code>
let x = 1
let y = x &amp;/ 0
// y 等于 0
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Core Data(3)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3/"/>
    <updated>2014-07-03T10:28:28+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3</id>
    <content type="html"><![CDATA[<p>在Swift发布后，我尝试用Swift和Core Data做了一个小Demo，名字叫“HardChoice”。它用于帮助人们随机生成一个问题的结果，当然结果是预设好的，并可以加入权值。本文将通过这个Demo来进一步阐述Core Data的知识。</p>

<p>本文包含以下内容：</p>

<ul>
<li>建立数据模型</li>
<li>Swift与Objective-C桥接</li>
<li>NSFetchedResultsController</li>
<li>UITextField键盘响应</li>
<li>随机选择算法</li>
</ul>


<!--more-->


<p>你可以在<a href="https://github.com/yulingtianxia/HardChoice">GitHub</a>上下载HardChoice的代码</p>

<p>在没弄懂Core Data的基础知识之前，我建议你先阅读我之前的两篇博文：</p>

<p><a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a><br/>
<a href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/">初识Core Data(2)</a></p>

<p>如果你不懂Swift也没关系，只要了解OC和Core Data，总是能看懂的</p>

<p>在写代码前先了解下我们要做什么：<br/>
<img src="http://yulingtianxia.qiniudn.com/140435701469.png" alt="" />
<img src="http://yulingtianxia.qiniudn.com/1404357012.png" alt="" /></p>

<p>先在第一个页面添加问题（吃啥？），然后点击问题进入到第二个添加选项（鸭子，蛋，猪）的页面。每个选项左边是选项名，右边是该选项的权值。摇动手机就能随机从所有选项中选出答案（就像第二张图那样）。</p>

<h2>建立数据模型</h2>

<p>还是像以前那样新建一个Master-Detail Application，勾选Use Core Data选项，语言选择Swift，然后Xcode会自动生成一个具有<code>UITableView</code>的Demo，这些内容之前说过。下面我们需要打开xcdatamodeld文件来建立我们的数据模型：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140436356516.png" alt="" /></p>

<p><code>Question</code>这个实体只具有一个属性，那就是问题内容<code>content</code>，类型为<code>String</code>；<code>Choice</code>实体有一个类型为<code>String</code>的<code>name</code>属性和一个类型为<code>Integer32</code>的<code>weight</code>属性，分别代表问题选项的名字和权重。</p>

<p>下面我们来建立<code>Question</code>和<code>Choice</code>这两个实体之间的关系：</p>

<p>假设每个问题都对应多个选项，也可以没有选项：</p>

<p><img src="http://yulingtianxia.qiniudn.com/14043675716.png" alt="" /></p>

<p><code>Optional</code>被打钩是因为问题可以没有任何选项，在Tpye那里我们选择<code>To Many</code></p>

<p>相反，每个选项一定会对应一个问题，并且是唯一的问题：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140436793089.png" alt="" /></p>

<p><code>Optional</code>那里不打钩是为了避免关系的目标为空，在<code>Tpye</code>那里我们选择了<code>To One</code></p>

<p><strong>关于<code>Delete Rule</code>的选择</strong></p>

<p>下面会通过部门与员工的例子来阐述<code>Delete Rule</code>的用法</p>

<ul>
<li><strong><code>Deny</code></strong> 如果关系指向的目标仍然有对象，那么关系的源对象就不会被删除，比如你想删除一个部门，必须先确保该部门所有员工已经调到其他部门（或被解雇），否则这个部门就不会被删除。</li>
<li><strong><code>Nullify</code></strong> 将被删除对象反向关系的目标设为null，比如如果你删除了一个部门，那么将这个部门所有成员的department关系目标设为null。需要注意的是员工的department关系应该被勾选为Optional，或者是在删除部门之后马上给该部门员工设置一个新的部门。</li>
<li><strong><code>Cascade</code></strong> 顾名思义它会传递删除命令，删除一个对象会导致这个对象关系中所指向的所有目标对象也被删除。比如如果你删除了一个部门那么这个部门所有员工都会被立即删除。</li>
<li><strong><code>No Action</code></strong> 无为而治。比如如果你删除了一个部门，那么这个部门底下的所有员工什么都不知道，他们还以为自己还属于这个部门。</li>
</ul>


<p>回到我们的例子，因为<code>Question</code>指向<code>Choice</code>的<code>choices</code>关系具有从属的性质，问题被删除后<code>choices</code>所指向的选项也应该被删除，所以<code>choices</code>关系中的<code>Delete Rule</code>我们选择<code>Cascade</code>；而<code>Choice</code>指向<code>Question</code>的<code>question</code>关系中<code>Delete Rule</code>被设置成了<code>Nullify</code>，也就是解除了<code>Question</code>与这个<code>Choice</code>的关系，并且我们之前已经设置<code>Question</code>的<code>choices</code>关系设置为<code>Optional</code>来满足<code>Nullify</code>这一选项的要求。</p>

<p><strong>注意：每当你修改过数据模型后，需要将以前生成好的APP删除后再重新Run一下，这样才不会发生错误。这是因为手动删除APP会连同将其数据一起删除，然后重新Run一下会将新的数据表结构安装在模拟器或真机上</strong></p>

<p>如果你对建立数据模型的过程生疏，建议回到<a href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/">初识Core Data(2)</a>中复习下“使用数据模型设计器”一节</p>

<h2>Swift与Objective-C桥接</h2>

<p>在使用Xcode6 Beta2生成<code>NSManagedObject</code>子类的时候，生成的代码依然是Objective-C的代码（即使我的工程是用Swift语言建立的），这就涉及到在Swift工程中调用Objective-C类的问题。苹果给我们提供了一个比较简单的解决方案。在你向工程中加入OC文件时，Xcode会自动弹出消息问你是否需要生成一个桥接头文件（“工程名-Bridging-Header.h”），然后我们在这个头文件中加入想要在Swift中调用的OC类的头文件：</p>

<p>``` objc
//
//  Use this file to import your target&rsquo;s public headers that you would like to expose to Swift.
//</p>

<h1>import &ldquo;Question.h&rdquo;</h1>

<h1>import &ldquo;Choice.h&rdquo;</h1>

<h1>import &ldquo;CustomIOS7AlertView.h&rdquo;</h1>

<p>```</p>

<p><code>Question</code>和<code>Choice</code>这两个类是用之前数据模型中同名实例创建的<code>NSManagedObject</code>子类，<code>CustomIOS7AlertView</code>类是本项目用到的一个自定义AlertView（iOS7之后苹果不再允许自定义<code>UIAlertView</code>了）</p>

<p>这样在Swift文件中不用<code>import</code>任何东西就可以直接使用上面被引入的OC类了</p>

<p>有关Swift和OC在同一项目中混合使用的方法详见<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/Swift%20and%20Objective-C%20in%20the%20Same%20Project.md">这里</a></p>

<h2>NSFetchedResultsController</h2>

<p>在<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a>中我们提到过<code>NSFetchedResultsController</code>的作用，简单地说，<code>NSFetchedResultsController</code>的作用就是有效率的管理从CoreData获取请求的数据结果，并将结果提供给<code>UITableView</code>作为数据源。</p>

<p>在<code>MasterViewController.swift</code>文件中，Xcode生成了两个<code>NSFetchedResultsController</code>属性：一个只读计算属性<code>fetchedResultsController</code>和一个可选存储属性<code>_fetchedResultsController</code>，通过两者搭配来实现setter，这里不再多说，将计算属性<code>fetchedResultsController</code>的定义替换如下：</p>

<p>``` js</p>

<pre><code>var fetchedResultsController: NSFetchedResultsController {
    if _fetchedResultsController != nil {
        return _fetchedResultsController!
    }

    let fetchRequest = NSFetchRequest()
    // Edit the entity name as appropriate.
    let entity = NSEntityDescription.entityForName("Question", inManagedObjectContext: self.managedObjectContext)
    fetchRequest.entity = entity

    // Set the batch size to a suitable number.
    fetchRequest.fetchBatchSize = 20

    // Edit the sort key as appropriate.
    let sortDescriptor = NSSortDescriptor(key: "content", ascending: true)
    let sortDescriptors = [sortDescriptor]

    fetchRequest.sortDescriptors = sortDescriptors

    // Edit the section name key path and cache name if appropriate.
    // nil for section name key path means "no sections".
    let aFetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: self.managedObjectContext, sectionNameKeyPath: nil, cacheName: "Master")
    aFetchedResultsController.delegate = self
    _fetchedResultsController = aFetchedResultsController

    var error: NSError? = nil
    if !_fetchedResultsController!.performFetch(&amp;error) {
         // Replace this implementation with code to handle the error appropriately.
         // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
         //println("Unresolved error \(error), \(error.userInfo)")
         abort()
    }

    return _fetchedResultsController!
}
</code></pre>

<p>```</p>

<p><code>NSFetchRequest</code>对象描述了从数据持久层获取数据的标准，也就是相当于SQL中的from和where等条件语句，它是初始化<code>NSFetchedResultsController</code>的必要参数之一，因为它规定了从<code>NSManagedObjectContext</code>实例中获取什么样的数据。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353389167.png" alt="" /></p>

<p><code>NSFetchRequest</code>的属性<code>NSEntityDescription</code>，<code>predicate</code>和<code>sortDescriptors</code>分别对应着SQL中的from，where和order by语句，只不过<code>NSFetchRequest</code>把复杂的SQL语句进行了简化，查抄条件和排序方法更加灵活。</p>

<p>在上面的<code>fetchedResultsController</code>属性中我们设置了<code>NSFetchRequest</code>实例：获取所有<code>Question</code>实体对应的数据，并将结果按照<code>content</code>属性的升序排列。</p>

<p><code>init(fetchRequest: NSFetchRequest!, managedObjectContext context: NSManagedObjectContext!, sectionNameKeyPath: String!, cacheName name: String!)</code>是<code>NSFetchedResultsController</code>的指定构造器，除了刚才提到的<code>fetchRequest</code>参数外，还需传入一个必要参数<code>managedObjectContext</code>，在这里我们传入的<code>managedObjectContext</code>是来自<code>AppDelegate</code>的<code>managedObjectContext</code>属性。有关<code>NSManagedObjectContext</code>的知识参见<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a>，这里不再赘述。<strong>当构造器执行结束后，你就不能再修改<code>NSFetchedResultsController</code>的<code>fetchRequest</code>属性了</strong>。</p>

<p><code>sectionNameKeyPath</code>参数是用来指定抓取数据结果的<code>section</code>信息的，这样<code>UITableView</code>的<code>section</code>信息此时已经预编译好了。因为我们的程序只需要一个<code>section</code>，所以只需传入<code>nil</code>；<code>cacheName</code>参数用于指定缓存<code>section</code>预编译信息的文件名，我们不需要缓存<code>section</code>信息，所以传入<code>nil</code>。</p>

<p>当执行<code>performFetch(error: NSErrorPointer) -&gt; Bool</code>方法成功后，你可以通过<code>NSFetchedResultsController</code>的<code>fetchedObjects</code>属性来获取数据结果，如果为<code>UITableView</code>提供数据，可以用<code>objectAtIndexPath(indexPath: NSIndexPath!) -&gt; AnyObject!</code>方法来更加便捷的将数据与<code>NSIndexPath</code>对接上。在我们的例子中，会把数据结果转化为<code>NSManagedObject</code>的子类<code>Question</code>或<code>Choice</code>类：</p>

<p>```</p>

<pre><code>func configureCell(cell: UITableViewCell, atIndexPath indexPath: NSIndexPath) {
    let object = self.fetchedResultsController.objectAtIndexPath(indexPath) as Question
    cell.textLabel.text = object.content
}
</code></pre>

<p>```</p>

<p>下面修改<code>insertNewObject</code>方法来添加新的<code>Question</code>：</p>

<p>```</p>

<pre><code>var addAV = CustomIOS7AlertView()
func insertNewObject(sender: AnyObject) {
    let textField = UITextField(frame:CGRectMake(0,0,290,50))
    textField.becomeFirstResponder()
    textField.placeholder = "question"
    textField.keyboardType = .Default
    textField.returnKeyType = .Done
    textField.delegate = self
    addAV.containerView = textField
    addAV.buttonTitles = ["OK","Cancel"]
    addAV.delegate = self
    addAV.useMotionEffects = true
    addAV.show()

}
</code></pre>

<p>```</p>

<p>有了添加<code>Question</code>功能，当然还会有修改功能：</p>

<p>```</p>

<pre><code>var modifyAV = CustomIOS7AlertView()
func modifyObject(indexPath:NSIndexPath){
    let question = self.fetchedResultsController.objectAtIndexPath(indexPath) as Question
    let textField = UITextField(frame:CGRectMake(0,0,290,50))
    textField.becomeFirstResponder()
    textField.placeholder = "question"
    textField.keyboardType = .Default
    textField.returnKeyType = .Done
    textField.delegate = self
    modifyAV.containerView = textField
    modifyAV.buttonTitles = ["OK","Cancel"]
    modifyAV.delegate = self
    modifyAV.useMotionEffects = true
    (modifyAV.containerView as UITextField).text = question.content
    modifyAV.show()
}
</code></pre>

<p>```</p>

<p><code>CustomIOS7AlertView</code>是一个第三方的开源AlertView，它允许我们自定义AlertView的内容，并提供了<code>CustomIOS7AlertViewDelegate</code>协议来用于按钮点击的回调，我们将这两个<code>CustomIOS7AlertView</code>实例的<code>delegate</code>属性都设置为<code>self</code>，然后在<code>MasterViewController</code>中的实现协议中唯一的方法<code>customIOS7dialogButtonTouchUpInside(alertView:AnyObject!, clickedButtonAtIndex buttonIndex:Int)</code>：</p>

<p>```</p>

<pre><code>func customIOS7dialogButtonTouchUpInside(alertView:AnyObject!, clickedButtonAtIndex buttonIndex:Int){
    switch buttonIndex{
        case 0:
        let context = self.fetchedResultsController.managedObjectContext
        let entity = self.fetchedResultsController.fetchRequest.entity
        var newManagedObject:Question!
        let av = alertView as CustomIOS7AlertView
        if addAV == av{
            newManagedObject = NSEntityDescription.insertNewObjectForEntityForName(entity.name, inManagedObjectContext: context) as Question
        }
        if modifyAV == av{
            newManagedObject = self.fetchedResultsController.objectAtIndexPath(selectedIndexPath) as Question
        }
        // If appropriate, configure the new managed object.
        // Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
        newManagedObject.content = (av.containerView as UITextField).text

        // Save the context.
        var error: NSError? = nil
        if !context.save(&amp;error) {
            // Replace this implementation with code to handle the error appropriately.
            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
            //println("Unresolved error \(error), \(error.userInfo)")
            abort()
        }
        alertView.close()
        default:
        alertView.close()
    }
}
</code></pre>

<p>```</p>

<p>当用户点击<code>alertView</code>的OK按钮时，判断<code>alertView</code>对象是<code>addAV</code>还是<code>modifyAV</code>，然后对应通过不同途径（新插入到<code>ManagedObjectContext</code>还是从<code>ManagedObjectContext</code>中取出）产生<code>Question</code>实例<code>newManagedObject</code>，最后的结果会保存回<code>ManagedObjectContext</code>中，最后关闭<code>alertView</code>。</p>

<p>添加<code>Question</code>时使用的<code>insertNewObjectForEntityForName(entityName: String!, inManagedObjectContext context: NSManagedObjectContext!) -&gt; AnyObject!</code>方法是一个配置和添加实体，并返回该实体对应<code>NSManagedObject</code>子类（在这里是<code>Question</code>类）的便捷方法，这是一个很强大的类方法，我们无需知道创建<code>Question</code>类的细节就能创建并添加一个<code>Question</code>实例到<code>NSManagedObjectContext</code>中，在保存前我们还可以对这个方法返回的<code>Question</code>实例做修改，然后再通过<code>save(error: NSErrorPointer) -&gt; Bool</code>方法保存。</p>

<p>修改<code>Question</code>的过程其实就是先通过<code>objectAtIndexPath(indexPath: NSIndexPath!) -&gt; AnyObject!</code>方法取出数据请求结果当中的某一项并转换成<code>Question</code>对象，对其进行修改后再保存。在界面中通过点击cell右侧带有字母i的蓝色圆圈来修改<code>Question</code>内容：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140438530596.png" alt="" /></p>

<p>上图的中的蓝色圆圈是<code>AccessoryButton</code>，需要在IB中设置<code>TableViewCell</code>的<code>Identifier</code>为<code>QuestionCell</code>，<code>Accessory</code>为<code>Detail Disclosure</code>，这样我们就能在<code>UITableViewDelegate</code>的<code>tableView(tableView: UITableView!, accessoryButtonTappedForRowWithIndexPath indexPath: NSIndexPath!)</code>方法中响应<code>AccessoryButton</code>了：</p>

<p>```</p>

<pre><code>override func tableView(tableView: UITableView!, accessoryButtonTappedForRowWithIndexPath indexPath: NSIndexPath!){
    selectedIndexPath = indexPath
    modifyObject(indexPath)

}
</code></pre>

<p>```</p>

<p>导航栏右侧的添加<code>Question</code>按钮已经通过下面的代码配置了响应函数：</p>

<p><code>
let addButton = UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: "insertNewObject:")
self.navigationItem.rightBarButtonItem = addButton
</code>
在<code>UITableViewDelegate</code>中删除<code>Question</code>的代码如下：</p>

<p>```</p>

<pre><code>override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
    if editingStyle == .Delete {
        let context = self.fetchedResultsController.managedObjectContext
        context.deleteObject(self.fetchedResultsController.objectAtIndexPath(indexPath) as NSManagedObject)

        var error: NSError? = nil
        if !context.save(&amp;error) {
            // Replace this implementation with code to handle the error appropriately.
            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
            //println("Unresolved error \(error), \(error.userInfo)")
            abort()
        }
    }
}
</code></pre>

<p>```</p>

<p>这里多说一嘴，如果你想打印出错误信息的话，不要直接反注释那行<code>println</code>代码，还需要在<code>error</code>后加上感叹号，因为<code>error</code>是可选类型，需要强制解析：</p>

<p><code>
println("Unresolved error \(error!), \(error!.userInfo)")
</code></p>

<h2>UITextField键盘响应</h2>

<p>在将<code>UITextField</code>实例赋值给<code>CustomIOS7AlertView</code>的<code>containerView</code>属性前需要先让其获取当前焦点，并将<code>UITextField</code>的<code>delegate</code>属性设为<code>self</code>：</p>

<p>```</p>

<pre><code>var addAV = CustomIOS7AlertView()
func insertNewObject(sender: AnyObject) {
    let textField = UITextField(frame:CGRectMake(0,0,290,50))
    textField.becomeFirstResponder()//获取当前焦点
    textField.placeholder = "question"
    textField.keyboardType = .Default
    textField.returnKeyType = .Done
    textField.delegate = self
    addAV.containerView = textField
    addAV.buttonTitles = ["OK","Cancel"]
    addAV.delegate = self
    addAV.useMotionEffects = true
    addAV.show()

}
</code></pre>

<p>```</p>

<p>然后让<code>MasterViewController</code>遵循<code>UITextFieldDelegate</code>协议，并实现下面两个协议中的方法：</p>

<p>```</p>

<pre><code>func textFieldDidBeginEditing(textField: UITextField!){
    let animationDuration:NSTimeInterval  = 1
    var frame = self.view.frame;
    frame.origin.y-=116
    frame.size.height+=116
    self.view.frame = frame;
    UIView.animateWithDuration(animationDuration){
        self.view.frame = frame;
    }
}

func textFieldShouldEndEditing(textField: UITextField!) -&gt; Bool{
    let animationDuration:NSTimeInterval  = 1
    var frame = self.view.frame;
    frame.origin.y+=116;
    frame.size.height-=116;
    self.view.frame = frame;
    //self.view移回原位置
    UIView.animateWithDuration(animationDuration){
        self.view.frame = frame;
    }
    textField.resignFirstResponder();
    return true
}
</code></pre>

<p>```</p>

<p>这里我将键盘高度硬编码为116，当<code>UITextField</code>开始编辑时获取焦点键盘弹出，背景上移；当其结束编辑时键盘消失，背景移回原位。</p>

<p>在Xcode6 beta2中的模拟器不是很好使，经常不能弹出键盘，这里给出的代码有很多疏漏，只提供个参考，主要是处理<code>UITextField</code>代理的思想</p>

<h2>随机选择算法</h2>

<p><code>DetailViewController</code>的内容跟<code>MasterViewController</code>内容很像，最大的区别在于多了一个从<code>Choice</code>数据中随机抽选的一个方法。因为是通过摇一摇的方式来触发随机算法，所以我们重载<code>motionBegan(motion: UIEventSubtype, withEvent event: UIEvent!)</code>方法来响应手机摇动：</p>

<p>```
override func motionBegan(motion: UIEventSubtype, withEvent event: UIEvent!) {</p>

<pre><code>    if motion == .MotionShake{

        let count = self.fetchedResultsController.fetchedObjects.count
        var arr = fetchedResultsController.fetchedObjects
        var sum:Int = 0
        for object : AnyObject in arr{
            sum+=(object as Choice).weight.integerValue
        }
        if sum&gt;0{
            var lucknum = arc4random()%UInt32(sum)
</code></pre>

<p>//                println(&ldquo;(lucknum)&rdquo;)</p>

<pre><code>            var num = 0
            var n:UInt32 = 0
            while lucknum&gt;0{
                if lucknum &lt;= n{
                    break
                }
                else{
                    num++
                    lucknum-=n
                    if num&gt;=count{
                        break
                    }
                    n = UInt32((arr[num] as Choice).weight.integerValue)
                }
            }
</code></pre>

<p>//                println(&ldquo;(num)&rdquo;)</p>

<pre><code>            var alertView = UIAlertView()
            alertView.alertViewStyle = .Default
            alertView.title = "恭喜"
            alertView.message = "\(detailItem!.content)的答案是：\n\((arr[num] as Choice).name)"
            alertView.addButtonWithTitle("OK")
            alertView.show()
        }

    }
}
</code></pre>

<p>```</p>

<p>前面提到过<code>NSFetchedResultsController</code>对象在执行<code>performFetch(error: NSErrorPointer) -&gt; Bool</code>方法后会将获取的数据存在<code>fetchedObjects</code>数组中，上面这段代码首先获取该问题对应的选项数量，并通过加权运算得到总的权重，然后通过随机数算法生成一个幸运数字，最后计算幸运数字落在哪个选项上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Initialization in Swift]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/24/initialization-in-swift/"/>
    <updated>2014-06-24T09:50:23+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/24/initialization-in-swift</id>
    <content type="html"><![CDATA[<p>本文参考自Swift文档，主要包括以下内容：</p>

<ul>
<li>简介</li>
<li>自定义构造过程</li>
<li>默认构造器</li>
<li>值类型的构造器代理</li>
<li>类的继承和构造过程</li>
<li>通过闭包和函数来设置属性的默认值</li>
</ul>


<p>(2014-8-8更新至beta5语法)</p>

<!--more-->


<h2>简介</h2>

<p>构造过程是为了使用某个类、结构体或枚举类型的实例而进行的准备过程。这个过程包含了为实例中的每个属性设置初始值和为其执行必要的准备和初始化任务。</p>

<p>Swift中的构造器不像Objective-C那样有返回值，但是跟C++有点像：所有的构造器都以<code>init</code>命名，用参数列表来区分各个构造器</p>

<p>``` js
struct Fahrenheit {</p>

<pre><code>var temperature = 16.0
init() {
    temperature = 32.0
}
</code></pre>

<p>}
var f = Fahrenheit()
```</p>

<p><code>Fahrenheit</code>是一个结构体，与类一样，Swift中的值类型也有构造器和普通方法。上面的代码先是定义了<code>temperature</code>属性的默认值，然后又在构造器中将其赋值，最后<code>temperature</code>属性的值为32。对于<code>temperature</code>这种存储型属性，无论定义默认值还是在构造器中赋值，最终它们实现的效果是一样的。</p>

<p><strong>给存储型类型属性赋默认值或在初始构造器中设置初始值时，此属性的属性观察者不会被调用</strong></p>

<h2>自定义构造过程</h2>

<p>你可以定义一些带参数的构造器</p>

<p>```
struct Celsius {</p>

<pre><code>var temperatureInCelsius: Double = 0.0
init(fromFahrenheit fahrenheit: Double) {
    temperatureInCelsius = (fahrenheit - 32.0) / 1.8
}
init(fromKelvin kelvin: Double) {
    temperatureInCelsius = kelvin - 273.15
}
</code></pre>

<p>}
```
构造器的参数也跟Swift中的方法定义（注意不是函数）一样，也分内部和外部参数名。上面代码中两个构造器外部参数名不同，调用构造器的时候也是通过外部参数名来区分的：</p>

<p><code>
let boilingPointOfWater = Celsius(fromFahrenheit: 212.0)
// boilingPointOfWater.temperatureInCelsius 是 100.0
let freezingPointOfWater = Celsius(fromKelvin: 273.15)
// freezingPointOfWater.temperatureInCelsius 是 0.0”
</code>
如果不写外部参数名那么外部参数名就等于内部参数名：</p>

<p>```
struct Color {</p>

<pre><code>let red = 0.0, green = 0.0, blue = 0.0
init(red: Double, green: Double, blue: Double) {
    self.red   = red
    self.green = green
    self.blue  = blue
}
</code></pre>

<p>}
let magenta = Color(red: 1.0, green: 0.0, blue: 1.0)
```</p>

<p>如果你不希望为构造器的某个参数提供外部名字，你还可以使用下划线<code>_</code>来显示描述它的外部名：</p>

<p>```
struct Celsius {</p>

<pre><code>var temperatureInCelsius: Double
init(fromFahrenheit fahrenheit: Double) {
    temperatureInCelsius = (fahrenheit - 32.0) / 1.8
}
init(fromKelvin kelvin: Double) {
    temperatureInCelsius = kelvin - 273.15
}
init(_ celsius: Double) {
    temperatureInCelsius = celsius
}
</code></pre>

<p>}
let bodyTemperature = Celsius(37.0)
// bodyTemperature.temperatureInCelsius is 37.0
```</p>

<p>你会发现构造器的第一个内部参数名也会默认作为其外部参数名供调用，这一点与方法不同（方法不会默认将第一个内部参数名作为外部参数名使用），因为方法名可以在结尾加上介词来烘托出第一个参数的名字，这样就不需要为第一个参数弄一个外部参数名了，但是构造器只能用<code>init</code>关键字来定义。</p>

<p>如果你定制的类型包含一个逻辑上允许取值为空的存储型属性&mdash;不管是因为它无法在初始化时赋值，还是因为它可以在之后某个时间点可以赋值为空&mdash;你都需要将它定义为可选类型<code>optional type</code>。可选类型的属性将自动初始化为空<code>nil</code>，表示这个属性是故意在初始化时设置为空的。</p>

<p>```
class SurveyQuestion {</p>

<pre><code>let text: String
var response: String?
init(text: String) {
    self.text = text
}
func ask() {
    println(text)
}
</code></pre>

<p>}
let cheeseQuestion = SurveyQuestion(text: &ldquo;Do you like cheese?&rdquo;)
cheeseQuestion.ask()
// 输出 &ldquo;Do you like cheese?&rdquo;
cheeseQuestion.response = &ldquo;Yes, I do like cheese.
```</p>

<p>调查问题在问题提出之后，我们才能得到回答。所以我们将属性回答response声明为String?类型，或者说是可选字符串类型optional String。当SurveyQuestion实例化时，它将自动赋值为空nil，表明暂时还不存在此字符串。<br/>
只要在构造过程结束前常量的值能确定，你可以在构造过程中的任意时间点修改常量属性的值。尽管text属性是常量，我们仍然可以在其类的构造器中设置它的值。<strong>对某个类实例来说，它的常量属性只能在定义它的类的构造过程中修改；不能在子类中修改。</strong></p>

<h2>默认构造器</h2>

<p>Swift将为所有属性已提供默认值的且自身没有定义任何构造器的结构体或基类，提供一个默认的构造器。这个默认构造器将简单的创建一个所有属性值都设置为默认值的实例：</p>

<p>```
class ShoppingListItem {</p>

<pre><code>var name: String?
var quantity = 1
var purchased = false
</code></pre>

<p>}
var item = ShoppingListItem()
<code>``
</code>ShoppingListItem<code>类没有父类（是基类），所有属性都有默认值（可选属性默认值为</code>nil`），所以可以直接调用默认的无参数构造器来初始化。<br/>
除上面提到的默认构造器，如果结构体对所有存储型属性提供了默认值且自身没有提供定制的构造器，它们能自动获得一个<strong>逐一成员构造器（Memberwise Initializers）</strong>：</p>

<p>```
struct Size {</p>

<pre><code>var width = 0.0, height = 0.0
</code></pre>

<p>}
let twoByTwo = Size(width: 2.0, height: 2.0)
```
逐一成员构造器是用来初始化结构体新实例里成员属性的快捷方法。我们在调用逐一成员构造器时，通过与成员属性名相同的参数名进行传值来完成对成员属性的初始赋值。</p>

<h2>值类型的构造器代理</h2>

<p>构造器可以通过调用其它构造器来完成实例的部分构造过程。这一过程称为构造器代理，它能减少多个构造器间的代码重复：</p>

<p>```
struct Size {</p>

<pre><code>var width = 0.0, height = 0.0
</code></pre>

<p>}
struct Point {</p>

<pre><code>var x = 0.0, y = 0.0
</code></pre>

<p>}
struct Rect {</p>

<pre><code>var origin = Point()
var size = Size()
init() {}
init(origin: Point, size: Size) {
    self.origin = origin
    self.size = size
}
init(center: Point, size: Size) {
    let originX = center.x - (size.width / 2)
    let originY = center.y - (size.height / 2)
    self.init(origin: Point(x: originX, y: originY), size: size)
}
</code></pre>

<p>}
<code>``
在值类型中，如果你添加了自定义构造器（如</code>init(center: Point, size: Size)<code>），Swift不会再为结构体生成一个默认构造器和逐一成员构造器，所以我们自己定义了</code>init()<code>和</code>init(origin: Point, size: Size)<code>，他们与自动生成的默认构造器和逐一成员构造器是一样的。这样子会显得很麻烦，我们可以将自定义构造器</code>init(center: Point, size: Size)<code>写在结构体</code>Rect<code>的扩展（</code>extension`）里，这样就不用自己把默认构造器和逐一成员构造器写一遍了。</p>

<p>构造器<code>init(center:size:)</code>先通过<code>center</code>和<code>size</code>的值计算出<code>origin</code>的坐标。然后再调用（或代理给）<code>init(origin:size:)</code>构造器来将新的<code>origin</code>和<code>size</code>值赋值到对应的属性中。因为值类型（结构体和枚举类型）不支持继承，所以构造器代理的过程相对简单，因为它们只能代理给本身提供的其它构造器：你只能在构造器内部调用<code>self.init</code></p>

<h2>类的继承和构造过程</h2>

<p>类里面的所有存储型属性&mdash;包括所有继承自父类的属性&mdash;都必须在构造过程中设置初始值。</p>

<p>Swift 提供了两种类型的类构造器来确保所有类实例中存储型属性都能获得初始值，它们分别是指定构造器(<code>Designated Initializers</code>)和便利构造器(<code>Convenience Initializers</code>)。</p>

<h3>指定构造器和便利构造器</h3>

<p>指定构造器是类中最主要的构造器。一个指定构造器将初始化类中提供的所有属性，并根据父类链往上调用父类的构造器来实现父类的初始化。<strong>每一个类都必须拥有至少一个指定构造器。</strong></p>

<p>便利构造器是类中比较次要的、辅助型的构造器。你可以定义便利构造器来调用同一个类中的指定构造器，并为其参数提供默认值。你也可以定义便利构造器来创建一个特殊用途或特定输入的实例。</p>

<p>类的指定构造器的写法跟值类型简单构造器一样，便利构造器也采用相同样式的写法，但需要在<code>init</code>关键字之前放置<code>convenience</code>关键字：</p>

<p>```
convenience init(parameters) {</p>

<pre><code>statements
</code></pre>

<p>}
```</p>

<h3>构造器链</h3>

<p>为了简化指定构造器和便利构造器之间的调用关系，Swift 采用以下三条规则来限制构造器之间的代理调用：</p>

<ol>
<li>指定构造器必须调用其直接父类的的指定构造器。</li>
<li>便利构造器必须调用同一类中定义的其它构造器。</li>
<li>便利构造器必须最终以调用一个指定构造器结束。</li>
</ol>


<p>一个更方便记忆的方法是:</p>

<ul>
<li>指定构造器必须总是向上代理</li>
<li>便利构造器必须总是横向代理</li>
</ul>


<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializerDelegation01_2x.png" alt="" />
举个栗子：</p>

<p>```
class Food {</p>

<pre><code>var name: String
init(name: String) {
    self.name = name
}
convenience init() {
    self.init(name: "[Unnamed]")
}
</code></pre>

<p>}
let namedMeat = Food(name: &ldquo;Bacon&rdquo;)
// namedMeat 的名字是 &ldquo;Bacon”
let mysteryMeat = Food()
// mysteryMeat 的名字是 [Unnamed]
```</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample01_2x.png" alt="" /></p>

<h3>两段式构造过程</h3>

<p>Swift 中类的构造过程包含两个阶段。第一个阶段，每个存储型属性通过引入它们的类的构造器来设置初始值。当每一个存储型属性值被确定后，第二阶段开始，它给每个类一次机会在新实例准备使用之前进一步定制它们的存储型属性。<br/>
下图展示了在假定的子类和父类之间构造的阶段1：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/twoPhaseInitialization01_2x.png" alt="" /></p>

<p>指定构造器将确保所有子类的属性都有值，然后它将调用父类的指定构造器，并沿着造器链一直往上完成父类的构建过程。一旦父类中所有属性都有了初始值，实例的内存被认为是完全初始化，而阶段1也已完成。</p>

<p>以下展示了相同构造过程的阶段2：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/twoPhaseInitialization02_2x.png" alt="" /></p>

<p>父类中的指定构造器现在有机会进一步来定制实例（尽管它没有这种必要）。</p>

<p>一旦父类中的指定构造器完成调用，子类的构指定构造器可以执行更多的定制操作（同样，它也没有这种必要）。</p>

<p>最终，一旦子类的指定构造器完成调用，最开始被调用的便利构造器可以执行更多的定制操作。</p>

<p>两段式构造过程是基于<strong>安全检查</strong>的，可以简单的理解为：</p>

<ul>
<li>指定构造器初始化顺序：初始化类自己引入的属性->向上代理调用父类指定构造器->为继承的属性设置新值</li>
<li>便利构造器初始化顺序：代理调用同一类中的其它构造器->为任意属性赋新值</li>
<li>构造器在第一阶段构造完成之前，不能调用任何实例方法、不能读取任何实例属性的值，也不能引用self的值。</li>
</ul>


<h3>构造器的继承和重载</h3>

<p><strong>跟 Objective-C 中的子类不同，Swift 中的子类不会默认继承父类的构造器。</strong>这是为了防止你想初始化一个很牛逼的类，但是调用的却是它继承于父类的菜逼构造器，那将会是个悲剧。</p>

<p><strong>但是如果特定条件可以满足，父类构造器是可以被自动继承的：</strong></p>

<ol>
<li>如果子类没有定义任何指定构造器，它将自动继承所有父类的指定构造器。</li>
<li>如果子类提供了所有父类指定构造器的实现&mdash;不管是通过规则1继承过来的，还是通过自定义实现的&mdash;它将自动继承所有父类的便利构造器。</li>
</ol>


<p>即使你在子类中添加了更多的便利构造器，这两条规则仍然适用。子类可以通过定义便利构造器来实现父类中的指定构造器，来部分满足规则2</p>

<p>如果你需要在子类中重写一个父类的指定构造器（包括自动生成的默认构造器），无论子类中的构造器是指定构造器还是便利构造器，都需要在子类定义重载的构造器前加上<code>override</code>修饰；如果你需要在子类中重写一个父类的便利构造器，根据构造器链，父类的便利构造器不会被子类直接调用，所以不必在子类重写构造器的定义前用<code>override</code>修饰。这是Xcode6beta5新修订的规则，在以前的版本中重载构造器不用<code>override</code>修饰。</p>

<p>还记得之前指定的<code>Food</code>类吧，现在它多了一个子类<code>RecipeIngredient</code>:</p>

<p>```
class RecipeIngredient: Food {</p>

<pre><code>var quantity: Int
init(name: String, quantity: Int) {
    self.quantity = quantity
    super.init(name: name)
}
override convenience init(name: String) {
    self.init(name: name, quantity: 1)
}
</code></pre>

<p>}
<code>``
可以看出来</code>RecipeIngredient<code>类的指定构造器和便利构造器都符合两段式构造安全检查，并且便利构造器跟</code>Food<code>类中的指定构造器具有相同的参数，尽管</code>RecipeIngredient<code>这个构造器是便利构造器，</code>RecipeIngredient<code>依然提供了对所有父类指定构造器的实现。因此，</code>RecipeIngredient<code>也能自动继承了所有父类的便利构造器(也就是</code>init()`):</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample02_2x.png" alt="" /></p>

<p>上图中<code>RecipeIngredient</code>类继承的init()函数版本跟Food提供的版本是一样的，除了它是将任务代理给RecipeIngredient版本的init(name: String)而不是Food提供的版本。</p>

<p>食材都已经建立好了，下面开始采购吧！我们需要一个购物单，购物单中每一项是这样子的：</p>

<p>```
class ShoppingListItem: RecipeIngredient {</p>

<pre><code>var purchased = false
var description: String {
var output = "\(quantity) x \(name.lowercaseString)"
    output += purchased ? " ✔" : " ✘"
    return output
}
</code></pre>

<p>}
```</p>

<p>由于它为自己引入的所有属性都提供了默认值，并且自己没有定义任何构造器，ShoppingListItem将自动继承所有父类中的指定构造器和便利构造器。</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/swift/conceptual/swift_programming_language/Art/initializersExample03_2x.png" alt="" /></p>

<p>你可以使用全部三个继承来的构造器来创建ShoppingListItem的新实例：</p>

<p>```
var breakfastList = [</p>

<pre><code>ShoppingListItem(),
ShoppingListItem(name: "Bacon"),
ShoppingListItem(name: "Eggs", quantity: 6),
</code></pre>

<p>]
breakfastList[0].name = &ldquo;Orange juice&rdquo;
breakfastList[0].purchased = true
for item in breakfastList {</p>

<pre><code>println(item.description)
</code></pre>

<p>}
// 1 x orange juice ✔
// 1 x bacon ✘
// 6 x eggs ✘
```</p>

<h3>必需构造器</h3>

<p>当你想让一个类的某个构造器被所有子类都实现，你可以在定义这个构造器时在前面用<code>required</code>修饰：</p>

<p>```
class SomeClass {</p>

<pre><code>required init() {
    // initializer implementation goes here
}
</code></pre>

<p>}
```</p>

<p>你也必须在它的子类定义必需构造器前用<code>required</code>修饰，但不必用<code>override</code>修饰：</p>

<p>```
class SomeSubClass: SomeClass {</p>

<pre><code>required init() {
    // subclass implementation of the required initializer goes here
}
</code></pre>

<p>}
```</p>

<p>这样的语法可以将这种“必需”信号传递给未来更多的子类，表明这个构造器一定要实现，千秋万代~</p>

<p>当然你可以满足构造器的继承规则来继承必需构造器，这样就不用“必须”重写“必需”构造器了：</p>

<p>```
class SomeSubSubClass:SomeSubClass {</p>

<pre><code>convenience init(a:String) {
    self.init()
    //subsubclass implementation of a convenience initializer goes here
}
</code></pre>

<p>}
```</p>

<h2>通过闭包和函数来设置属性的默认值</h2>

<p>如果某个存储型属性的默认值需要特别的定制或准备，你就可以使用闭包或全局函数来为其属性提供定制的默认值。每当某个属性所属的新类型实例创建时，对应的闭包或函数会被调用，而它们的返回值会当做默认值赋值给这个属性。</p>

<p>```
class SomeClass {</p>

<pre><code>let someProperty: SomeType = {
    // 在这个闭包中给 someProperty 创建一个默认值
    // someValue 必须和 SomeType 类型相同
    return someValue
    }()
</code></pre>

<p>}
```</p>

<p>注意闭包结尾的大括号后面接了一对空的小括号。这是用来告诉 Swift 需要立刻执行此闭包。如果你忽略了这对括号，相当于是将闭包本身作为值赋值给了属性，而不是将闭包的返回值赋值给属性。</p>

<p>如果你使用闭包来初始化属性的值，请记住在闭包执行时，实例的其它部分都还没有初始化。这意味着你不能够在闭包里访问其它的属性，就算这个属性有默认值也不允许。同样，你也不能使用隐式的self属性，或者调用其它的实例方法。</p>
]]></content>
  </entry>
  
</feed>
