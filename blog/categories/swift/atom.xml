<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Swift | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/swift/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-06-24T00:11:29+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Optionals and Optional Chaining in Swift]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/17/optionals-and-optional-chaining-in-swift/"/>
    <updated>2014-06-17T20:42:17+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/17/optionals-and-optional-chaining-in-swift</id>
    <content type="html"><![CDATA[<p>可选类型（<code>Optionals</code>）在Swift中用于处理值可能缺失的情况，也就是说可能存在没有值的情况。C 和 Objective-C 中并没有可选类型这个概念。但在Objective-C中，一个方法的返回值可以是一个对象或<code>nil</code>值（<code>nil</code>表示缺少一个合法对象），而对象只是针对类而言，结构体、基本C类型和枚举并不适用<code>nil</code>来表示值的缺失，对于这些类型，Objective-C 方法一般会返回一个特殊值（比如<code>NSNotFound</code>）来暗示值缺失。这种表示“值缺失”方法不统一的局面使得调用方法的程序员蛋疼了-需要针对不同情况进行处理-但随着可选类型的诞生，这种情形在Swift中得到解决，<code>Optionals</code>可以表示任意类型值的缺失。</p>

<!--more-->


<h2>可选类型（Optionals）</h2>

<p>在Swift中，有时候需要把内容为数字的字符串转化成数字：</p>

<p><code>js
let possibleNumber = "123"
let convertedNumber = possibleNumber.toInt()
// convertedNumber 被推测为类型 "Int?"， 或者类型 "optional Int"
</code>
因为Swift是类型安全的语言，为了保证转化过程中不出错，<code>toInt()</code>方法返回的是一个<code>Optional&lt;Int&gt;</code>(也可写成<code>Int?</code>)类型的实例。如果被转化的字符串不是一个数字（比如是“hello world”），那样<code>toInt()</code>返回的内容将不含有<code>Int</code>值。这保证了整个过程不报错，下面我们可以“优雅的”检查下<code>convertedNumber</code>是否有<code>Int</code>值：</p>

<p>```
if convertedNumber {</p>

<pre><code>println("\(possibleNumber) has an integer value of \(convertedNumber!)")
</code></pre>

<p>} else {</p>

<pre><code>println("\(possibleNumber) could not be converted to an integer")
</code></pre>

<p>}
// 输出 &ldquo;123 has an integer value of 123&rdquo;
```
当你确定可选类型确实包含值之后，你可以在可选的名字后面加一个感叹号（!）来获取值。这个惊叹号表示“我知道这个可选有值，请使用它。”这被称为可选值的强制解析（forced unwrapping）</p>

<p>这里细心的同学可能看不懂了：<code>convertedNumber</code>不是应该是一个可选的整型值么，怎么还能作为条件判断的逻辑值（Bool）呢？让我们来分析下<code>Optional</code>类型的真身：</p>

<p>```
enum Optional<T> : LogicValue, Reflectable {</p>

<pre><code>case None
case Some(T)
init()
init(_ some: T)

/// Allow use in a Boolean context.
func getLogicValue() -&gt; Bool

/// Haskell's fmap, which was mis-named
func map&lt;U&gt;(f: (T) -&gt; U) -&gt; U?
func getMirror() -&gt; Mirror
</code></pre>

<p>}
```</p>

<p>原来可选类型是本质是一个枚举类型，包含两个成员：<code>None</code>和<code>Some</code>，其中<code>Some</code>成员还有一个类型为泛型<code>T</code>的关联值（Associated Values）。它之所以能够当做条件判断语句是因为它遵循了<code>LogicValue</code>协议：</p>

<p><code>``
/// Protocol describing types that can be used as logical values within
/// a condition.
///
/// Types that conform to the</code>LogicValue<code>protocol can be used as
/// condition in various control statements (</code>if<code>,</code>while<code>, C-style
///</code>for<code>) as well as other logical value contexts (e.g.,</code>case`
/// statement guards).
protocol LogicValue {</p>

<pre><code>func getLogicValue() -&gt; Bool
</code></pre>

<p>}
<code>``
看了Swift对</code>LogicValue<code>协议的描述，这下子应该明白了吧。光凭猜测大约知道：当可选类型有值的时候其实是</code>Some<code>成员，并在构造器</code>init(_ some: T)<code>调用时将值存储在</code>Some<code>成员的关联值中，此时</code>getLogicValue()<code>方法返回true；当可选类型没有值的时候其实是</code>None<code>成员，并在构造器</code>init()<code>调用时将</code>nil<code>给了</code>None<code>成员，具体细节不是很清楚。  
看得出可选类型的设计借鉴了Haskell语言，至于</code>nil`到底是什么：</p>

<p><code>
/// A null sentinel value.
var nil: NilType { get }
</code>
<code>nil</code>是<code>NilType</code>类型唯一的实例，好特殊啊。Swift 的<code>nil</code>和 Objective-C 中的<code>nil</code>并不一样。在 Objective-C 中，<code>nil</code>是一个指向不存在对象的指针。在 Swift 中，<code>nil</code>不是指针——它是一个确定的值，用来表示值缺失。任何类型的可选状态都可以被设置为<code>nil</code>，不只是对象类型。</p>

<p><strong>可选类型默认值为<code>nil</code></strong></p>

<p>除了用if语句判断和强制解析来获取可选类型中的值，还可以用可选绑定的方式来来判断可选类型是否包含值：</p>

<p>```
if let constantName = someOptional {</p>

<pre><code>statements
</code></pre>

<p>}
```
于是之前的例子可以可以改写为：</p>

<p>```
if let actualNumber = possibleNumber.toInt() {</p>

<pre><code>println("\(possibleNumber) has an integer value of \(actualNumber)")
</code></pre>

<p>} else {</p>

<pre><code>println("\(possibleNumber) could not be converted to an integer")
</code></pre>

<p>}
// 输出 &ldquo;123 has an integer value of 123&rdquo;
```</p>

<p>如果<code>possibleNumber.toInt</code>返回的可选<code>Int</code>包含一个值，创建一个叫做<code>actualNumber</code>的新常量并将可选包含的值赋给它。它已经被可选类型包含的值初始化过，所以不需要再使用<code>!</code>后缀来获取它的值。</p>

<p>有时候在程序架构中，第一次被赋值之后，可以确定一个可选类型总会有值。在这种情况下，每次都要判断和解析可选值是非常低效的，因为可以确定它总会有值。这种类型的可选状态被定义为<strong>隐式解析可选类型</strong>（implicitly unwrapped optionals）。把想要用作可选的类型的后面的问号（String?）改成感叹号（String!）来声明一个隐式解析可选类型。</p>

<p><code>
let possibleString: String? = "An optional string."
println(possibleString!) // 需要惊叹号来获取值
// 输出 "An optional string."
let assumedString: String! = "An implicitly unwrapped optional string."
println(assumedString)  // 不需要感叹号
// 输出 "An implicitly unwrapped optional string."
</code>
你仍然可以把隐式解析可选类型当做普通可选类型来判断它是否包含值：</p>

<p>```
if assumedString {</p>

<pre><code>println(assumedString)
</code></pre>

<p>}
// 输出 &ldquo;An implicitly unwrapped optional string.&rdquo;
```
你也可以在可选绑定中使用隐式解析可选类型来检查并解析它的值：</p>

<p>```
if let definiteString = assumedString {</p>

<pre><code>println(definiteString)
</code></pre>

<p>}
// 输出 &ldquo;An implicitly unwrapped optional string.&rdquo;
<code>``
可能看到这里你会觉得隐式解析可选类型的存在意义是什么？为何不直接用普通的非可选类型呢？其实</code>Implicitly Unwrapped Optionals`被用于类的初始化方法中，避免循环引用:</p>

<p>```
class Country {</p>

<pre><code>let name: String
let capitalCity: City!
init(name: String, capitalName: String) {
    self.name = name
    self.capitalCity = City(name: capitalName, country: self)
}
</code></pre>

<p>}</p>

<p>class City {</p>

<pre><code>let name: String
unowned let country: Country
init(name: String, country: Country) {
    self.name = name
    self.country = country
}
</code></pre>

<p>}</p>

<p>var country = Country(name: &ldquo;Canada&rdquo;, capitalName: &ldquo;Ottawa&rdquo;)
println(&ldquo;(country.name)&rsquo;s capital city is called (country.capitalCity.name)&rdquo;)
// prints &ldquo;Canada&rsquo;s capital city is called Ottawa”</p>

<p>```</p>

<p>因为编译器会将其认为默认<code>nil</code>，不需赋值就可以完成类的初始化，在例子中<code>capitalCity</code>还没被赋值时<code>Country</code>类就已经初始化并可以被引用；这样就能实现一行代码建立<code>Country</code>和<code>City</code>实例而不造成强引用循环。有关ARC的更多知识可以看看这篇<a href="http://yulingtianxia.com/blog/2014/06/17/swiftzhong-de-arc/">文章</a></p>

<h2>可选链（Optional Chaining）</h2>

<p>可选链（Optional Chaining）是一种可以请求和调用属性、方法及下标的过程，它的可选性体现于请求或调用的目标当前可能为空（nil）。如果可选的目标有值，那么调用就会成功；相反，如果选择的目标为空（nil），则这种调用将返回空（nil）。多次请求或调用可以被链接在一起形成一个链，如果任何一个节点为空（nil）将导致整个链失效。</p>

<p>可能官方的定义不接地气，先来个例子做铺垫：</p>

<p>```
class Person {</p>

<pre><code>var residence: Residence?
</code></pre>

<p>}</p>

<p>class Residence {</p>

<pre><code>var rooms = Room[]()
var numberOfRooms: Int {
return rooms.count
}
subscript(i: Int) -&gt; Room {
    return rooms[i]
}
func printNumberOfRooms() {
    println("The number of rooms is \(numberOfRooms)")
}
var address: Address?
</code></pre>

<p>}</p>

<p>class Room {</p>

<pre><code>let name: String
init(name: String) { self.name = name }
</code></pre>

<p>}</p>

<p>class Address {</p>

<pre><code>var buildingName: String?
var buildingNumber: String?
var street: String?
func buildingIdentifier() -&gt; String? {
    if buildingName {
        return buildingName
    } else if buildingNumber {
        return buildingNumber
    } else {
        return nil
    }
}
</code></pre>

<p>}
```</p>

<p>人（<code>Person</code>）可能会拥有住所（<code>Residence</code>），一个住所肯定会有一些带名字的房间（<code>Room</code>），还有可能注明所在地址（<code>Address</code>）。住所还提供了获取房间数目的方法，并能通过下标访问某个房间，而地址包含了一些可选的信息。</p>

<p>PS：不要嫌我墨迹，官方文档比我墨迹多了。。。</p>

<p>现在我造个人（邪恶的孩子面壁思过去！），就叫john</p>

<p><code>
let john = Person()
</code>
如果我们想知道john同学家房子大不大，有几个房间啊？但是直接问不太好，万一john家里穷漂泊不定四海为家，那不就玩脱了么？</p>

<p><code>
let roomCount = john.residence!.numberOfRooms
//将导致运行时错误
</code></p>

<p>所以还是先问问他家有没有房子吧：</p>

<p>```
if let roomCount = john.residence?.numberOfRooms {</p>

<pre><code>println("John's residence has \(roomCount) room(s).")
</code></pre>

<p>} else {</p>

<pre><code>println("我造john的时候没给他分房子，这可怜孩子！")
</code></pre>

<p>}
// 打印 &ldquo;我造john的时候没给他分房子，这可怜孩子！&rdquo;
<code>``
可选链提供了一种另一种获得</code>numberOfRooms<code>的方法。利用可选链，使用</code>?<code>来代替原来</code>!<code>的位置，因为这种尝试获得</code>numberOfRooms<code>的操作有可能失败，可选链会返回</code>Int?<code>类型值。要注意的是，虽然</code>numberOfRooms<code>是非可选</code>Int<code>，这一点也成立。只要是通过可选链的请求就意味着最后</code>numberOfRooms<code>总是返回一个</code>Int?<code>而不是</code>Int`。</p>

<p>我们也可以在可选链上调用方法：</p>

<p>```
if john.residence?.printNumberOfRooms() {</p>

<pre><code>println("It was possible to print the number of rooms.")
</code></pre>

<p>} else {</p>

<pre><code>println("It was not possible to print the number of rooms.")
</code></pre>

<p>}
// 打印 &ldquo;It was not possible to print the number of rooms.&rdquo;
```</p>

<p>虽然<code>printNumberOfRooms</code>方法无返回值，但是它有一个隐式的返回类型<code>Void</code>，在可选链上调用后返回类型就成了<code>Void?</code>，既然是可选类型，就可以放到if语句条件判断中啦！</p>

<p>现在想看看john家第一间房子名字叫啥，但却怕人家没房子遭遇尴尬，不用怕：</p>

<p>```
if let firstRoomName = john.residence?[0].name {</p>

<pre><code>println("The first room name is \(firstRoomName).")
</code></pre>

<p>} else {</p>

<pre><code>println("连房子都没有更别提第一间房间名了！")
</code></pre>

<p>}
// 打印 &ldquo;连房子都没有更别提第一间房间名了！&rdquo;
<code>``
在下标调用中可选链的问号直接跟在</code>john.residence<code>的后面，在下标中括号的前面，因为</code>john.residence<code>才是可选链试图获得的可选值。（关键是</code>Person<code>不一定有</code>residence<code>，但</code>Residence<code>肯定有</code>rooms`）</p>

<p>造个john玩了人家这么久，还不快给人家分套房子！（其实是为了演示后面的<code>Address</code>）</p>

<p>```
let johnsHouse = Residence()
johnsHouse.rooms += Room(name: &ldquo;Living Room&rdquo;)
johnsHouse.rooms += Room(name: &ldquo;Kitchen&rdquo;)
john.residence = johnsHouse</p>

<p>if let firstRoomName = john.residence?[0].name {</p>

<pre><code>println("The first room name is \(firstRoomName).")
</code></pre>

<p>} else {</p>

<pre><code>println("Unable to retrieve the first room name.")
</code></pre>

<p>}
// 打印 &ldquo;The first room name is Living Room."。
```</p>

<p>现在john乔迁新居奔小康了，快问问他家地址，好串个门</p>

<p>```
let johnsAddress = Address()
johnsAddress.buildingName = &ldquo;The Larches&rdquo;
johnsAddress.street = &ldquo;Laurel Street&rdquo;
john.residence!.address = johnsAddress
if let johnsStreet = john.residence?.address?.street {</p>

<pre><code>println("John's street name is \(johnsStreet).")
</code></pre>

<p>} else {</p>

<pre><code>println("Unable to retrieve the address.")
</code></pre>

<p>}
// 打印 &ldquo;John&rsquo;s street name is Laurel Street.&rdquo;
<code>``
值得注意的是</code>john.residence<code>属性是一个可选类型并且已经不为</code>nil<code>(刚刚奔小康了嘛)，因此你需要在它获取</code>address<code>属性之前使用</code>!`强制解析以获得它的实际值。</p>

<p>虽然这条可选链上有两个问号（两层可选链），但其返回类型依然是可选类型（<code>String?</code>），而不是可选类型的嵌套（<code>String??</code>即<code>Optional&lt;Optional&lt;String&gt;&gt;</code>）。你可以将多层可选链连接在一起，可以掘取模型内更下层的属性方法和下标。然而多层可选链不能再添加比已经返回的可选值更多的层。 也就是说：</p>

<p><strong>如果你试图获得的类型不是可选类型，由于使用了可选链它将变成可选类型。 如果你试图获得的类型已经是可选类型，由于可选链它也不会提高可选性。</strong></p>

<p>前面的例子解释了如何通过可选链来获得可选类型属性值。你也可以通过可选链调用一个返回可选类型值的方法并按需链接该方法的返回值。 如上所述，<code>buildingIdentifier</code>方法在可选链调用后最终的返回值类型依然是<code>String?</code>:</p>

<p>```
if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {</p>

<pre><code>println("John's building identifier is \(buildingIdentifier).")
</code></pre>

<p>}
// 打印 &ldquo;John&rsquo;s building identifier is The Larches.&rdquo;
```
如果你还想进一步对方法返回值执行可选链，将可选链问号符放在方法括号的后面：</p>

<p>```
if let upper = john.residence?.address?.buildingIdentifier()?.uppercaseString {</p>

<pre><code>println("John's uppercase building identifier is \(upper).")
</code></pre>

<p>}
// 打印 &ldquo;John&rsquo;s uppercase building identifier is THE LARCHES.&rdquo;
<code>``
你将可选链问号符放在括号后面是因为你想要链接的可选值是</code>buildingIdentifier<code>方法的返回值，不是</code>buildingIdentifier`方法本身。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift中的ARC]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/17/swiftzhong-de-arc/"/>
    <updated>2014-06-17T10:32:38+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/17/swiftzhong-de-arc</id>
    <content type="html"><![CDATA[<p>Objective-C中的ARC被Swift很好的继承下来了，本文参考自Swift文档网上的翻译，主要重点记录下Swift中的ARC与OC对比需要注意的地方。</p>

<!--more-->


<h2>简介</h2>

<p>当你每次创建一个类的新的实例的时候，ARC 会分配一大块内存用来储存实例的信息。内存中会包含实例的类型信息，以及这个实例所有相关属性的值。此外，当实例不再被使用时，ARC 释放实例所占用的内存，并让释放的内存能挪作他用。这确保了不再被使用的实例，不会一直占用内存空间。</p>

<h2>类实例之间强引用循环的产生</h2>

<p>如果你对OC中的强引用循环很了解，可以直接跳过这节。</p>

<p>但是如果两个类的实例之间互相引用，这样就产生了强引用循环。下面展示了一个不经意产生强引用循环的例子。例子定义了两个类：<code>Person</code>和<code>Apartment</code>，用来建模公寓和它其中的居民:</p>

<p>``` js
class Person {</p>

<pre><code>let name: String
init(name: String) { self.name = name }
var apartment: Apartment?
deinit { println("\(name) is being deinitialized") }
</code></pre>

<p>}</p>

<p>class Apartment {</p>

<pre><code>let number: Int
init(number: Int) { self.number = number }
var tenant: Person?
deinit { println("Apartment #\(number) is being deinitialized") }
</code></pre>

<p>}
```</p>

<p>接下来的代码片段定义了两个可选类型的变量<code>john</code>和<code>number73</code>,并分别被设定为下面的<code>Apartment</code>和<code>Person</code>的实例。这两个变量都被初始化为<code>nil</code>，并为可选的（让它们可选是为了以后能销毁，为了演示程序）：</p>

<p><code>
var john: Person?
var number73: Apartment?
</code></p>

<p>现在你可以创建特定的<code>Person</code>和<code>Apartment</code>实例并将类实例赋值给<code>john</code>和<code>number73</code>变量：</p>

<p><code>
john = Person(name: "John Appleseed")
number73 = Apartment(number: 73)
</code></p>

<p>在<code>john</code>和<code>number73</code>互相引用之前，它们的强引用关系是这样的：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle01_2x.png" alt="" /></p>

<p>现在你能够将这两个实例关联在一起，这样人就能有公寓住了，而公寓也有了房客。注意感叹号是用来强制解析可选变量<code>john</code>和<code>number73</code>中的实例：</p>

<p><code>
john!.apartment = number73
number73!.tenant = john
</code>
在将两个实例联系在一起之后，强引用的关系变成了这样：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle02_2x.png" alt="" /></p>

<p>这样即使让<code>john</code>和<code>number73</code>断开它们持有的强引用，内存中的那两个<code>Person</code>和<code>Apartment</code>实例并不会销毁，因为它们互相引用，引用计数都为1：</p>

<p><code>
john = nil
number73 = nil
</code>
当你把这两个变量设为<code>nil</code>时，没有任何一个析构函数被调用。强引用循环阻止了<code>Person</code>和<code>Apartment</code>类实例的销毁，并在你的应用程序中造成了内存泄漏。</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/referenceCycle03_2x.png" alt="" /></p>

<h2>如何解决实例间强引用循环</h2>

<h3>弱引用</h3>

<p>跟OC中的弱引用相似，声明属性或者变量时，在前面加上<code>weak</code>关键字表明这是一个弱引用。弱引用不会牢牢保持住引用的实例，并且不会阻止 ARC 销毁被引用的实例。因为弱引用的值会变化并可能为<code>nil</code>，所以弱引用不能是常量，必须是可选类型（Optional）。因为弱引用不会保持所引用的实例，即使引用存在，实例也有可能被销毁。因此，ARC 会在引用的实例被销毁后自动将其赋值为nil。</p>

<p>下面的例子跟上面<code>Person</code>和<code>Apartment</code>的例子一致，但是有一个重要的区别。这一次，<code>Apartment</code>的<code>tenant</code>属性被声明为弱引用：</p>

<p>```
class Person {</p>

<pre><code>let name: String
init(name: String) { self.name = name }
var apartment: Apartment?
deinit { println("\(name) is being deinitialized") }
</code></pre>

<p>}
class Apartment {</p>

<pre><code>let number: Int
init(number: Int) { self.number = number }
weak var tenant: Person?
deinit { println("Apartment #\(number) is being deinitialized") }
</code></pre>

<p>}
<code>``
然后跟之前一样，建立两个变量（</code>john<code>和</code>number73`）之间的强引用，并关联两个实例：</p>

<p>```
var john: Person?
var number73: Apartment?</p>

<p>john = Person(name: &ldquo;John Appleseed&rdquo;)
number73 = Apartment(number: 73)</p>

<p>john!.apartment = number73
number73!.tenant = john
```
现在的引用关系如下：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference01_2x.png" alt="" /></p>

<p>当<code>john</code>的强引用断开后，引用关系变成了这样子：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference02_2x.png" alt="" /></p>

<p>因为没有强引用指向<code>Person</code>实例，它的引用计数为0，所以该实例会被销毁。因此<code>number73</code>指向的<code>Apartment</code>实例的的引用计数会变为1，因为<code>Person</code>实例销毁后，其<code>apartment</code>属性对<code>Apartment</code>实例的强引用也会断开。此时如果再断开<code>number73</code>对<code>Apartment</code>实例的强引用：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/weakReference03_2x.png" alt="" /></p>

<p><code>Apartment</code>实例因为引用计数为0，会被销毁，到此为止强引用循环被打破。</p>

<h3>无主引用</h3>

<p>和弱引用类似，无主引用不会牢牢保持住引用的实例。和弱引用不同的是，无主引用是永远有值的（不能为<code>nil</code>）。因此，无主引用总是被定义为非可选类型（non-optional type）。你可以在声明属性或者变量时，在前面加上关键字<code>unowned</code>表示这是一个无主引用。</p>

<p>下面的例子定义了两个类，<code>Customer</code>和<code>CreditCard</code>，模拟了银行客户和客户的信用卡。一个客户可能有或者没有信用卡，但是一张信用卡总是关联着一个客户。所以<code>Customer</code>类的<code>card</code>属性可以为<code>nil</code>，但是<code>CreditCard</code>类的<code>customer</code>属性不能为<code>nil</code>，所以创建CreditCard实例的时候必须给<code>customer</code>属性赋值避免其为<code>nil</code>。将<code>customer</code>属性定义为无主引用，用以避免循环强引用：</p>

<p>```
class Customer {</p>

<pre><code>let name: String
var card: CreditCard?
init(name: String) {
    self.name = name
}
deinit { println("\(name) is being deinitialized") }
</code></pre>

<p>}
class CreditCard {</p>

<pre><code>let number: Int
unowned let customer: Customer
init(number: Int, customer: Customer) {
    self.number = number
    self.customer = customer
}
deinit { println("Card #\(number) is being deinitialized") }
</code></pre>

<p>}
var john: Customer?
john = Customer(name: &ldquo;John Appleseed&rdquo;)
john!.card = CreditCard(number: 1234_5678_9012_3456, customer: john!)
```
关联两个实例后，引用关系如下：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference01_2x.png" alt="" /></p>

<p>由于<code>customer</code>的无主引用，当你断开<code>john</code>变量持有的强引用时，再也没有指向<code>Customer</code>实例的强引用了：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/unownedReference02_2x.png" alt="" /></p>

<p>于是<code>Customer</code>实例被销毁，这样又导致没有强引用指向<code>CreditCard</code>实例，最后<code>CreditCard</code>实例也被销毁了，这样说明强引用循环被打破了。</p>

<h3>无主引用以及隐式解析可选属性</h3>

<p>下面的例子定义了两个类，<code>Country</code>和<code>City</code>，每个类将另外一个类的实例保存为属性。在这个模型中，每个国家必须有首都，而每一个城市必须属于一个国家。为了实现这种关系，<code>Country</code>类拥有一个<code>capitalCity</code>属性，而<code>City</code>类有一个<code>country</code>属性：</p>

<p>```
class Country {</p>

<pre><code>let name: String
let capitalCity: City!
init(name: String, capitalName: String) {
    self.name = name
    self.capitalCity = City(name: capitalName, country: self)
}
</code></pre>

<p>}
class City {</p>

<pre><code>let name: String
unowned let country: Country
init(name: String, country: Country) {
    self.name = name
    self.country = country
}
</code></pre>

<p>}
<code>``
在这种场景中，两个属性都必须有值，并且初始化完成后不能为</code>nil`。在这种场景中，需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>

<p>隐式解析可选(<code>Implicitly Unwrapped Optionals</code>)被用于类的初始化方法中，避免循环引用，因为编译器会将其认为默认<code>nil</code>，不需赋值就可以完成类的初始化，在例子中一旦<code>name</code>属性被赋值后(但<code>capitalCity</code>还没被赋值时)<code>Country</code>类就已经初始化并且自身（<code>self</code>）可以被引用；这样就能实现一行代码建立<code>Country</code>和<code>City</code>实例而不造成强引用循环。</p>

<p><code>
var country = Country(name: "Canada", capitalName: "Ottawa")
println("\(country.name)'s capital city is called \(country.capitalCity.name)")
// prints "Canada's capital city is called Ottawa"
</code>
使用隐式解析可选值的意义在于满足了两个类构造函数的需求。<code>capitalCity</code>属性在初始化完成后，能像非可选值一样使用和存取同时还避免了循环强引用。</p>

<h3>总结</h3>

<p><code>Person</code>和<code>Apartment</code>的例子展示了两个属性的值都允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合用弱引用来解决。</p>

<p><code>Customer</code>和<code>CreditCard</code>的例子展示了一个属性的值允许为<code>nil</code>，而另一个属性的值不允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景最适合通过无主引用来解决。</p>

<p><code>Country</code>和<code>City</code>的例子展示了两个属性的值都不允许为<code>nil</code>，并会潜在的产生循环强引用。这种场景需要一个类使用无主属性，而另外一个类使用隐式解析可选属性。</p>

<h2>闭包引起的强引用循环</h2>

<p>强引用循环还会发生在当你将一个闭包赋值给类实例的某个属性，并且这个闭包体中又使用了实例。这个闭包体中可能访问了实例的某个属性，例如<code>self.someProperty</code>，或者闭包中调用了实例的某个方法，例如<code>self.someMethod</code>。这两种情况都导致了闭包 “捕获" <code>self</code>，因为闭包也是引用类型，从而产生了强引用循环。在Swift中闭包如果想使用外部的实例，不必像OC中的Block那样在外部实例前加<code>__block</code>加以修饰，而是可以直接用“值捕获”的方式捕获到闭包外面的实例。Swift 会决定捕获引用还是拷贝值，并负责管理内存释放。</p>

<p>Swift 有如下要求：只要在闭包内使用self的成员，就要用self.someProperty或者self.someMethod（而不只是someProperty或someMethod）。这提醒你可能会不小心就捕获了self。</p>

<p>在OC中也存在<code>Block</code>中引用<code>self</code>或<code>self</code>的属性而导致<code>self</code>被<code>Block</code> retain，进而产生引用循环，这也是为什么代理属性都被声明为<code>weak</code>的原因。</p>

<p>下面的例子为你展示了当一个闭包引用了self后是如何产生一个循环强引用的。例子中定义了一个叫HTMLElement的类，用一种简单的模型表示 HTML 中的一个单独的元素：</p>

<p>```
class HTMLElement {</p>

<pre><code>let name: String
let text: String?

@lazy var asHTML: () -&gt; String = {
    if let text = self.text {
        return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
    } else {
        return "&lt;\(self.name) /&gt;"
    }
}

init(name: String, text: String? = nil) {
    self.name = name
    self.text = text
}

deinit {
    println("\(name) is being deinitialized")
}
</code></pre>

<p>}
```</p>

<p><code>HTMLElement</code>定义了一个<code>lazy</code>属性<code>asHTML</code>。这个属性引用了一个闭包，将<code>name</code>和<code>text</code>组合成 HTML 字符串片段。该属性是<code>() -&gt; String</code>类型，或者可以理解为“一个没有参数，返回<code>String</code>的函数”。因为该闭包无参数并可推断出返回值类型，所以采取了简写，省略了关键字<code>in</code>和闭包的参数和返回值类型声明。</p>

<p><code>asHTML</code>声明为<code>lazy</code>属性，因为只有当元素确实需要处理为HTML输出的字符串时，才需要使用<code>asHTML</code>。也就是说，在默认的闭包中可以使用<code>self</code>，因为只有当初始化完成以及<code>self</code>确实存在后，才能访问<code>lazy</code>属性。</p>

<p>下面的代码展示了如何用HTMLElement类创建实例并打印消息</p>

<p><code>
var paragraph: HTMLElement? = HTMLElement(name: "p", text: "hello, world")
println(paragraph!.asHTML())
// prints"hello, world"
</code></p>

<p>不幸的是，上面写的HTMLElement类产生了类实例和asHTML默认值的闭包之间的循环强引用。循环强引用如下图所示：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle01_2x.png" alt="" /></p>

<p>虽然闭包多次使用了<code>self</code>，它只捕获<code>HTMLElement</code>实例的一个强引用。如果设置<code>paragraph</code>变量为<code>nil</code>，打破它持有的<code>HTMLElement</code>实例的强引用，<code>HTMLElement</code>实例和它的闭包都不会被销毁，也是因为强引用循环</p>

<h2>解决闭包引起的循环强引用</h2>

<p>Swift 提供了一种优雅的方法来解决这个问题，称之为闭包占用列表（closuer capture list）</p>

<h3>定义捕获列表</h3>

<p>捕获列表放置在闭包参数列表和返回类型之前，列表中每项都是由weak或unowned关键字和实例的引用（如self或someInstance）成对组成。每项都通过逗号分开写在方括号中。</p>

<p>```
@lazy var someClosure: (Int, String) &ndash;> String = {</p>

<pre><code>[unowned self] (index: Int, stringToProcess: String) -&gt; String in
// closure body goes here
</code></pre>

<p>}
<code>``
如果闭包没有指定参数列表或者返回类型，则可以通过上下文推断，那么可以捕获列表放在闭包开始的地方，跟着是关键字</code>in`：</p>

<p>```
@lazy var someClosure: () &ndash;> String = {</p>

<pre><code>[unowned self] in
// closure body goes here
</code></pre>

<p>}
```</p>

<h3>捕获列表中的弱引用和无主引用</h3>

<p>当捕获引用有时可能会是nil时，将闭包内的捕获定义为弱引用。<br/>
当闭包和捕获的实例总是互相引用时并且总是同时销毁时，将闭包内的捕获定义为无主引用。<br/>
如果捕获的引用绝对不会置为nil，应该用无主引用，而不是弱引用。</p>

<p>前面的<code>HTMLElement</code>例子中，无主引用是正确的解决循环强引用的方法。这样编写<code>HTMLElement</code>类来避免循环强引用：</p>

<p>```
class HTMLElement {</p>

<pre><code>let name: String
let text: String?

@lazy var asHTML: () -&gt; String = {
    [unowned self] in
    if let text = self.text {
        return "&lt;\(self.name)&gt;\(text)&lt;/\(self.name)&gt;"
    } else {
        return "&lt;\(self.name) /&gt;"
    }
}

init(name: String, text: String? = nil) {
    self.name = name
    self.text = text
}

deinit {
    println("\(name) is being deinitialized")
}
</code></pre>

<p>}
```</p>

<p>上面的例子只是多了一个捕获列表并增加关键字<code>in</code>，使用捕获列表后引用关系如下图所示：</p>

<p><img src="https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/Art/closureReferenceCycle02_2x.png" alt="" /></p>

<p>这一次，闭包以无主引用的形式捕获<code>self</code>，并不会持有<code>HTMLElement</code>实例的强引用。如果将<code>paragraph</code>赋值为<code>nil</code>，<code>HTMLElement</code>实例将会被销毁，并能看到它的析构函数打印出的消息。</p>

<p><code>
paragraph = nil
// prints "p is being deinitialized"
</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Swift重载和自定义运算符]]></title>
    <link href="http://yulingtianxia.com/blog/2014/06/16/swiftzhong-zai-yun-suan-fu/"/>
    <updated>2014-06-16T20:45:20+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/06/16/swiftzhong-zai-yun-suan-fu</id>
    <content type="html"><![CDATA[<p>最近一直边忙毕设边学Swift，终于看完了官方的教程（语言参考暂不打算看），在iBooks上做了一些笔记（看英文伤不起），感觉Swift是一门大杂烩类型的语言，我会记录一些我自认为以前遇到较少或者需要重点记忆的语法特性，在此作为分享，这次是运算符的重载，几乎每门语言都有，只是语法不一样罢了。</p>

<!--more-->


<h2>运算符重载</h2>

<p>在Swift的官方文档中运算符重载叫做运算符函数（Operator Functions），顾名思义就是对已经有的运算符覆盖定义自己的函数实现。三元运算符（a？b：c）和默认的默认的赋值符(=)是不可重载的。</p>

<h3>中缀运算符的重载</h3>

<p>在<code>func</code>关键字前使用属性<code>@infix</code>来重载中缀运算符，函数名为想要重载的中缀运算符：</p>

<p>``` js
struct Vector2D {</p>

<pre><code>var x = 0.0, y = 0.0
</code></pre>

<p>}
@infix func + (left: Vector2D, right: Vector2D) &ndash;> Vector2D {</p>

<pre><code>return Vector2D(x: left.x + right.x, y: left.y + right.y)
</code></pre>

<p>}
<code>``
上面的代码是对结构体</code>Vector2D<code>之间双目运算符</code>+<code>的重载，下面可以直接使用</code>+<code>对</code>Vector2D`进行操作了：</p>

<p><code>
let vector = Vector2D(x: 3.0, y: 1.0)
let anotherVector = Vector2D(x: 2.0, y: 4.0)
let combinedVector = vector + anotherVector
// combinedVector 是一个新的Vector2D, 值为 (5.0, 5.0)
</code></p>

<p>除了对双目运算符的重载，还有对比较运算符的重载</p>

<p>```
@infix func == (left: Vector2D, right: Vector2D) &ndash;> Bool {</p>

<pre><code>return (left.x == right.x) &amp;&amp; (left.y == right.y)
</code></pre>

<p>}</p>

<p>@infix func != (left: Vector2D, right: Vector2D) &ndash;> Bool {</p>

<pre><code>return !(left == right)
</code></pre>

<p>}
```</p>

<p>现在我们可以使用这两个运算符来判断两个Vector2D对象是否相等</p>

<p>```
let twoThree = Vector2D(x: 2.0, y: 3.0)
let anotherTwoThree = Vector2D(x: 2.0, y: 3.0)
if twoThree == anotherTwoThree {</p>

<pre><code>println("这两个向量是相等的.")
</code></pre>

<p>}
// prints &ldquo;这两个向量是相等的.&rdquo;
```</p>

<h3>前缀和后缀运算符的重载</h3>

<p>前缀和后缀运算符重载跟中缀运算符重载类似，只是将<code>func</code>关键字前的属性替换成<code>@prefix</code>和<code>@postfix</code>，比如：</p>

<p>```
@prefix func &ndash; (vector: Vector2D) &ndash;> Vector2D {</p>

<pre><code>return Vector2D(x: -vector.x, y: -vector.y)
</code></pre>

<p>}
```</p>

<p>这段代码为<code>Vector2D</code>类型提供了单目减运算，并且是前缀，也就是取负操作。</p>

<p><code>
let positive = Vector2D(x: 3.0, y: 4.0)
let negative = -positive
// negative 为 (-3.0, -4.0)
let alsoPositive = -negative
// alsoPositive 为 (3.0, 4.0)
</code></p>

<h3>组合赋值运算符的重载</h3>

<p>组合赋值是其他运算符和赋值运算符一起执行的运算。如<code>+=</code>把加运算和赋值运算组合成一个操作。实现一个组合赋值符号需要使用<code>@assignment</code>属性，还需要把运算符的左参数设置成<code>inout</code>，因为这个参数会在运算符函数内直接修改它的值。</p>

<p>```
@assignment func += (inout left: Vector2D, right: Vector2D) {</p>

<pre><code>left = left + right
</code></pre>

<p>}
```</p>

<p>因为加法运算在之前定义过了，这里无需重新定义。所以，加赋运算符函数使用已经存在的高级加法运算符函数来执行左值加右值的运算。</p>

<p><code>
var original = Vector2D(x: 1.0, y: 2.0)
let vectorToAdd = Vector2D(x: 3.0, y: 4.0)
original += vectorToAdd
// original 现在为 (4.0, 6.0)
</code>
你可以将<code>@assignment</code>属性和 <code>@prefix</code> 或 <code>@postfix</code> 属性起来组合，实现一个<code>Vector2D</code>的前缀运算符。</p>

<p>```
@prefix @assignment func ++ (inout vector: Vector2D) &ndash;> Vector2D {</p>

<pre><code>vector += Vector2D(x: 1.0, y: 1.0)
return vector
</code></pre>

<p>}
<code>``
这个前缀使用了已经定义好的高级加赋运算，将自己加上一个值为</code> (1.0，1.0) `的对象然后赋给自己，然后再将自己返回。</p>

<p><code>
var toIncrement = Vector2D(x: 3.0, y: 4.0)
let afterIncrement = ++toIncrement
// toIncrement 现在是 (4.0, 5.0)
// afterIncrement 现在也是 (4.0, 5.0)
</code></p>

<h2>自定义运算符</h2>

<p>标准的运算符不够玩，那你可以声明一些个性的运算符，但个性的运算符只能使用这些字符 <code>/ = - + * % &lt; &gt;！&amp; | ^。~</code>  <br/>
新的运算符声明需在全局域使用<code>operator</code>关键字声明，可以声明为前缀，中缀或后缀的。</p>

<p><code>
operator prefix +++ {}
</code>
这段代码定义了一个新的前缀运算符叫<code>+++</code>，此前Swift并不存在这个运算符。此处为了演示，我们让<code>+++</code>对<code>Vector2D</code>对象的操作定义为“双自增”（prefix doubling incrementer） 这样一个独有的操作，这个操作使用了之前定义的加赋运算（<code>+=</code>）实现了自已加上自己然后返回的运算。</p>

<p>```
@prefix @assignment func +++ (inout vector: Vector2D) &ndash;> Vector2D {</p>

<pre><code>vector += vector
return vector
</code></pre>

<p>}
```</p>

<p><code>+++</code>运算的实现是把自己再加上自己</p>

<p><code>
var toBeDoubled = Vector2D(x: 1.0, y: 4.0)
let afterDoubling = +++toBeDoubled
// toBeDoubled 现在是 (2.0, 8.0)
// afterDoubling 现在也是 (2.0, 8.0)
</code>
此外还可以定义运算符的结合性(associativity)和优先级(precedence)，结合性(associativity)的值可取的值有left，right和none。左结合运算符跟其他优先级相同的左结合运算符写在一起时，会跟左边的操作数结合。同理，右结合运算符会跟右边的操作数结合。而非结合运算符不能跟其他相同优先级的运算符写在一起。<br/>
结合性(associativity)的值默认为none，优先级(precedence)默认为100。</p>

<p>```
operator infix +&ndash; { associativity left precedence 140 }
func +&ndash; (left: Vector2D, right: Vector2D) &ndash;> Vector2D {</p>

<pre><code>return Vector2D(x: left.x + right.x, y: left.y - right.y)
</code></pre>

<p>}
let firstVector = Vector2D(x: 1.0, y: 2.0)
let secondVector = Vector2D(x: 3.0, y: 4.0)
let plusMinusVector = firstVector +&ndash; secondVector
// plusMinusVector 此时的值为 (4.0, -2.0)
```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[XCode,Swift和Objective-C Cheat Sheet]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/06/xcodehe-objective-c-cheat-sheet/"/>
    <updated>2014-04-06T18:38:24+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/06/xcodehe-objective-c-cheat-sheet</id>
    <content type="html"><![CDATA[<p>关于XCode,Swift和OC的速查，方便记忆，以后会更新</p>

<!-- more-->


<p>XCode5 Cheat Sheet:(<a href="http://www.git-tower.com/blog/xcode-cheat-sheet/">作者</a>)</p>

<p><img src="http://byetz.img41.wal8.com/img41/425047_20140623222918/140353412989.jpg" alt="" /></p>

<p><img src="http://byetz.img41.wal8.com/img41/425047_20140623222918/140353414151.jpg" alt="" /></p>

<p>Objective-C Cheat Sheet and Quick Reference Updated for Xcode 5:(摘自<a href="http://www.raywenderlich.com/54099/objective-c-cheat-sheet-and-quick-reference-updated-for-xcode-5">raywenderlich</a>)</p>

<p><img src="http://byetz.img41.wal8.com/img41/425047_20140623222918/140353409554.jpg" alt="" /></p>

<p>Swift Cheat Sheet and Quick Reference:(摘自<a href="http://www.raywenderlich.com/73967/swift-cheat-sheet-and-quick-reference">raywenderlich</a>)</p>

<p><img src="http://byetz.img41.wal8.com/img41/425047_20140623222918/140353410275.png" alt="" /></p>
]]></content>
  </entry>
  
</feed>
