<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: SpriteKit | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/spritekit/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-09-23T20:38:24+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[创建SpriteKit游戏的最佳范例]]></title>
    <link href="http://yulingtianxia.com/blog/2014/08/19/best-practices-for-building-spritekit-games/"/>
    <updated>2014-08-19T22:16:13+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/08/19/best-practices-for-building-spritekit-games</id>
    <content type="html"><![CDATA[<p>本文会从拓展性、游戏构造和性能三个方面分别讲述建立SpriteKit游戏时的一些实践经验和范例。建议先阅读<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>有助于理解本文内容。</p>

<!--more-->


<h2>拓展性最佳范例</h2>

<h3>硬编码问题</h3>

<p>在以前，程序员在场景中做了所有的事情，在代码中引用美工，游戏第一关采用硬编码，第二关第三关就是一顿复制粘贴修修补补。修改美工图片也意味着要改代码，每次预览修改后的效果都要Build和Run，而设计游戏的人甚至要会编程，因为修改设计（比如一些游戏参数）也要改代码。如果项目接着编写下去，这导致重复性的构建代码，将数据硬编码到代码中也是种低效率做法，编码与美工和设计人员之间合作困难。</p>

<p>解决方案：</p>

<ul>
<li>将游戏内容与游戏逻辑分离</li>
<li>将场景构造与素材分离</li>
<li>将数据与代码分离</li>
<li>在Xcode中所见即所得</li>
</ul>


<p>具体实现：</p>

<ul>
<li>游戏逻辑写在MyScene.m文件中（使用SpriteKit的模板）</li>
<li>游戏场景结构创建在MyScene.sks文件中</li>
<li>场景用到的素材使用单独的sks文件分开管理</li>
<li>数据要存储在plist文件中（XML格式）</li>
</ul>


<p>Xcode6为我们提供的工具：</p>

<ul>
<li>SpriteKit模版，支持OC和Swift</li>
<li>SpriteKit编辑器：可视化编辑sks文件，即时预览效果，实时物理模拟</li>
<li>plist数据编辑器：XML语言被可视化成字典来编辑，简单高效</li>
</ul>


<p>在MyScene.m文件中使用下面的模板来加载MyScene.sks中设计好的场景结构，然后你就可以接着写游戏的逻辑了：</p>

<p><code>js
let path = NSBundle.mainBundle().pathForResource(file, ofType: "sks")       
var sceneData = NSData.dataWithContentsOfFile(path, options: .DataReadingMappedIfSafe, error: nil)
var archiver = NSKeyedUnarchiver(forReadingWithData: sceneData)
archiver.setClass(self.classForKeyedUnarchiver(), forClassName: "SKScene")
let scene = archiver.decodeObjectForKey(NSKeyedArchiveRootObjectKey) as GameScene
archiver.finishDecoding()
</code></p>

<h2>游戏构造最佳范例</h2>

<p>程序员总是想让游戏尽可能早地跑起来。为了完成这个目标，我们要懂得与美工和设计合作，毕竟程序员不能独自完成所有事情，下面列举下快速达成目标的步骤：</p>

<ol>
<li>先把一般性的工作做完，这只是逻辑布局上的编程，不必等美工提供素材。标记好英雄、敌人等人物出现的位置，设计好背景、平台等。</li>
<li>用只有颜色没有贴图的<code>SKSpriteNode</code>来充当英雄和敌人，只要能区分开就好。现在可以设定父子层级关系，比如设定粒子发射位置，连接组件和关节（胳膊腿儿啥的）</li>
<li>设定物理层面的相互作用，比如各种物理体的类别，碰撞掩码，是否受物理世界的影响等。在Xcode中模拟物理场景，保证你做的这些从一开始就万无一失。</li>
<li>初始化场景逻辑和游戏逻辑，把之前在场景上布置好的物体与代码中的游戏中的物体用之前设定好的名字（英雄or敌人）联系起来。使用SpriteKit模板加载好游戏场景后，<code>SKScene</code>的<code>initWithCoder</code>会被调用，我们可以在这里加载声音和AI数据等不会变化的数据。当<code>SKView.presentScene:</code>被调用时，<code>SKScene</code>的<code>didMoveToView:</code>会被调用，在这里你要缓存可见的元素，比如敌人，你可以通过名字将它们从场景的子节点中遍历出来。</li>
<li>完成游戏：将美工给你的素材替代以前的纯色，增加关卡和效果（Shader，滤镜等），迭代测试。</li>
</ol>


<p>PS：两种搜索节点元素的方法：
<code>
– childNodeWithName:
– enumerateChildNodesWithName:usingBlock:
</code></p>

<blockquote><p>关于搜索文本的语法补充：<br/>
通过name查找：</p>

<ul>
<li>“hero”是查找叫做“hero”的子节点，不迭代</li>
<li>“//hero”是查找场景图中所有叫做“hero”的子节点，迭代</li>
</ul>


<p>通过class查找：</p>

<ul>
<li>“//SKEmitterNode”会在场景图中迭代查找所有粒子节点</li>
</ul>


<p>通过通配符查找：</p>

<ul>
<li>“//he*”查找所有以“he”开头的子节点</li>
</ul>
</blockquote>

<h2>性能最佳范例</h2>

<p>我们要尽可能维持游戏每秒60帧频率的刷新，就需要从性能上优化。</p>

<h3>Drawing performance</h3>

<p>影响绘图性能的两个主要因素：</p>

<ul>
<li>绘制顺序：默认的绘制顺序是按照代码中构造节点树的顺序绘制的，先绘制父节点，然后依次绘制子节点，并向下迭代。你可以将<code>SKView</code>的<code>ignoresSiblingOrder</code>属性设为YES，然后利用Z轴的层级深浅关系来定制绘制次序。</li>
<li>共享：使用纹理图集（texture atlases），共享法线贴图，从文件加载Shader而不是字符串，将混合模式放在Z轴同一层级。</li>
</ul>


<p>下面的工具能帮你评估图形性能：</p>

<p><code>SKView</code>上的HUD flags：</p>

<p><code>
showsFPS
showsDrawCount
showsNodeCount
showsQuadCount
</code></p>

<p>profile：检测硬件使用情况。</p>

<h3>Actions and constraints</h3>

<p>使用<code>SKAction</code>类实现SpriteKit中的动画是很高效的。用一行代码就能实现诸如平移、旋转、缩放、渐入渐出等动画效果。你可以将多个动画组成一个序列（sequence）来依次执行，也可组成一个group来同时执行，sequence和group之间也可以互相嵌套。<code>SKAction</code>有很多方法，可以查看它的API文档。</p>

<p>如果你给Action使用Key命名的话，你还可以通过Key来动态删除和重写这个Action。</p>

<p><code>SKConstraints</code>类能在节点与节点或固定点之间建立约束。详见我的另一篇文章<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>中New Physics->Constraints小节。</p>

<h3>Physics</h3>

<p>模拟物理世界需要很多的硬件计算，当务之急就是减少能耗。</p>

<p>静态物体耗能较小，即使他们外形复杂。所以尽可能的将物理体的<code>dynamic</code>属性设为NO</p>

<p>物理体的外形复杂程度也决定着能耗。圆形是最简单的，耗能最少，再往上依次是矩形、多边形、复合图形、alpha像素图形：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140844930564.png" alt="" /></p>

<p>所以你需要权衡利弊来设计你游戏中物理体的外形。上图的后两种外形是iOS8新加入的，你可以在<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>中的New Physics->Per-Pixel Physics和Improvements->Physics Updates这两个小节中学到有关它们的更多知识。</p>

<p>在设置碰撞掩码（mask）时，尽量将相同类别的物体归为一类，用尽可能少得类别来划分你游戏中的物体。这样能减少很多能耗。</p>

<p>尽可能使用iOS8新加入的<code>SKFieldNode</code>来模拟一些物理场景，而不是通过传统代码方式（自己向各种物体施加各种力）。有关<code>SKFieldNode</code>的知识可以查看<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>中New Physics->Physics Fields那节。</p>

<p>将<code>SKView</code>的<code>showsFields</code>属性设为YES可以将<code>SKFieldNode</code>的debug信息显示出来：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140845151467.png" alt="" />
<img src="http://yulingtianxia.qiniudn.com/140845150994.png" alt="" /></p>

<p>上面两个场景是我的一个SpriteKit游戏<a href="https://github.com/yulingtianxia/ColorAtom">ColorAtom</a>中的秘密模式和黑洞模式截图，欢迎Star和Follow。</p>

<h3>Shapes</h3>

<p><code>SKShapeNode</code>的耗能层级图如下：</p>

<p><img src="http://yulingtianxia.qiniudn.com/14084531435.png" alt="" /></p>

<p>上图中的分界线区分了低功耗和高功耗的Shape。绘制分段的linear strok所需的功耗也很少。</p>

<h3>Effects</h3>

<p><code>SKEffectNode</code>可以将它的子节点渲染的更加出彩，比如用CoreImage滤镜等合成出复杂的特效。但这也会对性能有很大影响，请谨慎使用。</p>

<p>Shader是一个不错的选择，它不需要离屏渲染，想用就用，节能环保。有关<code>SKShader</code>的知识可以查看<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>中Shader那节。</p>

<p><code>shouldRasterize</code>属性暗示是否缓存以备将来之需。如果你的画面会停留一段时间，可以考虑设置为YES。</p>

<p>我们还可以从<code>SKNode</code>中获取纹理（这不费吹灰之力），还可以对纹理进行滤镜加工：</p>

<p><code>
SKTexture *texture = [myView textureFromNode:node size:size];
SKTexture *texture = [myTexture textureByApplyingCIFiler:filer];
</code></p>

<h3>Lighting</h3>

<p>光照的功耗是跟像素数量成比例的，每个<code>SKSpriteNode</code>最多能被八个光源照射，你可以利用光照掩码来优化性能。</p>

<p>环境光照（ambient light）所需功耗是免费的，而法线贴图（Normal Maps）功耗很低。</p>

<p>阴影的功耗跟光源数量成正比，所以尽可能减少光源数量。</p>

<p>有关Lighting的更多知识可以查看<a href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/">SpriteKit在iOS8和OSX10.10中的新特性</a>中Lighting and Shadows那节。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpriteKit在iOS8和OSX10.10中的新特性]]></title>
    <link href="http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing/"/>
    <updated>2014-08-08T19:11:14+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/08/08/spritekitzai-ios8he-osx10-dot-10zhong-de-xin-te-xing</id>
    <content type="html"><![CDATA[<p>在iOS8和OSX10.10中SpriteKit迎来了重大升级。在物理表现方面增加了着色器，光照和阴影；在物理模拟方面增加了像素物理体、力场和宇宙动力学和约束等；在Xcode中集成了场景编辑器，你不需要写代码就能完成一些复杂的工作；此外它还集成了SceneKit以及其他的改进。</p>

<!--more-->


<h2>Shader</h2>

<p>有时候为了表现一些形变和模糊效果，比如透过热气和火焰看一些物体，或者是飞船被攻击而产生弯曲。SpriteKit新加入了<code>SKShader</code>类来帮助我们更简单的实现这个效果。它通过使用自定义的OpenGL ES碎片着色来完成绘制一些<code>SKNode</code>的自定义行为。现在支持以下几种类型的绘制：</p>

<ul>
<li><code>SKSpriteNode</code></li>
<li><code>SKShapeNode</code></li>
<li><code>SKEmitterNode</code></li>
<li><code>SKEffectNode</code></li>
<li><code>SKScene</code></li>
</ul>


<p>放一张官方演示的效果图：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140738700571.png" alt="" /></p>

<p><code>SKShader</code>内建了一些<code>uniforms</code>，用<code>SKUniform</code>来描述，当你创建一个<code>SKShader</code>时，需要通过一个<code>fsh</code>文件或者一个字符串代码来创建，也可选择性的传入<code>uniforms</code>来定义游戏中一些额外的参数。下面是创建Shader方法的集合：</p>

<p>（下面的只是伪代码，不是OC也不是Swift语法，只是为了更简洁的标记方法名，后面类似情形都会标记为“伪代码”）</p>

<p><code>
+ shaderWithFileNamed:
+ shaderWithSource:uniforms:
+ shaderWithSource:
+ shader
- initWithSource:uniforms:
- initWithSource:
</code></p>

<p>这些方法很相似，都是传入<code>source</code>或<code>source</code>与<code>uniforms</code>来创建shader。官方建议我们用<code>fsh</code>文件作为<code>source</code>而不是字符串代码；并且避免更改<code>source</code>或添加删除<code>uniforms</code>（修改<code>uniforms</code>是可以的），因为这样会导致后台花时间重新编译shader；尽量在加载时初始化shader。这些注意事项都可以总结为尽量使用内建的<code>uniforms</code>和共享shader对象。</p>

<p>我们可以将创建好的<code>SKShader</code>对象赋值给支持Shader渲染对象的<code>shader</code>属性。</p>

<p>下面列举一下Shader中的预定义符号：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140738949518.png" alt="" /></p>

<h2>Lighting and Shadows</h2>

<p>灯光和阴影效果可以给游戏增加真实感，SpriteKit这次增加了<code>SKLightNode</code>来作为光源节点。我们可以定义光源的颜色，阴影和衰弱程度。</p>

<p><code>SKLightNode</code>继承于<code>SKNode</code>，也就是说你可以把它加在其他<code>SKNode</code>上，并能够动起来，它是一个会发光的<code>SKNode</code>，cool！NOTE：它的光照以及阴影效果只对<code>SKSpriteNode</code>起作用。</p>

<p>下面我们看看<code>SKLightNode</code>的一些属性：</p>

<ul>
<li><strong><code>enabled</code></strong> 光源的开关</li>
<li><strong><code>ambientColor</code></strong> 环境色，默认是黑色，也就是没有环境色。它无视自身的alpha以及<code>SKLightNode</code>的<code>falloff</code>属性和<code>SKSpriteNode</code>的<code>normalTexture</code>属性，分分钟照亮全场。</li>
<li><strong><code>lightColor</code></strong> 顾名思义就是光的颜色，默认是白色。</li>
<li><strong><code>shadowColor</code></strong> 被精灵物体遮挡产生的阴影颜色。</li>
<li><strong><code>falloff</code></strong> 光源强度的衰减比率</li>
<li><strong><code>categoryBitMask</code></strong> 光的种类，32位整型数。<code>SKSpriteNode</code>的<code>lightingBitMask</code>、<code>shadowedBitMask</code>和<code>shadowCastBitMask</code>存储着光的种类，分别意味着：被何种光照亮、被何种光产生的阴影覆盖和遮挡何种光线并产生阴影。</li>
</ul>


<p>为了在<code>SKSpriteNode</code>上实现更加逼真的光照效果（如阴影和反射光），<code>SKSpriteNode</code>新增了<code>normalTexture</code>属性来储存原帖图的法线贴图（Normal Map）：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140739494085.png" alt="" /></p>

<p>上图中左侧的是原贴图，加上中间的法线贴图就合成出最右侧带有质感的光照纹理。当然提供这样一张发现纹理图片会增加开发者的工作量，苹果还提供了另一种更加简单的方案-“automatic normal map”：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140739540301.png" alt="" /></p>

<p>SpriteKit能够根据给出的纹理图片，用一系列算法分析原贴图，然后生成一个最佳的法线贴图，又是苹果的黑魔法！</p>

<p>毕竟众口难调，所以SpriteKit让你也可以在生成法线贴图的时候给出平滑度(smoothness)和对比度(contrast)来调节你想要的效果：（伪代码）</p>

<p><code>
- textureByGeneratingNormalMapWithSmoothness:contrast:
</code></p>

<p>PS：法线贴图将具有高细节的模型通过映射烘焙出法线贴图，贴在低端模型的法线贴图通道上，使之拥有法线贴图的渲染效果。可以大大降低渲染时需要的面数和计算内容，从而达到优化动画渲染和游戏渲染的效果。</p>

<p>在一个场景中可以添加多个光源，程序会运行的很快；但是如果用两个或以上的光源照亮同一个精灵，在某些iOS设备上可能保证不了60帧的刷新频率。</p>

<h2>New Physics</h2>

<h3>Per-Pixel Physics</h3>

<p>在定义一些复杂轮廓的物理体时，我们经常用简单图形代替，否则就用<code>CGPath</code>一点点描绘多边形或者把多个物理体组合在一起（这也是新加入的API，后面会提到），比如下面这把斧头，大多数程序员直接用矩形当做它的物理体：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140740041011.png" alt="" /></p>

<p>而Per-Pixel Physics根据纹理图片的alpha通道遮罩来生成一个粗略的形状，然后再用粗略的形状生成精确的形状，它让以前复杂的<code>CGPath</code>创建工作转变成一行代码：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140740040721.png" alt="" /></p>

<p>毕竟众口难调，所以SpriteKit给出了一个可以自由调节alpha阈值的物理体生成方法，所有alpha值大于<code>alphaThreshold</code>的像素点都将被认为是不透明的，并纳入物理体范围内：（伪代码）</p>

<p><code>
+ bodyWithTexture:alphaThreshold:size:
</code></p>

<p>因为SpriteKit是逐个像素计算才得出精确的物理体轮廓，所以我们应该尽量给出合适大小的图片，不要将分辨率过高的图片用在很小的<code>SKSpriteNode</code>上。</p>

<h3>Constrains</h3>

<p>试想如果你要做一款塔防游戏，你需要让你的大炮一直瞄准某个怪物，大炮会随着怪物的行走来转动炮台。我们需要不停地根据怪物和大炮的位置来计算需要旋转的角度，甚至当怪物跑的快的时候还要考虑怪物的速度来调整大炮旋转的速度，这是一个很麻烦的事情。现在SpriteKit帮你把这些都做好了，你只需要建立一个<code>SKConstrains</code>对象，并约束大炮的角度跟怪物一致就行。</p>

<p>约束的计算工作发生在模拟物理之后，SpriteKit提供了一个回调函数<code>didApplyConstraints</code>，我们可以在约束完成后在里面做一些善后工作：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140740456021.png" alt="" /></p>

<p>在SpriteKit中我们可以向SKNode添加三种约束：（工厂方法的伪代码）</p>

<ul>
<li>位置约束：</li>
</ul>


<p><code>
//约束节点的X坐标范围
+ positionX:
//约束节点的Y坐标范围
+ positionY:
//约束节点的X和Y坐标范围
+ positionX:Y:
</code></p>

<ul>
<li>方向约束：</li>
</ul>


<p><code>
//约束节点基于另一个SKNode旋转
+ orientToNode:offset:
//约束节点基于一个固定点旋转
+ orientToPoint:offset:
//约束节点基于另一个SKNode坐标系中的一个固定点旋转
+ orientToPoint:inNode:offset:
//约束节点的方向范围
+ zRotation:
</code></p>

<ul>
<li>距离约束：</li>
</ul>


<p><code>
//约束节点与另一节点保持一定距离
+ distance:toNode:
//约束节点与一个固定点保持一定距离
+ distance:toPoint:
//约束节点与另一个SKNode坐标系中的一个固定点保持一定距离
+ distance:toPoint:inNode:
</code></p>

<p>向<code>SKNode</code>添加约束很简单，只需要将一个<code>SKConstrains</code>数组赋值给<code>SKNode.constraints</code>属性即可。约束执行的顺序取决于它们在数组中的顺序。</p>

<h3>Inverse Kinematics</h3>

<p>反向运动学，没有机械工程学位或没写过动画引擎的人干脆不知道这是个啥。它其实是解决连接体运动的，比如现在有一个机器人的手臂，我们想让它动起来去用手抓某个东西。我们会想到每个关节转多少度才能准确让机器手抓到物体，计算的时候还应该考虑连接体的层级关系：肩膀连接上臂，上臂连接小臂，小臂连接手。哦天啊这真蛋疼，不过SpriteKit的反向动力学解决了这一点，我们只需要指定每个<code>SKNode</code>的活动约束还有需要抓取物体的位置，那么这一切只需要几行代码就能搞定。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140741648388.gif" alt="" /></p>

<p>机器人手臂转动约束是靠<code>SKReachConstraints</code>类来定义的，它只有一个初始化方法：（伪代码）</p>

<p><code>
- initWithLowerAngleLimit:upperAngleLimit:
</code></p>

<p>这个方法给<code>lowerAngleLimit</code>和<code>upperAngleLimit</code>属性赋值，约束了reach事件使其发生旋转角度的下限和上限。</p>

<p>当一个<code>SKReachConstraints</code>创建好后，将其赋值给<code>SKNode</code>的<code>reachConstraints</code>属性，然后用<code>SKPhysicsJoint</code>将这些<code>SKNode</code>连接起来。使用<code>SKAction</code>的一套工厂方法创建来让连接体reach到活动目标或固定点的动作：（伪代码）</p>

<p><code>
+ reachTo:rootNode:duration:
+ reachTo:rootNode:velocity:
+ reachToNode:rootNode:duration:
+ reachToNode:rootNode:velocity:
</code></p>

<p>让机器人的手部节点运行创建好的<code>SKAction</code>对象即可达到最初描述的动画效果。如果机器人的手触碰不到指定的位置或节点（gif中就是这样），<code>SKAction</code>会执行动画让其尽可能接近目的地。</p>

<p>PS：IK（Inverse Kinematics）也能在SceneKit上运行。</p>

<h3>Physics Fields</h3>

<p>在一个模拟宇宙空间的游戏中，星球对其他物体的引力是不可忽视的，这就涉及到物理场。SpriteKit为我们提供了一个专门描述物理场的类<code>SKFieldNode</code>，它继承于<code>SKNode</code>，也就是说它可以被添加到其他节点中。它能够描述多种场：电场、磁场、矢量重力场、辐射重力场、噪声场等十余种场。<code>SKFieldNode</code>的<code>strength</code>和<code>falloff</code>属性决定了场的强度和衰减比率。</p>

<p><code>SKFieldNode</code>还有一些属性决定了游戏中哪些物理体会被场影响：</p>

<ul>
<li><strong><code>region</code></strong> 描述了场的影响区域，类型是<code>SKRegion</code>。<code>SKRegion</code>可以是无限区域，矩形、圆形、<code>CGPath</code>多边形区域，还可以用两个<code>SKRegion</code>做逻辑运算得出新的<code>SKRegion</code>，比如交集，并集，差集，还可对一个<code>SKRegion</code>取反得到剩下的区域。</li>
<li><strong><code>minimumRadius</code></strong> 一些场对物体的影响程度跟距离有关，当物体与场的距离小于<code>minimumRadius</code>属性的值时，仍被当做<code>minimumRadius</code>的值进行处理计算。<code>minimumRadius</code>的默认值很小很小，但不是0</li>
<li><strong><code>categoryBitMask</code></strong> 场的类别。当一个节点进入了场的影响区域，会根据节点的物理体属性的<code>fieldBitMask</code>属性来判断此节点是否收到场的影响。此外<code>SKPhysicsBody</code>的<code>charge</code>属性还会标记物理体所带的电荷量，这在跟电磁有关的场中会影响到物理体的运动。默认为 0xFFFFFFFF</li>
<li><strong><code>enabled</code></strong> 场的“开关”</li>
<li><strong><code>exclusive</code></strong> 唯我独尊，这个场的地盘内，别的场的影响被无视。别让两个唯我独尊的场影响区域重叠，那样会出乱子的。默认为<code>NO</code>。</li>
</ul>


<p>我用SpriteKit的力场中的噪声场和辐射重力场做了一个小游戏<a href="https://github.com/yulingtianxia/ColorAtom">ColorAtom</a>，有兴趣的可以去看看。应用了很多粒子系统和碰撞检测知识，把SpriteKit之前的内容能加的都加进去了，欢迎指正。</p>

<h2>Integration with SceneKit</h2>

<p>在SpriteKit这样的2D游戏引擎中也可以引入3D的内容，可以将SceneKit中的3D物体当做SpriteKit中的<code>SKNode</code>来操作，为了达到这一目的SpriteKit这次增加了<code>SK3DNode</code>类作为3D物体到SpriteKit中的桥接。</p>

<p>通过<code>SK3DNode</code>的<code>scnScene</code>属性可以获取到<code>SCNScene</code>，因为<code>SK3DNode</code>把3D场景渲染成2D贴图，所以创建<code>SK3DNode</code>对象的时候需要传入一个渲染后贴图的尺寸<code>viewportSize</code>。<code>pointOfView</code>属性存储了游戏视角的位置，你可以尝试实现个上帝视角。</p>

<p>由于我也不太了解“新”出的SceneKit，所以这部分不过多介绍了。</p>

<h2>Tools</h2>

<p>Xcode6增加了SpriteKit编辑器，一行代码都不用写就能创建出个游戏场景。这样你就将游戏内容从游戏逻辑冲分离出来。我们只需要将控件拖拽到游戏场景你想要的位置上，而不必每次调整一个飞船的位置，编译运行看看结果，然后再改代码微调位置再次编译运行。。。</p>

<p>SpriteKit编辑器不仅有编辑功能，也可用来debug。你可以再运行过程中将当前状态存储在一个sks文件中。</p>

<p>SpriteKit编辑器强大到你可以直接拖拽出一个SKSpriteNode并定义它的物理体，甚至使用Per-Pixel Physics。还可以编辑光照和阴影，编辑Shader并调整Uniforms，建立一个Inverse Kinematics并预览其效果，强大极了。</p>

<p>其实说白了SpriteKit编辑器就像IB一样可以可视化编辑属性，并课即时预览效果，整个过程不需一行代码。</p>

<p>Xcode能编辑fsh文件，与SpriteKit场景编辑器对照编辑，并做语法检查和编译。</p>

<h2>Improvements</h2>

<h3>SKScene</h3>

<p>SpriteKit每一帧场景的执行过程：</p>

<p><img src="http://yulingtianxia.qiniudn.com/update_loop_2x.png" alt="" /></p>

<p>除了之前提到新加的Constrains，SpriteKit这次还加入了一个回调函数<code>didFinishUpdate</code>。这绝对是SpriteKit将每帧所有东西打包好交给GPU渲染之前调用的最后一个函数。</p>

<h3>SKTexture</h3>

<ul>
<li><code>SKMutableTexture</code>是<code>SKTexture</code>新加的子类，它的内容可以通过<code>
modifyPixelDataWithBlock:</code>方法动态地修改。</li>
<li><code>SKTexture</code>现在可以生成“noise textures”，参见<code>textureVectorNoiseWithSmoothness:size:</code>和<code>
textureNoiseWithSmoothness:size:grayscale:</code><br/>
<img src="http://yulingtianxia.qiniudn.com/14074923846.png" alt="" /></li>
</ul>


<h3>SKShapeNode</h3>

<ul>
<li>增加了一些常见图形便捷的构造方法，比如矩形，圆形，椭圆和曲线。</li>
<li>可以用贴图和Shader来美化形状的描边和填充</li>
</ul>


<h3>Physics Updates</h3>

<ul>
<li><code>SKPhysicsBody</code>新加了<code>pinned</code>属性来标志此物理体对应的节点是否被钉在它的父节点上。如果父节点也有物理体，那么这两个物理体被认为被一个pin连接。如果将<code>allowsRotation</code>设为NO并且<code>pinned</code>设为YES，那么它相当于被焊在父节点上了，因为它不能转动了。</li>
<li><code>SKPhysicsBody</code>允许用<code>bodyWithBodies:</code>把多个物理体组合在一起来创建一个新的物理体，还记得前面提到过的斧头么：<br/>
  <img src="http://yulingtianxia.qiniudn.com/140749497219.png" alt="" /></li>
</ul>


<h3>SKTexture Atlas</h3>

<ul>
<li>同时支持SpriteKit和SceneKit</li>
<li>同时支持Retina和非Retina</li>
<li>同时支持16位和32位格式</li>
<li>支持4k x 4k 分辨率</li>
<li>支持运行时纹理图集的生成。比如从网上下载资源，SpriteKit会自动将透明的像素裁剪下去</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Swift和SpriteKit开发iOS游戏]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/17/a-ios-game-developed-by-swift-and-spritekit/"/>
    <updated>2014-07-17T12:54:13+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/17/a-ios-game-developed-by-swift-and-spritekit</id>
    <content type="html"><![CDATA[<p>之前用SpriteKit做过一个叫做<a href="https://github.com/yulingtianxia/ColorAtom">ColorAtom</a>的小游戏，用了访问者模式处理碰撞检测，还用了SpriteKit中的粒子系统、连接体、力场和动画等，可以说是一个学习SpriteKit比较不错的Demo，随着Swift的火热，我也用Swift和SpriteKit写了一个更为简单的小游戏<a href="https://github.com/yulingtianxia/Spiral">Spiral</a></p>

<!--more-->


<p>附上Spiral的动图：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140557437844.gif" alt="" /></p>

<p>游戏规则是：玩家是五角星小球，小球自动沿着陀螺线向外运动，当玩家点击屏幕时五角星小球会跳跃到内层螺旋，当五角星小球碰到红色旋风或滚动到螺旋线终点时游戏结束。玩家吃掉绿色旋风来得2分，吃到紫色三角得一分并获得保护罩，保护罩用来抵挡一次红色旋风。随着分数的增加游戏会升级，速度加快。游戏结束后可以截屏分享到社交网络，也可以选择重玩。</p>

<p>以下是本文内容：</p>

<ol>
<li>准备工作</li>
<li>绘制基本界面</li>
<li>Swift中用访问者模式处理碰撞</li>
<li>界面数据显示</li>
<li>按钮的绘制和截图分享</li>
</ol>


<h2>准备工作</h2>

<p>SpriteKit是苹果iOS7新推出的2D游戏引擎，这里不再过多介绍。我们新建工程的时候选取iOS中的Game，然后选择SpriteKit作为游戏引擎，语言选择Swift，Xcode6会为我们自动创建一个游戏场景<code>GameScene</code>，它包含<code>GameScene.swift</code>和<code>GameScene.sks</code>两个文件，<code>sks</code>文件可以让我们可视化拖拽游戏控件到场景上，然后再代码中加载<code>sks</code>文件来完成场景的初始化：</p>

<p>``` js</p>

<p>extension SKNode {</p>

<pre><code>class func unarchiveFromFile(file : NSString) -&gt; SKNode? {

    let path = NSBundle.mainBundle().pathForResource(file, ofType: "sks")

    var sceneData = NSData.dataWithContentsOfFile(path, options: .DataReadingMappedIfSafe, error: nil)
    var archiver = NSKeyedUnarchiver(forReadingWithData: sceneData)

    archiver.setClass(self.classForKeyedUnarchiver(), forClassName: "SKScene")
    let scene = archiver.decodeObjectForKey(NSKeyedArchiveRootObjectKey) as GameScene
    archiver.finishDecoding()
    return scene
}
</code></pre>

<p>}
```</p>

<p>但我比较喜欢纯写代码的方式来搭接面，因为<code>sks</code>文件作为游戏场景布局还不成熟，它是iOS8新加入的功能，以前在iOS7的时候<code>sks</code>文件只是作为粒子系统的可视化编辑文件。</p>

<p>所以我们修改<code>GameViewController.swift</code>文件的<code>viewDidLoad()</code>函数，像以前那样直接用代码加载游戏场景：</p>

<p>```
override func viewDidLoad() {</p>

<pre><code>    super.viewDidLoad()
    // Configure the view.
    let skView = self.view as SKView
    /* Sprite Kit applies additional optimizations to improve rendering performance */
    skView.ignoresSiblingOrder = true
    let scene = GameScene(size: skView.bounds.size)
    /* Set the scale mode to scale to fit the window */
    scene.scaleMode = .AspectFill
    skView.presentScene(scene)

}
</code></pre>

<p>```</p>

<p><code>GameScene</code>虽然是Xcode自动生成的，但是只是个空架子，我们需要把它生成的没用的代码删掉，比如初始化函数里内容为“HelloWorld”的<code>SKLabelNode</code>，还有<code>touchesBegan(touches: NSSet, withEvent event: UIEvent)</code>方法中绘制飞船的代码。把这些删光后，我们还需要有图片素材来绘制这四类精灵节点：<code>Player</code>（五角星），<code>Killer</code>（红色旋风），<code>Score</code>（绿色旋风）和<code>Shield</code>（紫色三角）。我是用Sketch来绘制这些矢量图形的，文件名为<code>spiral.sketch</code>，随同工程文件一同放到GitHub上了。当然你不需要手动导出图片到工程，直接下载工程文件就好了：</p>

<p><a href="https://github.com/yulingtianxia/Spiral">https://github.com/yulingtianxia/Spiral</a></p>

<h2>绘制基本界面</h2>

<p>这部分的工作主要是绘制出螺旋线作为地图，并让四种精灵节点动起来。</p>

<h3>螺旋线的绘制</h3>

<p><code>SKNode</code>有一个子类<code>SKShapeNode</code>，专门用于绘制线条的，我们新建一个<code>Map</code>类，继承<code>SKShapeNode</code>。下面我们需要生成一个<code>CGPath</code>来赋值给<code>Map</code>的<code>path</code>属性：</p>

<p>```
import UIKit
import SpriteKit
class Map: SKShapeNode {</p>

<pre><code>let spacing:CGFloat = 35
var points:[CGPoint] = []
convenience init(origin:CGPoint,layer:CGFloat){

    var x:CGFloat = origin.x
    var y:CGFloat = origin.y
    var path = CGPathCreateMutable()
    self.init()
    CGPathMoveToPoint(path, nil, x, y)
    points.append(CGPointMake(x, y))
    for index in 1..&lt;layer{
        y-=spacing*(2*index-1)
        CGPathAddLineToPoint(path, nil , x, y)
        points.append(CGPointMake(x, y))
        x-=spacing*(2*index-1)
        CGPathAddLineToPoint(path, nil , x, y)
        points.append(CGPointMake(x, y))
        y+=spacing*2*index
        CGPathAddLineToPoint(path, nil , x, y)
        points.append(CGPointMake(x, y))
        x+=spacing*2*index
        CGPathAddLineToPoint(path, nil , x, y)
        points.append(CGPointMake(x, y))
    }
    self.path = path
    self.glowWidth = 1
    self.antialiased = true
    CGPathGetCurrentPoint(path)
}
</code></pre>

<p>}
```</p>

<p>算法很简单，就是顺时针计算点坐标然后画线，这里把每一步的坐标都存入了<code>points</code>数组里，是为了以后计算其他数据时方便。因为这部分算法不难而且不是我们的重点，这里不过多介绍了。</p>

<h3>四种精灵的绘制</h3>

<p>因为四种精灵都是沿着<code>Map</code>类的路径来顺时针运动，它们的动画绘制是相似的，所以我建立了一个<code>Shape</code>类作为基类来绘制动画，它继承于<code>SKSpriteKit</code>类，并拥有半径（<code>radius</code>）、移动速度（<code>moveSpeed</code>）和线段计数（<code>lineNum</code>）这三个属性。其中<code>lineNum</code>是用于标记精灵在螺旋线第几条线段上的，这样比较方便计算动画的参数。</p>

<p>```
class Shape: SKSpriteNode {</p>

<pre><code>let radius:CGFloat = 10
var moveSpeed:CGFloat = 50
var lineNum = 0
init(name:String,imageName:String){
    super.init(texture: SKTexture(imageNamed: imageName),color:SKColor.clearColor(), size: CGSizeMake(radius*2, radius*2))
    self.physicsBody = SKPhysicsBody(circleOfRadius: radius)
    self.physicsBody.usesPreciseCollisionDetection = true
    self.physicsBody.collisionBitMask = 0
    self.physicsBody.contactTestBitMask = playerCategory|killerCategory|scoreCategory
    moveSpeed += CGFloat(Data.speedScale) * self.moveSpeed
    self.name = name
    self.physicsBody.angularDamping = 0

}
</code></pre>

<p>}
```</p>

<p>构造函数中设定了<code>Shape</code>类的一些物理参数，比如物理体的形状大小，碰撞检测掩码等。这里设定<code>usesPreciseCollisionDetection</code>为<code>true</code>是为了增加碰撞检测的精度，常用于体积小速度快的物体。<code>collisionBitMask</code>属性标记了需要模拟物理碰撞的类别，<code>contactTestBitMask</code>属性标记了需要检测到碰撞的类别。这里说的“类别”指的是物体的类别：</p>

<p><code>
let playerCategory:UInt32      =  0x1 &lt;&lt; 0;
let killerCategory:UInt32      =  0x1 &lt;&lt; 1;
let scoreCategory:UInt32       =  0x1 &lt;&lt; 2;
let shieldCategory:UInt32      =  0x1 &lt;&lt; 3;
</code>
这种用位运算来判断和存储物体类别的方式很常用，上面这段代码写在了<code>NodeCategories.swift</code>文件中。</p>

<p>为了描述<code>Shape</code>的速度随着游戏等级上升而增加，这里速度的计算公式含有<code>Data.speedScale</code>作为参数，关于<code>Data</code>“类”在后面会讲到。</p>

<p>为了让精灵动起来，需要知道动画的移动目的地是什么。虽然<code>SKAction</code>有<code>followPath(path: CGPath?, speed: CGFloat)</code>方法，但是在这里并不实用，因为<code>Player</code>会经常改变路线，所以我写了一个<code>runInMap(map:Map)</code>方法让精灵每次只移动到路径上的下一个节点（之前<code>Map</code>类存储的<code>points</code>属性用到了吧！嘿嘿）</p>

<p>```
func runInMap(map:Map){</p>

<pre><code>    let distance = calDistanceInMap(map)
    let duration = distance/moveSpeed
    let rotate = SKAction.rotateByAngle(distance/10, duration: duration)
    let move = SKAction.moveTo(map.points[lineNum+1], duration: duration)
    let group = SKAction.group([rotate,move])
    self.runAction(group, completion: {
        self.lineNum++
        if self.lineNum==map.points.count-1 {
            if self is Player{
                Data.gameOver = true
            }
            if self is Killer{
                self.removeFromParent()
            }
            if self is Score{
                self.removeFromParent()
            }
            if self is Shield{
                self.removeFromParent()
            }
        }
        else {
            self.runInMap(map)
        }
        })
}
</code></pre>

<p>```</p>

<p>上面的代码先是调用<code>calDistanceInMap(map:Map)-&gt;CGFloat</code>方法计算精灵距离下一个节点的距离（也就是需要移动的距离），然后计算精灵需要旋转动画时间和移动动画时间，最后将两个动画作为一个<code>group</code>来运行，在动画运行结束后判断精灵是否运行到了最后一个节点，也就是螺旋线的终点：如果到终点了则移除精灵，否则开始递归调用方法，来开始下一段动画（奔向下一个节点）。</p>

<p>计算距离的<code>calDistanceInMap(map:Map)-&gt;CGFloat</code>方法代码如下：</p>

<p>```
func calDistanceInMap(map:Map)&ndash;>CGFloat{</p>

<pre><code>    if self.lineNum==map.points.count {
        return 0
    }
    switch lineNum%4{
    case 0:
        return position.y-map.points[lineNum+1].y
    case 1:
        return position.x-map.points[lineNum+1].x
    case 2:
        return map.points[lineNum+1].y-position.y
    case 3:
        return map.points[lineNum+1].x-position.x
    default:
        return 0
    }
}
</code></pre>

<p>```</p>

<p>到此为止<code>Shape</code>类完成了，<code>Killer</code>、<code>Score</code>和<code>Shield</code>类比较简单，继承<code>Shape</code>类并设置自身纹理和类别即可：</p>

<p>```
class Killer: Shape {</p>

<pre><code>convenience init() {
    self.init(name:"Killer",imageName:"killer")
    self.physicsBody.categoryBitMask = killerCategory
}
</code></pre>

<p>}
class Score: Shape {</p>

<pre><code>convenience init() {
    self.init(name:"Score",imageName:"score")
    self.physicsBody.categoryBitMask = scoreCategory
}
</code></pre>

<p>}
class Shield: Shape {</p>

<pre><code>convenience init() {
    self.init(name:"Shield",imageName:"shield")
    self.physicsBody.categoryBitMask = shieldCategory
}
</code></pre>

<p>}
```</p>

<p>而<code>Player</code>因为有护盾状态并可以在螺旋线上跳跃到内层，所以稍微复杂些：</p>

<p>```
class Player: Shape {</p>

<pre><code>var jump = false
var shield:Bool = false {
willSet{
    if newValue{
        self.texture = SKTexture(imageNamed: "player0")
    }
    else{
        self.texture = SKTexture(imageNamed: "player")
    }
}
}
convenience init() {
    self.init(name:"Player",imageName:"player")
    self.physicsBody.categoryBitMask = playerCategory
    self.moveSpeed = 70
    self.lineNum = 3
}
func restart(map:Map) {
    self.alpha = 1
    self.removeAllActions()
    self.lineNum = 3
    self.moveSpeed = 70
    self.jump = false
    self.shield = false
    self.position = map.points[self.lineNum]
    self.runInMap(map)
}
</code></pre>

<p>}
```</p>

<p><code>Player</code>类的初始位置是螺旋线第四个节点，而且移动速度要略快于其他三种精灵，所以在这里设置为70（<code>Shape</code>默认速度50）。<code>jump</code>和<code>shield</code>是用来标记<code>Player</code>当前状态的属性，其中<code>shield</code>属性还定义了属性监察器，这是Swift中存储属性具有的响应机制，类似于<code>KVO</code>。在<code>shield</code>状态改变时也同时改变<code>Player</code>的纹理。<strong>需要注意的是构造器中对属性的改变并不会调用属性检查器，在<code>willSet</code>和<code>didSet</code>中改变自身属性也不会调用属性检查器，因为那样会造成死循环。</strong></p>

<p><code>restart(map:Map)</code>方法用于在游戏重新开始时重置<code>Player</code>的相关数据。</p>

<h2>Swift中用访问者模式处理碰撞</h2>

<p>访问者模式是双分派（Double Dispatch）模式的一种实现，关于双分派模式的详细解释，参考我的另一篇文章：<a href="http://yulingtianxia.com/blog/2014/04/13/double-dispatchmo-shi-ji-qi-zai-ioskai-fa-zhong-shi-zhan/">Double Dispatch模式及其在iOS开发中实践</a>，里面包含了C++，Java和Obje-C的实现，这次我们用Swift实现访问者模式。</p>

<p>因为SpriteKit中物理碰撞检测到的都是<code>SKPhysicsBody</code>，所以我们的被访问者需要包含一个<code>SKPhysicsBody</code>对象：</p>

<p>```
class VisitablePhysicsBody{</p>

<pre><code>let body:SKPhysicsBody
init(body:SKPhysicsBody){
    self.body = body
}
func acceptVisitor(visitor:ContactVisitor){
    visitor.visitBody(body)
}
</code></pre>

<p>}
```</p>

<p><code>acceptVisitor</code>方法传入的是一个<code>ContactVisitor</code>类，它是访问者的基类（也相当于接口），访问者的<code>visitBody(body:SKPhysicsBody)</code>方法会根据传入的<code>body</code>实例来推断出被访问者的真实类别，然后调用对应的方法来处理碰撞：</p>

<p>```
func visitBody(body:SKPhysicsBody){</p>

<pre><code>    //第二次dispatch，通过构造方法名来执行对应方法
    // 生成方法名，比如"visitPlayer"
    var contactSelectorString = "visit" + body.node.name + ":"
    let selector = NSSelectorFromString(contactSelectorString)
    if self.respondsToSelector(selector){
        dispatch_after(0, dispatch_get_main_queue(), {
            NSThread.detachNewThreadSelector(selector, toTarget:self, withObject: body)
            })
    }

}
</code></pre>

<p>```</p>

<p>Swift废弃了<code>performSelector</code>方法，所以这里耍了个小聪明来将消息传给具体的访问者。有关Swift中替代<code>performSelector</code>的方案，参见<a href="http://www.cnblogs.com/yangzhou1030/p/3830592.html">这里</a></p>

<p>下面让<code>GameScene</code>实现<code>SKPhysicsContactDelegate</code>协议：</p>

<p>```
func didBeginContact(contact:SKPhysicsContact){</p>

<pre><code>    //A-&gt;B
    let visitorA = ContactVisitor.contactVisitorWithBody(contact.bodyA, forContact: contact)
    let visitableBodyB = VisitablePhysicsBody(body: contact.bodyB)
    visitableBodyB.acceptVisitor(visitorA)
    //B-&gt;A
    let visitorB = ContactVisitor.contactVisitorWithBody(contact.bodyB, forContact: contact)
    let visitableBodyA = VisitablePhysicsBody(body: contact.bodyA)
    visitableBodyA.acceptVisitor(visitorB)
}
</code></pre>

<p><code>``
跟Objective-C中实现访问者模式类似，也是通过</code>ContactVisitor<code>类的工厂方法返回一个对应的子类实例来作为访问者，然后实例化一个被访问者，被访问者接受访问者的访问。A访问B和B访问A在大多数场合是相同的，但是你不知道谁是A谁是B，所以需要两种情况都调用。下面是</code>ContactVisitor`类的工厂方法和构造器：</p>

<p>```
class ContactVisitor:NSObject{</p>

<pre><code>let body:SKPhysicsBody!
let contact:SKPhysicsContact!
class func contactVisitorWithBody(body:SKPhysicsBody,forContact contact:SKPhysicsContact)-&gt;ContactVisitor!{
    //第一次dispatch，通过node类别返回对应的实例
    if 0 != body.categoryBitMask&amp;playerCategory {
        return PlayerContactVisitor(body: body, forContact: contact)
    }
    if 0 != body.categoryBitMask&amp;killerCategory {
        return KillerContactVisitor(body: body, forContact: contact)
    }
    if 0 != body.categoryBitMask&amp;scoreCategory {
        return ScoreContactVisitor(body: body, forContact: contact)
    }
    if 0 != body.categoryBitMask&amp;shieldCategory {
        return ShieldContactVisitor(body: body, forContact: contact)
    }
    return nil

}
init(body:SKPhysicsBody, forContact contact:SKPhysicsContact){
    self.body = body
    self.contact = contact
    super.init()

}
</code></pre>

<p>}
```</p>

<p>PS：上面的代码省略了已经提到过的<code>visitBody(body:SKPhysicsBody)</code>方法</p>

<p>因为这个游戏逻辑比较简单，所有碰撞后的逻辑都写到了<code>PlayerContactVisitor</code>类里：</p>

<p>```
func visitKiller(body:SKPhysicsBody){</p>

<pre><code>    let thisNode = self.body.node as Player
    let otherNode = body.node
</code></pre>

<p>//        println(thisNode.name+&ldquo;&ndash;>&rdquo;+otherNode.name)</p>

<pre><code>    if thisNode.shield {
        otherNode.removeFromParent()
        thisNode.shield = false
    }
    else {
        Data.gameOver = true
    }
}
func visitScore(body:SKPhysicsBody){
    let thisNode = self.body.node
    let otherNode = body.node
</code></pre>

<p>//        println(thisNode.name+&ldquo;&ndash;>&rdquo;+otherNode.name)</p>

<pre><code>    otherNode.removeFromParent()
    Data.score += 2
}
func visitShield(body:SKPhysicsBody){
    let thisNode = self.body.node as Player
    let otherNode = body.node
    otherNode.removeFromParent()
    thisNode.shield = true
    Data.score++
    //        println(thisNode.name+"-&gt;"+otherNode.name)
}
</code></pre>

<p>```</p>

<p>上面的方法都是“visit+类名”格式的，处理的是<code>Player</code>碰撞到其他三种精灵的逻辑。而其他三种精灵之间的碰撞不需要处理，所以<code>KillerContactVisitor</code>、<code>ScoreContactVisitor</code>和<code>ShieldContactVisitor</code>这三个<code>ContactVisitor</code>的子类很空旷，这里不再赘述。</p>

<p>我们设置<code>Player</code>碰撞到<code>Killer</code>游戏结束，碰撞到<code>Score</code>加两分，碰撞到<code>Shield</code>加一分并获得护甲（shield属性设为true）。可以看到这里大量用到了<code>Data</code>“类“”，它其实是一个存储并管理全局数据的结构体，它里面存储了一些静态的成员属性，也可看做非线程安全的单例。</p>

<h2>界面数据显示</h2>

<p>这部分很简单，主要是将<code>Data</code>结构体中存储的分数和等级等数据通过<code>SKLabelNode</code>显示在界面上，只不过我封装了一个<code>Display</code>类来将所有的<code>SKLabelNode</code>统一管理，并让其实现我定义的<code>DisplayData</code>协议来让<code>Data</code>中的数据变化驱动界面更新：</p>

<p>```
protocol DisplayData{</p>

<pre><code>func updateData()
func levelUp()
func gameOver()
func restart()
</code></pre>

<p>}
```</p>

<p>下面是Data结构体代码，大量使用了存储属性的监察器来响应数据变化：</p>

<p>```
struct Data{</p>

<pre><code>static var display:DisplayData?
static var updateScore:Int = 5
static var score:Int = 0{
willSet{
    if newValue&gt;=updateScore{
        updateScore+=5 * ++level
    }
}
didSet{
    display?.updateData()
}
}
static var highScore:Int = 0
static var gameOver:Bool = false {
willSet{
    if newValue {
        let standardDefaults = NSUserDefaults.standardUserDefaults()
        Data.highScore = standardDefaults.integerForKey("highscore")
        if Data.highScore &lt; Data.score {
            Data.highScore = Data.score
            standardDefaults.setInteger(Data.score, forKey: "highscore")
            standardDefaults.synchronize()
        }
        display?.gameOver()
    }
    else {
        display?.restart()
    }
}
didSet{

}
}
static var level:Int = 1{
willSet{
    speedScale = Float(newValue)*0.1
    if newValue != 1{
        display?.levelUp()
    }
}
didSet{
    display?.updateData()

}
}
static var speedScale:Float = 0{
willSet{

}
didSet{

}
}

static func restart(){
    Data.updateScore = 5
    Data.score = 0
    Data.level = 1
    Data.speedScale = 0
}
</code></pre>

<p>}
```</p>

<p>这里不得不提到一个更新界面时遇到的一个坑，当我想通过名字遍历<code>GameScene</code>子节点的时候，一般会用到<code>enumerateChildNodesWithName(name: String?, usingBlock: ((SKNode!, UnsafePointer&lt;ObjCBool&gt;) -&gt; Void)?)</code>方法，但是这个方法在Xcode6Beta3更新后经常会抛异常强退，这让我很费解，恰巧遇到此问题的不只是我一个人，所以还是老老实实的自己写循环遍历加判断吧。</p>

<h2>按钮的绘制和截图分享</h2>

<p>参考我的另外两篇文章：<a href="http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button/">在游戏的SKScene中添加Button</a>和<a href="http://yulingtianxia.com/blog/2014/04/22/spritekitjie-ping-bing-fen-xiang-zhi-she-jiao-wang-luo/">SpriteKit截屏并分享至社交网络</a></p>

<p>在本工程中只有<code>ShareButton</code>和<code>ReplayButton</code>两个按钮，Swift版本的代码很简洁，而我通过<code>Social.Framework</code>中的<code>UIActivityViewController</code>来分享得分，这部分代码写在了<code>ShareButton.swift</code>中：</p>

<p>```
let scene = self.scene as GameScene</p>

<pre><code>    let image = scene.imageFromNode(scene)
    let text = "我在Spiral游戏中得了\(Data.score)分，快来追逐我的步伐吧！"
    let activityItems = [image,text]
    let activityController = UIActivityViewController(activityItems: activityItems, applicationActivities: nil)
    (scene.view.nextResponder() as UIViewController).presentViewController(activityController, animated: true, completion: nil)
</code></pre>

<p>```</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpriteKit坐标系]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/04/spritekitzuo-biao-xi/"/>
    <updated>2014-05-04T19:36:26+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/04/spritekitzuo-biao-xi</id>
    <content type="html"><![CDATA[<p>前一阵子在用SpriteKit写一个小游戏的时候，因为对坐标系系统不是很熟悉，结果耽误了不少时间，现在将这些SKNode(及其子类)中常用的部分记下来，以利于以后快速查找</p>

<p>本文测试用到的工程代码可以在<a href="https://github.com/yulingtianxia/NodesCoordinates/tree/master">这里</a>下载</p>

<p><strong>一般来说，SpriteKit中所有坐标系都是x轴正方向向右，y轴正方向向上的，后面不再重复</strong></p>

<!--more-->


<h2>SKScene</h2>

<p>虽然是<code>SKNode</code>的子类的子类，但是因为所有<code>SKNode</code>都需要在场景上构建布局，所以比较重要，其原点在左下角，y轴向上，x轴向右；正是因为UIView的原点在左上角，y轴向下，x轴向右，所以在<code>SKScene</code>中判别手势坐标的时候需要将y轴反向：</p>

<p>``` objc
&ndash; (void)handlePanFrom:(UIPanGestureRecognizer *)recognizer {</p>

<pre><code>if (recognizer.state == UIGestureRecognizerStateBegan) {
    CGPoint touchLocation = [recognizer locationInView:recognizer.view];
    touchLocation = [self convertPointFromView:touchLocation];
    AtomNode *touchedNode = (AtomNode *)[self nodeAtPoint:touchLocation];
    if (isAllAtomStatic&amp;&amp;[touchedNode.name isEqualToString:AtomName]) {
        touchedAtom = touchedNode;
        isPanningAtom = YES;
    }


} else if (recognizer.state == UIGestureRecognizerStateChanged) {

    CGPoint translation = [recognizer translationInView:recognizer.view];
    translation = CGPointMake(translation.x, -translation.y);
    if (isPanningAtom==YES) {
        touchedAtom.position = CGPointMake(touchedAtom.position.x+translation.x, touchedAtom.position.y+translation.y);
    }
    [recognizer setTranslation:CGPointZero inView:recognizer.view];

} else if (recognizer.state == UIGestureRecognizerStateEnded) {

    if (isPanningAtom==YES) {
        CGPoint velocity = [recognizer velocityInView:recognizer.view];
        touchedAtom.physicsBody.velocity =CGVectorMake(velocity.x, -velocity.y);
        isPanningAtom = NO;
    }
}
</code></pre>

<p>}
```</p>

<p>在第一个判断分支中，因为用了<code>convertPointFromView</code>方法，已经将<code>CGPoint</code>从<code>UIView</code>坐标系转为<code>SKScene</code>坐标系，所以不用反转，其余两个分支中的代码均需要反转y轴。</p>

<h2>SKNode</h2>

<p>SKNode的原点在正中央，也就是(0.5,0.5)<br/>
我构建了一个App，分别将被测试的Node放置在场景中央，并用一个黑色的小圆圈代表Node的坐标系的原点<br/>
因为SKNode比较抽象，没填充内容，所以只显示了一个原点：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353411185.png" alt="" /></p>

<p>如果想填充些东西来证明SKNode的坐标系原点的确在其中央，将下面代码注释部分取消注释即可：</p>

<p>```</p>

<h1>import &ldquo;NodeButton.h&rdquo;</h1>

<p>@implementation NodeButton
&ndash;(id)init{</p>

<pre><code>if (self = [super initWithName:@"SKNode"]) {
    SKNode *sknode = (SKNode *)self.node;
    SKSpriteNode *fill = [[SKSpriteNode alloc] init];
    fill.size = CGSizeMake(100, 100);
    fill.color = [UIColor redColor];
    fill.colorBlendFactor = 1;
</code></pre>

<p>//        [sknode addChild:fill];</p>

<pre><code>}
return self;
</code></pre>

<p>}
@end
```</p>

<h2>SKEmitterNode</h2>

<p>粒子系统比较有趣，它从原点发射大量粒子，不同的粒子系统也会构筑不同的效果，因为它没有边界，还可调节发射粒子的数量方向速度等，这也使得原点在整个粒子系统中的位置有了错觉，但其本质还是(0.5,0.5)，也就是在中心</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353410978.png" alt="" /></p>

<p>这个火苗看起来中心在哪呢？当然在圆圈处！因为粒子是从圆圈处的区域产生的，然后向上发射</p>

<h2>SKLabelNode</h2>

<p>label比较特殊，可能是因为需要现实文字的关系吧，其坐标原点在中下方，但不是(0.5,0)，因为如果文字包含y，p之类的“带尾巴”的字符，那么将会突出十字线下方，可以理解为写英文用的四线本的第三条线？因为字号大小不同或者提子不同，也会影响到原点位置。</p>

<p>知道其原点精确位置对于编程来说意义不大，以后有时间会深究下</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353410886.png" alt="" /></p>

<h2>SKShapeNode</h2>

<p>这个类也很特殊，因为其frame是根据path填充内容来确定的，而原点又是其在父坐标的position处，那么<code>SKShapeNode</code>的原点具体位置在哪也就没意义了，只要按照其position的位置当作原点建立坐标系就好</p>

<p>```
@implementation ShapeButton
&ndash;(id)init{</p>

<pre><code>if (self = [super initWithName:@"SKShapeNode"]) {
    SKShapeNode *shape = (SKShapeNode *)self.node;
    shape.path = CGPathCreateWithRect(CGRectMake(-50,-50, 100, 100), NULL);
    shape.strokeColor = [UIColor redColor];

}
return self;
</code></pre>

<p>}
@end
```</p>

<p>下图是我故意画了个正方形使其居中：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353411872.png" alt="" /></p>

<h2>SKSpriteNode</h2>

<p>坐标原点在其frame中心，也就是(0.5,0.5)</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353412174.png" alt="" /></p>

<h2>总结</h2>

<p>其实之所以会出现坐标系原点位置一说，是因为不同类型的Node其frame大小也不一样，而其原点在其frame中的位置也不一样，这就给人一种错觉：有的Node原点在左下角，只暴漏给我们第一象限；有的Node原点在中间，其四个象限都被填充了。。。无论原点在哪，其x轴，y轴方向都是不变的，所以本质都是一样的，只是写代码的时候需要注意，比如如果觉得将一个<code>SKLabelNode</code>的position设置为屏幕中心，则其文字内容就会正好居中，其实那就错了，因为y轴并没有居中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在游戏的SKScene中添加Button]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button/"/>
    <updated>2014-04-27T13:18:04+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button</id>
    <content type="html"><![CDATA[<p>偶然发现<code>SpriteKit</code>中的<code>SKNode</code>也有<code>userInteractionEnabled</code>属性，就像<code>UIKit</code>中的<code>userInteractionEnabled</code>一样，于是我对以前的代码进行重构，发现了在游戏中添加交互button的新的方式（估计很多大神们早就发现了）</p>

<!--more-->


<h2>在SKScene中添加SKNode对象作为Button</h2>

<p>不得不承认，我以前在<code>SKScene</code>中添加一个<code>Button</code>的过程是这样的：</p>

<p><strong>添加一个<code>SKNode</code>（一般都是它的子类：<code>SKLabelNode</code>和<code>SKSpriteNode</code>）属性</strong></p>

<p><code>objc
SKLabelNode *button = [SKLabelNode labelNodeWithFontNamed:@"Chalkduster"];
</code></p>

<p><strong>设置其填充的内容和放置位置，还有<code>SKNode</code>的<code>name</code></strong></p>

<p><code>
button.text = @"Click me";
button.name = @"button";
button.fontSize = 40;
button.fontColor = [SKColor purpleColor];
button.position = CGPointMake(self.size.width/2, self.size.height/2);
[self addChild:button];
</code></p>

<p><strong>在<code>SKScene</code>重写<code>touchesEnded: withEvent:</code>方法，并在方法中判断触摸到哪个<code>SKNode</code></strong></p>

<p>```
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event{</p>

<pre><code>UITouch * touch = [touches anyObject];
CGPoint location = [touch locationInNode:self];
SKSpriteNode *touchedNode = (SKSpriteNode *)[self nodeAtPoint:location];
if ([touchedNode.name isEqualToString:@"button"]) {
    //TODO:
}
</code></pre>

<p>}
<code>``
如果某个场景中需要设置很多Button，比如游戏设置界面，那么在</code>touchesEnded: withEvent: `方法中就会出现好多if判断，这么多分支，每个分支可能还有很多操作，这样增加了SKScene的体积，使得代码可读性变差，维护也困难</p>

<h2>通过继承来封装自己的Button</h2>

<p><code>UIKit</code>中的<code>userInteractionEnabled</code>大家一定都很熟悉，它默认值是<code>YES</code>，也就是默认接受触摸事件，偶然发现<code>SKNode</code>也有<code>userInteractionEnabled</code>属性，但是默认值是<code>NO</code>，而且<code>SKNode</code>是继承<code>UIResponder</code>的，这么说，我们可以在SKNode中一展拳脚了，不必再麻烦SKScene了<br/>
下面添加一个用于跳转到主菜单场景页面的Button为例：<br/>
<strong>新建一个类，名字叫MainSceneButton，继承<code>SKLabelNode</code>，并构造出时候方法</strong></p>

<p>```
&ndash;(id)init{</p>

<pre><code>if (self = [super initWithFontNamed:@"Chalkduster"]) {
    self.text = @"MENU";
    self.fontSize = 20;
    self.userInteractionEnabled = YES;
}
return self;
</code></pre>

<p>}</p>

<p><code>``
这里碰到一个问题：如果用上面的代码初始化，将会出现</code>EXC_BAD_ACCESS` 错误，问题的解决方法是在超类初始化时用init方法代替，然后再设置字体：</p>

<p>```
&ndash;(id)init{</p>

<pre><code>if (self = [super init]) {
    self.fontName = @"Chalkduster";
    self.text = @"MENU";
    self.fontSize = 20;
    self.userInteractionEnabled = YES;
}
return self;
</code></pre>

<p>}
<code>``
至于原因，我也没弄清楚，估计是</code>SKLabelNode<code>的bug吧，因为初始化</code>SKSpriteNode<code>时用</code>initWithTexture: color: size:<code>方法就不会报错  
**在MainSceneButton中重写</code>touchesEnded: withEvent: `方法**</p>

<p>```
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event{</p>

<pre><code>SKTransition *reveal = [SKTransition flipHorizontalWithDuration:0.5];
SKScene * myScene = [[MainScene alloc] initWithSize:self.scene.size];
[self.scene.view presentScene:myScene transition: reveal];
</code></pre>

<p>}
```
MainScene是我的一个SKScene，通过点击MainSceneButton来切换到MainScene<br/>
<strong>最后在某个场景中将button添加上去，跟之前的类似</strong></p>

<p><code>
MainSceneButton *mainScene = [[MainSceneButton alloc] init];
mainScene.position = CGPointMake(self.size.width/2, self.size.height/2);
[self addChild:mainScene];
</code>
感觉这样做是不是很像以前继承一个UIView然后封装自己的Custom View呢？给SKScene瘦身的方法还有很多，参照给UIViewController瘦身的方法，我们还可以把其他SKNode也从SKScene中剥离出去，一些用于设置SKNode的方法也会随之剥离到自定义的类中，便于以后维护代码</p>
]]></content>
  </entry>
  
</feed>
