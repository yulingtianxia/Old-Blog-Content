<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Core Data | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/core-data/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-10-01T09:07:28+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[CoreData处理海量数据]]></title>
    <link href="http://yulingtianxia.com/blog/2014/08/05/coredatachu-li-hai-liang-shu-ju/"/>
    <updated>2014-08-05T18:15:03+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/08/05/coredatachu-li-hai-liang-shu-ju</id>
    <content type="html"><![CDATA[<p>随着iOS8和OSX10.10的发布，Core Data也迎来了更新。这次的更新可谓是重量级的，它使得程序员能够更加直接高效的操作数据库，在处理大量数据时速度明显提升（这在以前不知有多少程序员因为Core Data批量更新数据效率之低而不得不放弃使用它）。Batch Updates可用于批量快速更新数据，Asynchronous Fetching可用于异步抓取海量数据，并可以通过<code>NSProgress</code>实现进度跟踪和取消。</p>

<!--more-->


<h2>Batch Updates</h2>

<p>在CoreData中想要更新大量数据，我们往往要将大量修改后的<code>NSManagedObject</code>加载到<code>NSManagedObjectContext</code>中并保存，这会占用大量内存，试想想在iPhone这样的内存有限的移动设备上将是个灾难，数据有可能丢失。你可能会采取批处理的方式，即一小批一小批的更新<code>NSManagedObject</code>并保存到<code>NSManagedObjectContext</code>中，但这样会花费很多时间，用户体验较差。</p>

<p>为了解决这个问题，苹果在<code>NSManagedObjectContext</code>加入了一个新的方法：<code>executeRequest:error:</code>，它接受一个<code>NSPersistentStoreRequest</code>类型的参数，返回类型为<code>NSPersistentStoreResult</code>。</p>

<p>关于<code>NSPersistentStoreRequest</code>有些人可能比较熟悉，它是<code>NSFetchRequest</code>、<code>NSSaveChangesRequest</code>、<code>NSBatchUpdateRequest</code>和<code>NSAsynchronousFetchRequest</code>的基类。后两个类是这次iOS8新加的，也是这篇文章将要讨论的内容。</p>

<p><code>NSPersistentStoreResult</code>是一个新加入的类，它也是一个基类，而且是抽象类，这个类作为<code>executeRequest:error:</code>返回内容的父类，相当于一个接口，它目前有两个子类：<code>NSPersistentStoreAsynchronousResult</code>和<code>NSBatchUpdateResult</code>。</p>

<p>你大概猜到了，<code>NSBatchUpdateResult</code>对应着前面的<code>NSBatchUpdateRequest</code>，下面说说<code>NSBatchUpdateRequest</code>。它有点像<code>NSFetchRequest</code>：它允许你指定一个想要更新数据的实体；也可以指定一个<code>affectedStores</code>，它存储了一个接受更新请求的<code>NSPersistentStore</code>数组。（其实它是<code>NSPersistentStoreRequest</code>的属性）；它也有一个谓词属性来做更新的条件，它跟<code>NSFetchRequest</code>中的谓词一样强大和灵活，类似于SQL的where语句；它允许你指定想要更新的字段，通过<code>propertiesToUpdate</code>属性来描述字段更新，它是一个字段，key为<code>NSPropertyDescription</code>或属性名字符串，value为<code>NSExpression</code>或常量。</p>

<p>接着谈谈<code>NSBatchUpdateResult</code>，它有一个<code>result</code>属性和<code>resultType</code>属性，<code>result</code>中的内容跟<code>resultType</code>有关，可能是成功或者失败，有可能是每行被更新的ID，也可能是被更新的行数。</p>

<p>需要注意的是，由于<code>NSBatchUpdateRequest</code>并不会先将数据存入内存，而是直接操作数据库，所以并不会引起NSManagedObjectContext的同步更新，所以你不仅需要获取<code>NSBatchUpdateResult</code>然后刷新<code>NSManagedObjectContext</code>对应的数据和UI界面，还需要保证更新后的数据满足数据库模型上的<code>validation</code>，因为<code>NSManagedObjectContext</code>没有感知Batch Updates，一些数据验证工作就落在了程序员的身上（你需要写一段代码验证更新后的数据是合法的，用户可不希望在跑步APP上看到自己今天跑步里程是个负数）。一旦有非法数据录入数据库，下次加载并修改<code>NSManagedObject</code>的时候就会导致数据验证失败。除了上面提到的这些，还要注意Batch Updates对数据库的操作是乐观锁，也就是假定很少会发生同时存取同一块数据的情况，所以你需要制定一个合理的"merge"策略来应付因同时更新数据产生的冲突。</p>

<p>Batch Updates的优势在于其效率，在处理上万条数据的时候，它执行的时间跟SQL语句执行时间相当。</p>

<h2>Asynchronous Fetching</h2>

<p>Asynchronous Fetching的加入依然是为了解决CoreData读取海量数据所带来的问题。通过使用Asynchronous Fetching，我们可以在抓取数据的同时不阻塞占用<code>NSManagedObjectContext</code>，并可以随时取消抓取行为，随时跟踪抓取数据的进度。</p>

<p>设想我们平时用<code>NSFetchRequest</code>抓取数据的时候，我们会先用<code>NSManagedObjectContext</code>的<code>executeFetchRequest:error:</code>方法传入一个<code>NSFetchRequest</code>，然后请求会被发送到<code>NSPersistentStore</code>，然后执行一段时间后返回一个数组，在<code>NSManagedObjectContext</code>更新后，这个数组被当做<code>executeFetchRequest:error:</code>的返回值返回到我们这里。</p>

<p>而Asynchronous Fetching则不同，当我们将一个<code>NSAsynchronousFetchRequest</code>对象传入<code>executeRequest:error:</code>方法后会立即返回一个“未来的”<code>NSAsynchronousFetchResult</code>。<code>NSAsynchronousFetchRequest</code>初始化时需要传入两个参数赋值给属性：</p>

<ol>
<li><code>completionBlock</code>属性，允许我们在抓取完成后执行回调block；</li>
<li><code>fetchRequest</code>属性，类型是<code>NSFetchRequest</code>。也即是说虽然是异步抓取，其实我们用的还是以前的<code>NSFetchRequest</code>，当<code>NSFetchRequest</code>抓取结束后会更新<code>NSManagedObjectContext</code>，这也就意味着<code>NSManagedObjectContext</code>的并发类型只能是<code>NSPrivateQueueConcurrencyType</code>或<code>NSMainQueueConcurrencyType</code>。</li>
</ol>


<p>于是当我们用<code>NSAsynchronousFetchRequest</code>抓取数据时，我们会先用<code>NSManagedObjectContext</code>的<code>executeRequest:error:</code>方法传入一个<code>NSAsynchronousFetchRequest</code>，这个方法在<code>NSManagedObjectContext</code>上执行时，<code>NSManagedObjectContext</code>会立即制造并返回一个<code>NSAsynchronousFetchResult</code>，同时<code>NSAsynchronousFetchRequest</code>会被发送到<code>NSPersistentStore</code>。你现在可以继续编辑这个<code>NSManagedObjectContext</code>中的<code>NSManagedObject</code>，等到<code>NSPersistentStore</code>执行请求完毕时会将结果返回给<code>NSAsynchronousFetchResult</code>的<code>finalResult</code>属性，更新<code>NSManagedObjectContext</code>，执行<code>NSAsynchronousFetchRequest</code>的回调block。</p>

<p>举个栗子：</p>

<p>```
let request = NSFetchRequest(entityName: &ldquo;MyEntity&rdquo;)</p>

<pre><code>    let async = NSAsynchronousFetchRequest(fetchRequest: request){
        (id result) in
        if result.finalResult {
            //TODO..
        }
    }
</code></pre>

<p>```</p>

<p>Swift代码很简洁，并用了尾随闭包语法，看不懂的朋友也不用着急，知道<code>NSAsynchronousFetchRequest</code>大概的用法就行。</p>

<p>之前提到过<code>NSAsynchronousFetchRequest</code>能在抓取数据的过程中跟踪进度，于是乎<code>NSProgress</code>登场了！一行代码顶十句话：</p>

<p>```
let request = NSFetchRequest(entityName: &ldquo;MyEntity&rdquo;)
var asyncResult:NSPersistentStoreResult!
let async = NSAsynchronousFetchRequest(fetchRequest: request){</p>

<pre><code>        (id result) in
        if result.finalResult {
            //TODO..
        }
    }
</code></pre>

<p>let progress = NSProgress(totalUnitCount: 1)
progress.becomeCurrentWithPendingUnitCount(1)
managedObjectContext?.performBlock{</p>

<pre><code>        [unowned self] in
        let error = NSErrorPointer()
        asyncResult = self.managedObjectContext?.executeRequest(async, error: error)
    }
</code></pre>

<p>progress.resignCurrent()
<code>``
而取消获取数据只需要取消</code>NSProgress`就可以了！取消行为会沿着数的根节点蔓延到叶子。</p>

<p><code>
progress.cancel()
</code>
可以在<code>cancellationHandler</code>属性设置取消后执行的block，这里不再多说。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Core Data(3)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3/"/>
    <updated>2014-07-03T10:28:28+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3</id>
    <content type="html"><![CDATA[<p>在Swift发布后，我尝试用Swift和Core Data做了一个小Demo，名字叫“HardChoice”。它用于帮助人们随机生成一个问题的结果，当然结果是预设好的，并可以加入权值。本文将通过这个Demo来进一步阐述Core Data的知识。</p>

<p>本文包含以下内容：</p>

<ul>
<li>建立数据模型</li>
<li>Swift与Objective-C桥接</li>
<li>NSFetchedResultsController</li>
<li>UITextField键盘响应</li>
<li>随机选择算法</li>
</ul>


<!--more-->


<p>你可以在<a href="https://github.com/yulingtianxia/HardChoice">GitHub</a>上下载HardChoice的代码</p>

<p>在没弄懂Core Data的基础知识之前，我建议你先阅读我之前的两篇博文：</p>

<p><a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a><br/>
<a href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/">初识Core Data(2)</a></p>

<p>如果你不懂Swift也没关系，只要了解OC和Core Data，总是能看懂的</p>

<p>在写代码前先了解下我们要做什么：<br/>
<img src="http://yulingtianxia.qiniudn.com/140435701469.png" alt="" />
<img src="http://yulingtianxia.qiniudn.com/1404357012.png" alt="" /></p>

<p>先在第一个页面添加问题（吃啥？），然后点击问题进入到第二个添加选项（鸭子，蛋，猪）的页面。每个选项左边是选项名，右边是该选项的权值。摇动手机就能随机从所有选项中选出答案（就像第二张图那样）。</p>

<h2>建立数据模型</h2>

<p>还是像以前那样新建一个Master-Detail Application，勾选Use Core Data选项，语言选择Swift，然后Xcode会自动生成一个具有<code>UITableView</code>的Demo，这些内容之前说过。下面我们需要打开xcdatamodeld文件来建立我们的数据模型：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140436356516.png" alt="" /></p>

<p><code>Question</code>这个实体只具有一个属性，那就是问题内容<code>content</code>，类型为<code>String</code>；<code>Choice</code>实体有一个类型为<code>String</code>的<code>name</code>属性和一个类型为<code>Integer32</code>的<code>weight</code>属性，分别代表问题选项的名字和权重。</p>

<p>下面我们来建立<code>Question</code>和<code>Choice</code>这两个实体之间的关系：</p>

<p>假设每个问题都对应多个选项，也可以没有选项：</p>

<p><img src="http://yulingtianxia.qiniudn.com/14043675716.png" alt="" /></p>

<p><code>Optional</code>被打钩是因为问题可以没有任何选项，在Tpye那里我们选择<code>To Many</code></p>

<p>相反，每个选项一定会对应一个问题，并且是唯一的问题：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140436793089.png" alt="" /></p>

<p><code>Optional</code>那里不打钩是为了避免关系的目标为空，在<code>Tpye</code>那里我们选择了<code>To One</code></p>

<p><strong>关于<code>Delete Rule</code>的选择</strong></p>

<p>下面会通过部门与员工的例子来阐述<code>Delete Rule</code>的用法</p>

<ul>
<li><strong><code>Deny</code></strong> 如果关系指向的目标仍然有对象，那么关系的源对象就不会被删除，比如你想删除一个部门，必须先确保该部门所有员工已经调到其他部门（或被解雇），否则这个部门就不会被删除。</li>
<li><strong><code>Nullify</code></strong> 将被删除对象反向关系的目标设为null，比如如果你删除了一个部门，那么将这个部门所有成员的department关系目标设为null。需要注意的是员工的department关系应该被勾选为Optional，或者是在删除部门之后马上给该部门员工设置一个新的部门。</li>
<li><strong><code>Cascade</code></strong> 顾名思义它会传递删除命令，删除一个对象会导致这个对象关系中所指向的所有目标对象也被删除。比如如果你删除了一个部门那么这个部门所有员工都会被立即删除。</li>
<li><strong><code>No Action</code></strong> 无为而治。比如如果你删除了一个部门，那么这个部门底下的所有员工什么都不知道，他们还以为自己还属于这个部门。</li>
</ul>


<p>回到我们的例子，因为<code>Question</code>指向<code>Choice</code>的<code>choices</code>关系具有从属的性质，问题被删除后<code>choices</code>所指向的选项也应该被删除，所以<code>choices</code>关系中的<code>Delete Rule</code>我们选择<code>Cascade</code>；而<code>Choice</code>指向<code>Question</code>的<code>question</code>关系中<code>Delete Rule</code>被设置成了<code>Nullify</code>，也就是解除了<code>Question</code>与这个<code>Choice</code>的关系，并且我们之前已经设置<code>Question</code>的<code>choices</code>关系设置为<code>Optional</code>来满足<code>Nullify</code>这一选项的要求。</p>

<p><strong>注意：每当你修改过数据模型后，需要将以前生成好的APP删除后再重新Run一下，这样才不会发生错误。这是因为手动删除APP会连同将其数据一起删除，然后重新Run一下会将新的数据表结构安装在模拟器或真机上</strong></p>

<p>如果你对建立数据模型的过程生疏，建议回到<a href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/">初识Core Data(2)</a>中复习下“使用数据模型设计器”一节</p>

<h2>Swift与Objective-C桥接</h2>

<p>在使用Xcode6 Beta2生成<code>NSManagedObject</code>子类的时候，生成的代码依然是Objective-C的代码（即使我的工程是用Swift语言建立的），这就涉及到在Swift工程中调用Objective-C类的问题。苹果给我们提供了一个比较简单的解决方案。在你向工程中加入OC文件时，Xcode会自动弹出消息问你是否需要生成一个桥接头文件（“工程名-Bridging-Header.h”），然后我们在这个头文件中加入想要在Swift中调用的OC类的头文件：</p>

<p>``` objc
//
//  Use this file to import your target&rsquo;s public headers that you would like to expose to Swift.
//</p>

<h1>import &ldquo;Question.h&rdquo;</h1>

<h1>import &ldquo;Choice.h&rdquo;</h1>

<h1>import &ldquo;CustomIOS7AlertView.h&rdquo;</h1>

<p>```</p>

<p><code>Question</code>和<code>Choice</code>这两个类是用之前数据模型中同名实例创建的<code>NSManagedObject</code>子类，<code>CustomIOS7AlertView</code>类是本项目用到的一个自定义AlertView（iOS7之后苹果不再允许自定义<code>UIAlertView</code>了）</p>

<p>这样在Swift文件中不用<code>import</code>任何东西就可以直接使用上面被引入的OC类了</p>

<p>有关Swift和OC在同一项目中混合使用的方法详见<a href="https://github.com/CocoaChina-editors/Welcome-to-Swift/blob/master/Using%20Swift%20with%20Cocoa%20and%20Objective-C/03Mix%20and%20Match/Swift%20and%20Objective-C%20in%20the%20Same%20Project.md">这里</a></p>

<h2>NSFetchedResultsController</h2>

<p>在<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a>中我们提到过<code>NSFetchedResultsController</code>的作用，简单地说，<code>NSFetchedResultsController</code>的作用就是有效率的管理从CoreData获取请求的数据结果，并将结果提供给<code>UITableView</code>作为数据源。</p>

<p>在<code>MasterViewController.swift</code>文件中，Xcode生成了两个<code>NSFetchedResultsController</code>属性：一个只读计算属性<code>fetchedResultsController</code>和一个可选存储属性<code>_fetchedResultsController</code>，通过两者搭配来实现setter，这里不再多说，将计算属性<code>fetchedResultsController</code>的定义替换如下：</p>

<p>``` js</p>

<pre><code>var fetchedResultsController: NSFetchedResultsController {
    if _fetchedResultsController != nil {
        return _fetchedResultsController!
    }

    let fetchRequest = NSFetchRequest()
    // Edit the entity name as appropriate.
    let entity = NSEntityDescription.entityForName("Question", inManagedObjectContext: self.managedObjectContext)
    fetchRequest.entity = entity

    // Set the batch size to a suitable number.
    fetchRequest.fetchBatchSize = 20

    // Edit the sort key as appropriate.
    let sortDescriptor = NSSortDescriptor(key: "content", ascending: true)
    let sortDescriptors = [sortDescriptor]

    fetchRequest.sortDescriptors = sortDescriptors

    // Edit the section name key path and cache name if appropriate.
    // nil for section name key path means "no sections".
    let aFetchedResultsController = NSFetchedResultsController(fetchRequest: fetchRequest, managedObjectContext: self.managedObjectContext, sectionNameKeyPath: nil, cacheName: "Master")
    aFetchedResultsController.delegate = self
    _fetchedResultsController = aFetchedResultsController

    var error: NSError? = nil
    if !_fetchedResultsController!.performFetch(&amp;error) {
         // Replace this implementation with code to handle the error appropriately.
         // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
         //println("Unresolved error \(error), \(error.userInfo)")
         abort()
    }

    return _fetchedResultsController!
}
</code></pre>

<p>```</p>

<p><code>NSFetchRequest</code>对象描述了从数据持久层获取数据的标准，也就是相当于SQL中的from和where等条件语句，它是初始化<code>NSFetchedResultsController</code>的必要参数之一，因为它规定了从<code>NSManagedObjectContext</code>实例中获取什么样的数据。</p>

<p><img src="http://img41.wal8.com/img41/425047_20140623222918/140353389167.png" alt="" /></p>

<p><code>NSFetchRequest</code>的属性<code>NSEntityDescription</code>，<code>predicate</code>和<code>sortDescriptors</code>分别对应着SQL中的from，where和order by语句，只不过<code>NSFetchRequest</code>把复杂的SQL语句进行了简化，查抄条件和排序方法更加灵活。</p>

<p>在上面的<code>fetchedResultsController</code>属性中我们设置了<code>NSFetchRequest</code>实例：获取所有<code>Question</code>实体对应的数据，并将结果按照<code>content</code>属性的升序排列。</p>

<p><code>init(fetchRequest: NSFetchRequest!, managedObjectContext context: NSManagedObjectContext!, sectionNameKeyPath: String!, cacheName name: String!)</code>是<code>NSFetchedResultsController</code>的指定构造器，除了刚才提到的<code>fetchRequest</code>参数外，还需传入一个必要参数<code>managedObjectContext</code>，在这里我们传入的<code>managedObjectContext</code>是来自<code>AppDelegate</code>的<code>managedObjectContext</code>属性。有关<code>NSManagedObjectContext</code>的知识参见<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a>，这里不再赘述。<strong>当构造器执行结束后，你就不能再修改<code>NSFetchedResultsController</code>的<code>fetchRequest</code>属性了</strong>。</p>

<p><code>sectionNameKeyPath</code>参数是用来指定抓取数据结果的<code>section</code>信息的，这样<code>UITableView</code>的<code>section</code>信息此时已经预编译好了。因为我们的程序只需要一个<code>section</code>，所以只需传入<code>nil</code>；<code>cacheName</code>参数用于指定缓存<code>section</code>预编译信息的文件名，我们不需要缓存<code>section</code>信息，所以传入<code>nil</code>。</p>

<p>当执行<code>performFetch(error: NSErrorPointer) -&gt; Bool</code>方法成功后，你可以通过<code>NSFetchedResultsController</code>的<code>fetchedObjects</code>属性来获取数据结果，如果为<code>UITableView</code>提供数据，可以用<code>objectAtIndexPath(indexPath: NSIndexPath!) -&gt; AnyObject!</code>方法来更加便捷的将数据与<code>NSIndexPath</code>对接上。在我们的例子中，会把数据结果转化为<code>NSManagedObject</code>的子类<code>Question</code>或<code>Choice</code>类：</p>

<p>```</p>

<pre><code>func configureCell(cell: UITableViewCell, atIndexPath indexPath: NSIndexPath) {
    let object = self.fetchedResultsController.objectAtIndexPath(indexPath) as Question
    cell.textLabel.text = object.content
}
</code></pre>

<p>```</p>

<p>下面修改<code>insertNewObject</code>方法来添加新的<code>Question</code>：</p>

<p>```</p>

<pre><code>var addAV = CustomIOS7AlertView()
func insertNewObject(sender: AnyObject) {
    let textField = UITextField(frame:CGRectMake(0,0,290,50))
    textField.becomeFirstResponder()
    textField.placeholder = "question"
    textField.keyboardType = .Default
    textField.returnKeyType = .Done
    textField.delegate = self
    addAV.containerView = textField
    addAV.buttonTitles = ["OK","Cancel"]
    addAV.delegate = self
    addAV.useMotionEffects = true
    addAV.show()

}
</code></pre>

<p>```</p>

<p>有了添加<code>Question</code>功能，当然还会有修改功能：</p>

<p>```</p>

<pre><code>var modifyAV = CustomIOS7AlertView()
func modifyObject(indexPath:NSIndexPath){
    let question = self.fetchedResultsController.objectAtIndexPath(indexPath) as Question
    let textField = UITextField(frame:CGRectMake(0,0,290,50))
    textField.becomeFirstResponder()
    textField.placeholder = "question"
    textField.keyboardType = .Default
    textField.returnKeyType = .Done
    textField.delegate = self
    modifyAV.containerView = textField
    modifyAV.buttonTitles = ["OK","Cancel"]
    modifyAV.delegate = self
    modifyAV.useMotionEffects = true
    (modifyAV.containerView as UITextField).text = question.content
    modifyAV.show()
}
</code></pre>

<p>```</p>

<p><code>CustomIOS7AlertView</code>是一个第三方的开源AlertView，它允许我们自定义AlertView的内容，并提供了<code>CustomIOS7AlertViewDelegate</code>协议来用于按钮点击的回调，我们将这两个<code>CustomIOS7AlertView</code>实例的<code>delegate</code>属性都设置为<code>self</code>，然后在<code>MasterViewController</code>中的实现协议中唯一的方法<code>customIOS7dialogButtonTouchUpInside(alertView:AnyObject!, clickedButtonAtIndex buttonIndex:Int)</code>：</p>

<p>```</p>

<pre><code>func customIOS7dialogButtonTouchUpInside(alertView:AnyObject!, clickedButtonAtIndex buttonIndex:Int){
    switch buttonIndex{
        case 0:
        let context = self.fetchedResultsController.managedObjectContext
        let entity = self.fetchedResultsController.fetchRequest.entity
        var newManagedObject:Question!
        let av = alertView as CustomIOS7AlertView
        if addAV == av{
            newManagedObject = NSEntityDescription.insertNewObjectForEntityForName(entity.name, inManagedObjectContext: context) as Question
        }
        if modifyAV == av{
            newManagedObject = self.fetchedResultsController.objectAtIndexPath(selectedIndexPath) as Question
        }
        // If appropriate, configure the new managed object.
        // Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
        newManagedObject.content = (av.containerView as UITextField).text

        // Save the context.
        var error: NSError? = nil
        if !context.save(&amp;error) {
            // Replace this implementation with code to handle the error appropriately.
            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
            //println("Unresolved error \(error), \(error.userInfo)")
            abort()
        }
        alertView.close()
        default:
        alertView.close()
    }
}
</code></pre>

<p>```</p>

<p>当用户点击<code>alertView</code>的OK按钮时，判断<code>alertView</code>对象是<code>addAV</code>还是<code>modifyAV</code>，然后对应通过不同途径（新插入到<code>ManagedObjectContext</code>还是从<code>ManagedObjectContext</code>中取出）产生<code>Question</code>实例<code>newManagedObject</code>，最后的结果会保存回<code>ManagedObjectContext</code>中，最后关闭<code>alertView</code>。</p>

<p>添加<code>Question</code>时使用的<code>insertNewObjectForEntityForName(entityName: String!, inManagedObjectContext context: NSManagedObjectContext!) -&gt; AnyObject!</code>方法是一个配置和添加实体，并返回该实体对应<code>NSManagedObject</code>子类（在这里是<code>Question</code>类）的便捷方法，这是一个很强大的类方法，我们无需知道创建<code>Question</code>类的细节就能创建并添加一个<code>Question</code>实例到<code>NSManagedObjectContext</code>中，在保存前我们还可以对这个方法返回的<code>Question</code>实例做修改，然后再通过<code>save(error: NSErrorPointer) -&gt; Bool</code>方法保存。</p>

<p>修改<code>Question</code>的过程其实就是先通过<code>objectAtIndexPath(indexPath: NSIndexPath!) -&gt; AnyObject!</code>方法取出数据请求结果当中的某一项并转换成<code>Question</code>对象，对其进行修改后再保存。在界面中通过点击cell右侧带有字母i的蓝色圆圈来修改<code>Question</code>内容：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140438530596.png" alt="" /></p>

<p>上图的中的蓝色圆圈是<code>AccessoryButton</code>，需要在IB中设置<code>TableViewCell</code>的<code>Identifier</code>为<code>QuestionCell</code>，<code>Accessory</code>为<code>Detail Disclosure</code>，这样我们就能在<code>UITableViewDelegate</code>的<code>tableView(tableView: UITableView!, accessoryButtonTappedForRowWithIndexPath indexPath: NSIndexPath!)</code>方法中响应<code>AccessoryButton</code>了：</p>

<p>```</p>

<pre><code>override func tableView(tableView: UITableView!, accessoryButtonTappedForRowWithIndexPath indexPath: NSIndexPath!){
    selectedIndexPath = indexPath
    modifyObject(indexPath)

}
</code></pre>

<p>```</p>

<p>导航栏右侧的添加<code>Question</code>按钮已经通过下面的代码配置了响应函数：</p>

<p><code>
let addButton = UIBarButtonItem(barButtonSystemItem: .Add, target: self, action: "insertNewObject:")
self.navigationItem.rightBarButtonItem = addButton
</code>
在<code>UITableViewDelegate</code>中删除<code>Question</code>的代码如下：</p>

<p>```</p>

<pre><code>override func tableView(tableView: UITableView, commitEditingStyle editingStyle: UITableViewCellEditingStyle, forRowAtIndexPath indexPath: NSIndexPath) {
    if editingStyle == .Delete {
        let context = self.fetchedResultsController.managedObjectContext
        context.deleteObject(self.fetchedResultsController.objectAtIndexPath(indexPath) as NSManagedObject)

        var error: NSError? = nil
        if !context.save(&amp;error) {
            // Replace this implementation with code to handle the error appropriately.
            // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development.
            //println("Unresolved error \(error), \(error.userInfo)")
            abort()
        }
    }
}
</code></pre>

<p>```</p>

<p>这里多说一嘴，如果你想打印出错误信息的话，不要直接反注释那行<code>println</code>代码，还需要在<code>error</code>后加上感叹号，因为<code>error</code>是可选类型，需要强制解析：</p>

<p><code>
println("Unresolved error \(error!), \(error!.userInfo)")
</code></p>

<h2>UITextField键盘响应</h2>

<p>在将<code>UITextField</code>实例赋值给<code>CustomIOS7AlertView</code>的<code>containerView</code>属性前需要先让其获取当前焦点，并将<code>UITextField</code>的<code>delegate</code>属性设为<code>self</code>：</p>

<p>```</p>

<pre><code>var addAV = CustomIOS7AlertView()
func insertNewObject(sender: AnyObject) {
    let textField = UITextField(frame:CGRectMake(0,0,290,50))
    textField.becomeFirstResponder()//获取当前焦点
    textField.placeholder = "question"
    textField.keyboardType = .Default
    textField.returnKeyType = .Done
    textField.delegate = self
    addAV.containerView = textField
    addAV.buttonTitles = ["OK","Cancel"]
    addAV.delegate = self
    addAV.useMotionEffects = true
    addAV.show()

}
</code></pre>

<p>```</p>

<p>然后让<code>MasterViewController</code>遵循<code>UITextFieldDelegate</code>协议，并实现下面两个协议中的方法：</p>

<p>```</p>

<pre><code>func textFieldDidBeginEditing(textField: UITextField!){
    let animationDuration:NSTimeInterval  = 1
    var frame = self.view.frame;
    frame.origin.y-=116
    frame.size.height+=116
    self.view.frame = frame;
    UIView.animateWithDuration(animationDuration){
        self.view.frame = frame;
    }
}

func textFieldShouldEndEditing(textField: UITextField!) -&gt; Bool{
    let animationDuration:NSTimeInterval  = 1
    var frame = self.view.frame;
    frame.origin.y+=116;
    frame.size.height-=116;
    self.view.frame = frame;
    //self.view移回原位置
    UIView.animateWithDuration(animationDuration){
        self.view.frame = frame;
    }
    textField.resignFirstResponder();
    return true
}
</code></pre>

<p>```</p>

<p>这里我将键盘高度硬编码为116，当<code>UITextField</code>开始编辑时获取焦点键盘弹出，背景上移；当其结束编辑时键盘消失，背景移回原位。</p>

<p>在Xcode6 beta2中的模拟器不是很好使，经常不能弹出键盘，这里给出的代码有很多疏漏，只提供个参考，主要是处理<code>UITextField</code>代理的思想</p>

<h2>随机选择算法</h2>

<p><code>DetailViewController</code>的内容跟<code>MasterViewController</code>内容很像，最大的区别在于多了一个从<code>Choice</code>数据中随机抽选的一个方法。因为是通过摇一摇的方式来触发随机算法，所以我们重载<code>motionBegan(motion: UIEventSubtype, withEvent event: UIEvent!)</code>方法来响应手机摇动：</p>

<p>```
override func motionBegan(motion: UIEventSubtype, withEvent event: UIEvent!) {</p>

<pre><code>    if motion == .MotionShake{

        let count = self.fetchedResultsController.fetchedObjects.count
        var arr = fetchedResultsController.fetchedObjects
        var sum:Int = 0
        for object : AnyObject in arr{
            sum+=(object as Choice).weight.integerValue
        }
        if sum&gt;0{
            var lucknum = arc4random()%UInt32(sum)
</code></pre>

<p>//                println(&ldquo;(lucknum)&rdquo;)</p>

<pre><code>            var num = 0
            var n:UInt32 = 0
            while lucknum&gt;0{
                if lucknum &lt;= n{
                    break
                }
                else{
                    num++
                    lucknum-=n
                    if num&gt;=count{
                        break
                    }
                    n = UInt32((arr[num] as Choice).weight.integerValue)
                }
            }
</code></pre>

<p>//                println(&ldquo;(num)&rdquo;)</p>

<pre><code>            var alertView = UIAlertView()
            alertView.alertViewStyle = .Default
            alertView.title = "恭喜"
            alertView.message = "\(detailItem!.content)的答案是：\n\((arr[num] as Choice).name)"
            alertView.addButtonWithTitle("OK")
            alertView.show()
        }

    }
}
</code></pre>

<p>```</p>

<p>前面提到过<code>NSFetchedResultsController</code>对象在执行<code>performFetch(error: NSErrorPointer) -&gt; Bool</code>方法后会将获取的数据存在<code>fetchedObjects</code>数组中，上面这段代码首先获取该问题对应的选项数量，并通过加权运算得到总的权重，然后通过随机数算法生成一个幸运数字，最后计算幸运数字落在哪个选项上。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Core Data(2)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2/"/>
    <updated>2014-05-02T20:17:04+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/02/chu-shi-core-data-2</id>
    <content type="html"><![CDATA[<p>本文内容：</p>

<ul>
<li>自定义NSManagedObject</li>
<li>使用数据模型设计器</li>
<li>探究Core Data在SQLite中的实现</li>
</ul>


<p>推荐先阅读上一篇文章：<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">初识Core Data(1)</a></p>

<p><strong>文章所使用的项目代码可以到<a href="https://github.com/yulingtianxia/MyCDDemo">这里</a>下载</strong></p>

<p>在<a href="http://yulingtianxia.com/blog/2014/07/03/chu-shi-core-data-3/">下一篇文章</a>里，我将会通过教程的方式，讲述如何用Swift结合CoreData的NSFetchedResultsController写一个小Demo-<a href="https://github.com/yulingtianxia/HardChoice">HardChoice</a></p>

<!--more-->


<h2>自定义NSManagedObject</h2>

<p>在上一篇教程中我们每条数据都是通过<code>NSManagedObject</code>对象装载，通过KVC方式使用<code>valueForKey：</code>方法访问对象属性，但是使用KVC要比使用访问器效率低一点。 只在必要时使用KVC，比如你需要动态选择key或keyPath。</p>

<p><code>objc
[newEmployee setValue:@”Stig” forKey:firstName];
[aDepartment setValue:@1000 forKeyPath:manager.salary];
</code></p>

<p>下面我们将自定义<code>NSManagedObject</code>类，通过对它的继承拓展，使得我们有自己的Event类，并通过访问<a href="http://yulingtianxia.qiniudn.com/%E5%99%A8%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BFKVC%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E3%80%82  ">http://yulingtianxia.qiniudn.com/%E5%99%A8%E6%96%B9%E6%B3%95%E4%BB%A3%E6%9B%BFKVC%E6%96%B9%E5%BC%8F%E6%9D%A5%E8%AE%BF%E9%97%AE%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%B1%9E%E6%80%A7%E3%80%82  </a>
按CMD+N或者在可视化建模工具下选择菜单中Editor->Create NSManagedObject Subclass：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353399425.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353399917.png" alt="" /></p>

<p>选中需要子类化的Entity（当然我们只有一个Event，自动勾选了）：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353400261.png" alt="" /></p>

<p>最后点击Create，于是Event类就创建好了，可以看到属性timeStamp已经自动生成了，并且实现为<code>@dynamic</code></p>

<p>熟悉Objective-C语法的都知道<code>@synthesize</code>实际的意义就是自动生成属性的setter和getter方法。</p>

<p><code>@dynamic</code>就是要告诉编译器，代码中用<code>@dynamic</code>修饰的属性，其getter和setter方法会在程序运行的时候或者用其他方式动态绑定，以便让编译器通过编译。其主要的作用就是用在<code>NSManagerObject</code>对象的属性声明上，由于此类对象的属性一般是从Core Data的属性中生成的，Core Data框架会在程序运行的时候为此类属性生成getter和setter方法。</p>

<p>好的，下面我们改写以前的代码，这次我们将使用Event类的对象完成以前的任务：</p>

<p>在MasterViewController.m文件中加入<code>#import "Event.h"</code>，然后将<code>insertNewObject:</code>方法替换如下</p>

<p>```
&ndash; (void)insertNewObject:(id)sender
{</p>

<pre><code>NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
NSEntityDescription *entity = [[self.fetchedResultsController fetchRequest] entity];
Event *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];

// If appropriate, configure the new managed object.
// Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
</code></pre>

<p>//    [newManagedObject setValue:[NSDate date] forKey:@&ldquo;timeStamp&rdquo;];</p>

<pre><code>newManagedObject.timeStamp = [NSDate date];
// Save the context.
NSError *error = nil;
if (![context save:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}
</code></pre>

<p>}
<code>``
嗯，英文注释还告诉我们通常你应该用访问器方法呢，还说但是现在在这用KVC就避免了向模板添加自定义类的需求，真逗啊  
依此类推，更改</code>prepareForSegue: sender:`方法：</p>

<p>```
&ndash; (void)prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender
{</p>

<pre><code>if ([[segue identifier] isEqualToString:@"showDetail"]) {
    NSIndexPath *indexPath = [self.tableView indexPathForSelectedRow];
    Event *object = [[self fetchedResultsController] objectAtIndexPath:indexPath];
    [[segue destinationViewController] setDetailItem:object];
}
</code></pre>

<p>}
```</p>

<p>还有<code>configureCell: atIndexPath:</code>方法：</p>

<p>```
&ndash; (void)configureCell:(UITableViewCell <em>)cell atIndexPath:(NSIndexPath </em>)indexPath
{</p>

<pre><code>Event *object = [self.fetchedResultsController objectAtIndexPath:indexPath];
</code></pre>

<p>//    cell.textLabel.text = [[object valueForKey:@&ldquo;timeStamp&rdquo;] description];</p>

<pre><code>cell.textLabel.text = [object.timeStamp description];
</code></pre>

<p>}
<code>``
相应地我们也可以针对</code>DetailViewController`进行改造：</p>

<p>DetailViewController.h:</p>

<p>```</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@class Event;
@interface DetailViewController : UIViewController</p>

<p>@property (strong, nonatomic) Event *detailItem;</p>

<p>@property (weak, nonatomic) IBOutlet UILabel *detailDescriptionLabel;
@end
```</p>

<p>DetailViewController.m:</p>

<p>```</p>

<h1>import &ldquo;DetailViewController.h&rdquo;</h1>

<h1>import &ldquo;Event.h&rdquo;</h1>

<p>@interface DetailViewController ()
&ndash; (void)configureView;
@end</p>

<p>@implementation DetailViewController</p>

<h1>pragma mark &ndash; Managing the detail item</h1>

<ul>
<li><p>(void)setDetailItem:(Event *)newDetailItem
{
  if (<em>detailItem != newDetailItem) {
      </em>detailItem = newDetailItem;</p>

<pre><code>  // Update the view.
  [self configureView];
</code></pre>

<p>  }
}</p></li>
<li><p>(void)configureView
{
  // Update the user interface for the detail item.</p>

<p>  if (self.detailItem) {
//        self.detailDescriptionLabel.text = [[self.detailItem valueForKey:@&ldquo;timeStamp&rdquo;] description];
      self.detailDescriptionLabel.text = [self.detailItem.timeStamp description];
  }
}</p></li>
<li><p>(void)viewDidLoad
{
  [super viewDidLoad];
  // Do any additional setup after loading the view, typically from a nib.
  [self configureView];
}</p></li>
<li><p>(void)didReceiveMemoryWarning
{
  [super didReceiveMemoryWarning];
  // Dispose of any resources that can be recreated.
}</p></li>
</ul>


<p>@end
```
这部分比较简单，就不详细解释了，运行程序，跟以前一样（不截图了）</p>

<p>如果想复用<code>MasterViewController</code>里面那些代码，需要做些大改动，具体可以参看<a href="http://objccn.io/issue-1-1/">更轻量的 View Controllers</a>这篇文章</p>

<h2>使用数据模型设计器</h2>

<p>点击MyCDDemo.xcdatamodeld文件进入数据模型设计器，点击下方的加号（Add Enity），添加一个Enity，将其名字改为Person。然后添加name和sex属性，类型为string，需要注意的是属性名需要首字母小写，而且我们无需像往常给数据库建表一样为其添加ID字段，因为Core Data中你不需要任何类型的唯一标识Id，也不需要处理表连接。Core Data将在后台自动处理。你所需要做的就是定义对象间的关系。Core Data框架将在后台决定如何生成最佳的底层机制。</p>

<p>与实体名一样，属性的命名也有很多的要求和约定。属性名不能以大写字母开头，不能包含空格，一般都是单数。对于Boolean类型属性，你应该遵循Objective-C实例变量的约定,比如指定一个CustomerOrder对象是否已经发货，那么应该命名属性为shipped，而不是isShipped、hasShipped等。</p>

<p>关于Core Data属性类型，我从网上摘抄了一段比较全面的解释：</p>

<ul>
<li><p>Undefined选项值是新创建的属性的默认类型；如果属性类型为undefined，项目将无法通过编译。</p></li>
<li><p>Integer 16/32/64只表示整数，没有小数点。所以如果10除以3，你将会得到3，而余数1会丢失。Integer 16/32/64之间唯一的区别是所表示的数值范围不同。因为Core Data使用符号数，所以起始范围是负数，而不是0。</p>

<ul>
<li><p>Integer 16 数值范围：-32768~32767；</p></li>
<li><p>Integer 32 数值范围：-2147483648~2147483647；</p></li>
<li><p>Integer 64 数值范围：–9223372036854775808~9223372036854775807。</p></li>
</ul>


<p>  标准整型数的最大值和最小值可以在stdint.h中找到。在任何类文件中输入INT32_MAX,选中右击，然后选择Jump To Definition，你将看到许多最大值最小值定义。<strong>实体的属性的类型是Integer 16/32/64，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSNumber</strong>。</p></li>
<li><p>Double和Float可以认为是有小数部分的整数。它们都是基于二进制数值系统，在CPU运算时很可能会发生舍入误差。比如1/5，如果使用十进制数值系统，可以精确表示为0.2.但在二进制数值系统中，只能表示一个大概，在小数部分你会得到大量数字。<strong>所以不要使用Integer、Double、Float表示货币值。</strong>计算精度越高则越加趋于准确值，但内存占用也会越大。一个Float数使用32bit进行存储，一个Double数使用64bit。它们都使用科学计数法进行存储，所以一个数包含尾数和指数部分。</p>

<p>  在iOS中，最大的Float值是340282346638528859811704183484516925440.000000，最小的Float值是340282346638528859811704183484516925440.000000Double和Float都有一个符号位。而Double比Float的数值范围更大。</p>

<p>  当你决定该选择Float还是Double时，想一下你的属性是否真的需要超过Float提供的7位精度，如果不是，你应该选择Float，因为它更加匹配64bit的iPhone 5S底层处理器。除此之外，如果你想增加浮点数的计算速度而精度并没有严格要求，Float也是最佳选择。<strong>实体的属性的类型是Float或Double，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSNumber。</strong></p></li>
<li><p><strong>Decimal（十进制）是处理货币值和其他需要十进制场合下最佳选择</strong>，Decimal提供了优秀的计算精度，也消除了计算过程中的舍入误差。因为CPU的本地数制是二进制，所以CPU在处理十进制数时，开销会多一点。<strong>实体的属性的类型是Decimal，当创建此实体对应的NSManagedObject子类时，属性最终的类型将会是NSDecimalNumber。</strong>当你使用NSDecimalNumber执行计算时(如加减乘除计算)，为了保证计算精度，你只能使用它提供的内建方法。更多关于NSDecimalNumber可参见这里。</p></li>
<li><p>String类型和Objective-C中的NSString类似，用于保存字符数组。当生成实体对应的NSManagedObject子类时，String属性被表示为NSString。</p></li>
<li><p>Boolean数据类型被用于表示YES/NO值。当生成实体对应的NSManagedObject子类时，Boolean数据类型会被表示为NSNumber。所以为了获取布尔值，你需要想NSNumber对象发送boolValue消息。</p></li>
<li><p>Date类型是自解释类型。用来存储日期和时间。<strong>当生成实体对应的NSManagedObject子类时，Date类型会被表示为NSDate。</strong></p></li>
<li><p>Binary Data用来表示照片，音频，或一些BLOB类型数据(&ldquo;Binary Large OBjects&rdquo; such as image and sound data)。<strong>当生成实体对应的NSManagedObject子类时，Binary Data数据类型会被表示为NSData。</strong></p></li>
<li><p>Transformable属性类型用于存储一个Objective-C对象。该属性类型允许你存储任何类的实例，比如你使用Transformable属性表示UIColor。<strong>当生成NSManagedObject子类时，Transformable类型会被表示为id。</strong>对于id对象的保存和解档需要使用一个NSValueTransformer的实例或子类的实例。由该类负责属性值与NSData之间的转换。但这也相当的简单，尤其是当属性值的类型已经实现了NSCoding协议，此时系统会自动提供一个默认的NSValueTransformer实例来完成归档和解档。</p></li>
</ul>


<p><img src="http://yulingtianxia.qiniudn.com/140353400282.png" alt="" /></p>

<p>选择一个属性，在右侧的Data Model Inspector中可以对属性进行更为详细的设置，而且这些设置项会根据你所设置的属性类型不同而不同，大致分为以下几类：</p>

<ul>
<li>Transient（瞬时）选项表示属性不会存储到持久化存储文件中。Transient通常用在属性的值是由其他属性计算或合成而来（比如fullName属性是根据Persion类实例的firstName和lastName拼接而来）。</li>
<li>Optional（可选）选项表示当前属性的值允许为空。如果将属性指定为Optional，那么即使属性的值为空，实体的NSManagedObject实例也可被保存。如果该值是必选的（不选中Optional则为必选），如果属性值为空，NSManagedObject对象上下文将拒绝保存这个属性值不完整的NSManagedObject对象（当你尝试并保存上下文，你将接收到一个NSError对象）。所有的属性最初的状态都是Optinal。</li>
<li>Indexed选项表示底层的持久化存储文件应该为该属性生成一个索引；如果你使用基于多个属性的查询条件来提取对象，指定此类属性为Indexed，可以大幅提高提取速度。</li>
<li>Reg.Ex是Regular Expression的缩写，主要是用来验证属性值是否匹配特定的模式。此选项只对String类型有效。</li>
<li>Validation可以保证非法数据不被保存进持久化存储文件中。数值属性类型（Integer 16/32/64、Float、Double、Decimal）都有maximum和minimum最大值最小值设定。你也可以对String类型设置最大长度和最小长度。或对Date类型设置日期范围。不过最好的做法是当用户向UITextField中输入数据时就开始验证数据，而非等到向上下文发送save消息才验证数据。</li>
<li>除了Transformable和Binary Data类型以外，Default适用于所有属性类型。它被用来配置属性的默认值。</li>
<li>Allows External Storage允许大尺寸的二进制数据可以保存在持久化存储文件的外部。当你保存如照片，音频或视频时，建议是选中该选项， 这样Core Data就会对大于1MB的数据保存在持久化存储文件的外部。</li>
</ul>


<p>如果你细心的话，会发现无论是属性还是实体等选项，右侧的Data Model Inspector经常会出现User Info一栏。<br/>
在managed object model中很多元素，比如entities, attributes,和 relationships，有一个相关联的用户信息字典。你可以在用户信息字典中以键值对的形式放入你想要的任何信息。这里常用的信息有实体的版本详情，还有fetched property中谓词（predicate）用到的值。</p>

<p>说了一大堆，再添加两个实体吧：Teacher和Student，都继承自Person：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353400755.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353401739.png" alt="" /></p>

<p>点击右下方的Editor Style切换到Graph模式：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353401953.png" alt="" /></p>

<p>选中Teacher，长按Add Attribute会弹出所有的选项（同样你也可以试试长按Add Enity），选择Add Relationship，添加一个关系，命名为students，Type为To Many，目标为Student（一个老师教很多学生）：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353402308.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/14035340227.png" alt="" /></p>

<p>我们再尝试一种添加关系的新方法：把以前在Teacher中建立的students删除，选中Student，按住Ctrl，鼠标拖至Teacher，这样一个双向的关系就建立起来了：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353402879.png" alt="" /></p>

<p>分别编辑双方的关系，Tpye都是To Many：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353402596.png" alt="" /></p>

<p>用上一节中提到的方法，建立这三个新建的Entity的<code>NSManagedObject</code>子类：</p>

<p><img src="http://yulingtianxia.qiniudn.com/14035340286.png" alt="" /></p>

<p>因为创建顺序的问题，当Student创建的时候还不知道有<code>Teacher</code>类，于是其生成的一些方法将Teacher默认为<code>NSManagedObject</code>类：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<p>@interface Student : NSManagedObject</p>

<p>@property (nonatomic, retain) NSNumber * grade;
@property (nonatomic, retain) NSSet *teachers;
@end</p>

<p>@interface Student (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addTeachersObject:(NSManagedObject *)value;</li>
<li>(void)removeTeachersObject:(NSManagedObject *)value;</li>
<li>(void)addTeachers:(NSSet *)values;</li>
<li>(void)removeTeachers:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>而Teacher类创建的时候已经有了<code>Student</code>类，就不会出现上面的问题：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<p>@class Student;</p>

<p>@interface Teacher : NSManagedObject</p>

<p>@property (nonatomic, retain) NSString * course;
@property (nonatomic, retain) NSSet *students;
@end</p>

<p>@interface Teacher (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addStudentsObject:(Student *)value;</li>
<li>(void)removeStudentsObject:(Student *)value;</li>
<li>(void)addStudents:(NSSet *)values;</li>
<li>(void)removeStudents:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>虽然<code>Teacher</code>类认识<code>Student</code>类，因为它已经创建了，但是此时Persion类还没有创建，于是此时<code>Student</code>类和<code>Teacher</code>类继承的依然是<code>NSManagedObject</code>，这不是我们想要的结果。<br/>
解决方法是重新生成下这三个Entity对应的<code>NSManagedObject</code>子类，并覆盖原有的文件：</p>

<p>```</p>

<h1>import &lt;Foundation/Foundation.h></h1>

<h1>import &lt;CoreData/CoreData.h></h1>

<h1>import &ldquo;Person.h&rdquo;</h1>

<p>@class Teacher;</p>

<p>@interface Student : Person</p>

<p>@property (nonatomic, retain) NSNumber * grade;
@property (nonatomic, retain) NSSet *teachers;
@end</p>

<p>@interface Student (CoreDataGeneratedAccessors)</p>

<ul>
<li>(void)addTeachersObject:(Teacher *)value;</li>
<li>(void)removeTeachersObject:(Teacher *)value;</li>
<li>(void)addTeachers:(NSSet *)values;</li>
<li>(void)removeTeachers:(NSSet *)values;</li>
</ul>


<p>@end
```</p>

<p>你会发现多了一个<code>CoreDataGeneratedAccessors</code>类别，这个类别中的方法是Core Data框架根据你在数据模式编辑器中设置的实体关系自动生成的，你不需要实现它们，Core Data会在运行时实现这些方法<br/>
如果你偏要想看看其实现机理，在右下方的代码片段库中选择“Core Data To-Many Relationship Accessors”并拖拽到代码中</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353403195.png" alt="" /></p>

<p>生成的代码如下：</p>

<p>```
&ndash; (void)add&lt;#CapitalizedRelationshipName#>Object:(&lt;#relationship destination class#> *)value
{</p>

<pre><code>NSSet *changedObjects = [NSSet setWithObject:value];
[self willChangeValueForKey:@"&lt;#relationshipName#&gt;" withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects];
[[self primitiveValueForKey:@"&lt;#relationshipName#&gt;"] addObject:value];
[self didChangeValueForKey:@"&lt;#relationshipName#&gt;" withSetMutation:NSKeyValueUnionSetMutation usingObjects:changedObjects];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)remove&lt;#CapitalizedRelationshipName#>Object:(&lt;#relationship destination class#> <em>)value
{
  NSSet </em>changedObjects = [NSSet setWithObject:value];
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] removeObject:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:changedObjects];
}</p></li>
<li><p>(void)add&lt;#CapitalizedRelationshipName#>:(NSSet *)value
{  <br/>
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueUnionSetMutation usingObjects:value];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] unionSet:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueUnionSetMutation usingObjects:value];
}</p></li>
<li><p>(void)remove&lt;#CapitalizedRelationshipName#>:(NSSet *)value
{
  [self willChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:value];
  [[self primitiveValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo;] minusSet:value];
  [self didChangeValueForKey:@&ldquo;&lt;#relationshipName#>&rdquo; withSetMutation:NSKeyValueMinusSetMutation usingObjects:value];
}
```</p></li>
</ul>


<p>我们需要将&lt;#Capitalized relationship name#>, &lt;#Relationship destination class#> 和 &lt;#Relationship name#>替换为我们定义的连接名，对照下前面<code>CoreDataGeneratedAccessors</code>类别中的方法名，你就会明白了</p>

<p>同样以前标记为<code>@dynamic</code>的属性，其实现原理如下：</p>

<p>```
&ndash; (&lt;#propertyObjectType#> *)&lt;#propertyName#>
{</p>

<pre><code>[self willAccessValueForKey:@"&lt;#propertyName#&gt;"];
&lt;#propertyObjectType#&gt; *value = [self primitiveValueForKey:@"&lt;#propertyName#&gt;"];
[self didAccessValueForKey:@"&lt;#propertyName#&gt;"];
return value;
</code></pre>

<p>}</p>

<ul>
<li>(void)set&lt;#CapitalizedPropertyName#>:(&lt;#propertyObjectType#> *)value
{
  [self willChangeValueForKey:@&ldquo;&lt;#propertyName#>&rdquo;];
  [self setPrimitiveValue:value forKey:@&ldquo;&lt;#propertyName#>&rdquo;];
  [self didChangeValueForKey:@&ldquo;&lt;#propertyName#>&rdquo;];
}
```
现在，我们并不需要知道他们的实现方法是如何被动态生成的，估计是用到了block或者delegate。</li>
</ul>


<h2>探究Core Data在SQLite中的实现</h2>

<p>在上一节中我们创建了<code>Person</code>，<code>Teacher</code>和<code>Student</code>三个Entity和对应的<code>NSManagedObject</code>子类，下面我们需要在代码中对其进行“实战部署”，并观察它们是如何在SQLite数据库中保存的，这样更有利于理解Core Data机制。</p>

<p>为了简单测试，我直接在MasterViewController.m文件中的<code>insertNewObject:</code>方法中加入测试代码（其实关于测试应该利用好Xcode自带的单元测试工具<a href="http://yulingtianxia.com/blog/2014/04/28/iosdan-yuan-ce-shi-%5Bnil%5Dxctest/">XCTest</a>，我这里为了方便操作，用了以前添加数据的<code>insertNewObject:</code>方法，关于工程初始代码的讲解，请看我之前的一篇<a href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/">教程</a>）</p>

<p>```
&ndash; (void)insertNewObject:(id)sender
{</p>

<pre><code>NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
NSEntityDescription *entity = [[self.fetchedResultsController fetchRequest] entity];
Event *newManagedObject = [NSEntityDescription insertNewObjectForEntityForName:[entity name] inManagedObjectContext:context];

// If appropriate, configure the new managed object.
// Normally you should use accessor methods, but using KVC here avoids the need to add a custom class to the template.
</code></pre>

<p>//    [newManagedObject setValue:[NSDate date] forKey:@&ldquo;timeStamp&rdquo;];</p>

<pre><code>newManagedObject.timeStamp = [NSDate date];
//新加的测试代码
Student *aStudent = [NSEntityDescription insertNewObjectForEntityForName:@"Student" inManagedObjectContext:context];
aStudent.name = @"LiLei";
aStudent.sex = @"male";
aStudent.grade = @1;
Teacher *aTeacher = [NSEntityDescription insertNewObjectForEntityForName:@"Teacher" inManagedObjectContext:context];
aTeacher.name = @"MissGao";
aTeacher.sex = @"female";
aTeacher.course = @"English";
[aTeacher addStudentsObject:aStudent];


// Save the context.
NSError *error = nil;
if (![context save:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}
</code></pre>

<p>}
```</p>

<p>我们建立了一名叫LiLei的一年级男生和一名叫MissGao的教英语的女教师，并将LiLei同学添加到高老师的学生名单中。</p>

<p>运行程序，打开MyCDDemo.sqlite文件，查看表结构：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353403982.png" alt="" /></p>

<p>你会发现虽然Student和Teacher继承Person，但是Person表里面竟然也有grade和course字段</p>

<p>点击程序中的加号来添加一条数据：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353403912.png" alt="" /></p>

<p>查看ZPERSON，Z_3TEACHERS，Z_PRIMARYKEY表内容：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353404264.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353404745.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353405697.png" alt="" /></p>

<p>这次一目了然了：</p>

<p>ZPERSON表存储了子类所有字段数据，其Z_ENT字段标志着这条数据的类型，Z_ENT与类型名Z_NAME的映射关系储存在Z_PRIMARYKEY表中，而Z_3TEACHERS存储的则是ZPERSON表中数据项之间的关系，也就是之前我们建立的学生和老师的对应关系，其原理是将ZPERSON表中的Z_PK字段内容两个一组对应起来，这样就相当于把ZPERSON表中两条数据项关联起来了。之前我们在代码中只将LiLei同学添加到了MissGao老师的学生列表中，但是Core Data已经自动维护起了关系，让MissGao也存在于LiLei的老师列表中。Core Data把底层的数据库封装起来，通过简单的操作让程序员更高校的管理数据，所以SQLite这部分我们只是了解下就可以了。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[初识Core Data(1)]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1/"/>
    <updated>2014-05-01T19:58:00+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/01/chu-shi-core-data-1</id>
    <content type="html"><![CDATA[<p>本文内容：</p>

<ul>
<li>Core Data概述</li>
<li>新建一个Core Data工程</li>
<li>总结</li>
</ul>


<hr />

<!--more-->


<h2>Core Data概述</h2>

<p>Core Data本身既不是数据库也不是数据库访问框架。相反，Core Data是一个完整的数据模型解决方案。我简单理解为对持久层的封装，使得我们可以通过可视化建立数据模型，简化数据存取。有人会联想到Hibernate，其实Core Data比Hibernate强大得多，它不仅支持SQLite数据库，还能对XML文件、二进制文件、用户自定义文件进行操作。</p>

<p>即使不懂SQL语句，也依然可以使用Core Data。因为Core Data将底层的数据库SQL语句封装成了一套API，并可通过可视化操作来建立数据库的模型和表之间的关系，它甚至在数据变化时会帮你自动处理关系（比如删除了一门课程，所有选这门课程的学生也会自动解除与此门课程的关系），Core Data还能对非法数据进行过滤，还支持对数据操作的Undo/Redo功能。更重要的是，Core Data的<code>NSFetchRequest</code>类可以替代SQL中的Select语句，并提供了更高效的方法将查询结果显示在UITableView中。</p>

<p>iOS 3.0和Mac OS X10.5都支持Core Data，但iOS上不支持XML文件存储。Core Data对读取性能做了大量优化，其中惰性加载（Faulting）就是一个例子，毕竟设备的内存是有限切珍贵的。<br/>
在OSX上可以绑定利用KVO和KVC保持UI项与模型对象或属性之间的连接，无需编写任何代码，通过对象和数组控制器自动从Core Data存储区分批提取<code>NSManagedObject</code>对象。这就像在VS中用.Net构建基于SQLServer的桌面程序。<br/>
苹果公司单独为iOS平台的Core Data引入了<code>NSFetchedResultsController</code>类帮助视图与从持久化存储文件提取的数据之间的交互。它主要是用来充当<code>UITableiView</code>的数据源，负责调整<code>UITableiView</code>行与节（section）的显示数目，以及为各表格行提供内容。</p>

<h2>新建一个Core Data工程</h2>

<p>在Xcode5中，只有Master-Detail Application，Utility Application以及Empty Application支持创建时使用Core Data模板，我们选择带有UITableView的Master-Detail Application吧。</p>

<p><img src="http://yulingtianxia.qiniudn.com/14035339677.png" alt="" /></p>

<p>一定要勾选Core Data选项，项目名称就叫MyCDDemo吧，嘿嘿</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353396978.png" alt="" /></p>

<p>项目建立后会发现Frameworks中已经有了<code>CoreData.framework</code>一项，并且还多了一个MyCDDemo.xcdatamodeld文件，该文件定义了数据模型结构，你可以使用XCode内置的可视化建模工具进行构建。点开它你会发现左侧有三项：Entities，Fetch Request、Configurations。</p>

<p><strong>Entities</strong></p>

<p>在系统的学习Core Data前，可以简单的将Entity理解为数据库中的一张表，在代码中一个<code>NSEntityDescription</code>类的对象就代表了一个Entity。Entity也像类一样可以继承，如果你有若干个相似的实体，就可以抽离出它们的共有特性作为一个“父实体”，就省去了在多个实体中都指定相同的属性。甚至可以勾选Abstract Entitiy让其成为抽象实体，就像抽象类一样。</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353414584.png" alt="" /></p>

<p>现在已经有了一个现成的实体：Event，也就是在SQLite中有了一张叫做Event的表：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353397403.png" alt="" /></p>

<p>Attributes就相当于一张表的列属性，可以设置其数据类型，默认值，最大最小值等，类似数据库可视化建表。需要注意的是这里的空值是NULL，不等同于OC中的nil，更不等同于0和空字符串@“”。Event实体中已经有了一个叫timeStamp的属性，类型为Date，这是模版自动生成的，暂且别修改它。</p>

<p>Relationships描述了Entity间的关系：多对一，一对一等。当你指定了一个关系后，苹果推荐我们也指定一个反转关系。比如A和B是多对多的关系，那么A指向B的关系Type为To Many，同时设定B指向A的关系Type为To Many。</p>

<p>Fetched Property表示了一种弱的、单向的关系。因为Core Data不支持在persistent store之间建立Relationships，所以Fetched Property可用于建立cross-store关系，还用于建立“松耦合”关系，相似暂时的分组。（a fetched property of a department might be &ldquo;recent hires&rdquo; (employees do not have an inverse to the recent hires relationship)）</p>

<p><strong>Fetch Request</strong></p>

<p>我们使用<code>NSFetchRequest</code>类来描述数据请求，利用数据请求从持久存储（persistent store）中获取对象。经常碰到的情形是你经常需要多次执行同样的请求，或是执行遵循一个给定模式的请求，但是其中包含变量（如查找条件）——这些变量经常由用户提供。例如，在运行程序的时候，你要根据用户需要获取某个作者在用户指定日期后出版的所有出版物。</p>

<p>你可以预定义请求，把它们作为模板存储在被管理对象模型中。预定义的模板在你需要的时候就可以取出使用。通常情况下，我们通过Xcode的data modeling tool工具创建请求模板。模板可以包含变量：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353412465.png" alt="" /></p>

<p><strong>Configurations</strong></p>

<p>配置包含了一个名称和若干个相关的实体。实体的集合是可以重叠的——这就是说，一个实体可以出现在多个配置中。在代码中，我们使用<code>setEntities: forConfiguration:</code>的方法来指定配置。也可以用Xcode的建模工具来指定。要获取某项配置的实体，需要用<code>entitiesForConfiguration:</code>的方法。</p>

<p>一般说来，如果你想把不同的实体存放在不同的存储中去，就可能用到配置。一个持久化存储协调器（persistent store coordinator，你暂且理解为负责数据库连接的东东）只能有一个被管理对象模型（managed object model，也就是把xcdatamodeld文件加载到代码中的内容啦）。所以，默认情况下，和协调器关联的某个存储必须包含同样的实体。要想绕过这个限制，你可以创建一个包含所有实体并集的模型，然后在模型中为每一个你想使用的实体子集创建配置，这样一来，使用这个模型创建协调器，当你需要添加存储（persistent store）时，可根据不同的配置来指定对应的存储属性。当你创建配置的时候，需要记住，不能创建跨存储的关系（cross-store relationships）。</p>

<p>模版已经生成了一个叫Default的配置，但是在程序中并没有用到它（这在之后的内容会阐述）。</p>

<p>在了解了xcdatamodeld类型文件之后，你可能对Core Data如何描述一个数据库有了一定的概念，下一步我们准备阅读模版自动生成的代码，你会体会到xcdatamodeld文件在程序中是如何被加载和使用的。</p>

<p>先看看AppDelegate.h</p>

<p>``` objc</p>

<h1>import &lt;UIKit/UIKit.h></h1>

<p>@interface AppDelegate : UIResponder <UIApplicationDelegate></p>

<p>@property (strong, nonatomic) UIWindow *window;</p>

<p>@property (readonly, strong, nonatomic) NSManagedObjectContext <em>managedObjectContext;
@property (readonly, strong, nonatomic) NSManagedObjectModel </em>managedObjectModel;
@property (readonly, strong, nonatomic) NSPersistentStoreCoordinator *persistentStoreCoordinator;</p>

<ul>
<li>(void)saveContext;</li>
<li>(NSURL *)applicationDocumentsDirectory;</li>
</ul>


<p>@end
```
嗯，比平时的程序多出了三个属性嘛，而且后两个属性之前还提到过，这“三剑客“是Core Data中非常重要的三个类：</p>

<ul>
<li>Managed Object Model（管理数据模型）: 你可以将这个东西看作是数据库的轮廓，或者结构。这里包含了各个实体的定义信息，一般来说，你会使用我们刚刚看过的视觉编辑器来操作这个物体，添加属性，建立属性之间的关系等等，当然你也可以使用代码。</li>
<li>Persistent Store Coordinator （持久性数据协调器）： 你可以将这个东西看作是数据库连接库，在这里，你将设置数据存储的名字和位置，以及数据存储的时机。</li>
<li>Managed Object Context （管理数据内容）：你可以将这一部分看作是数据的实际内容，这也是整个数据库中对我们而言最重要的部分（这还用说），基本上，插入数据，查询数据，删除数据的工作都在这里完成。</li>
</ul>


<p>如果你还是不好理解，那么简单的把这“三剑客”理解为：数据定义语言 (DDL)、数据库连接（DBC）、数据操作语言 (DML)在Core Data中的另一种存在吧！</p>

<p>下面该看看AppDelegate.m，了解下“三剑客”实例化的过程：
首先是程序加载完毕的代理方法：</p>

<p>```
&ndash; (BOOL)application:(UIApplication <em>)application didFinishLaunchingWithOptions:(NSDictionary </em>)launchOptions
{</p>

<pre><code>// Override point for customization after application launch.
UINavigationController *navigationController = (UINavigationController *)self.window.rootViewController;
MasterViewController *controller = (MasterViewController *)navigationController.topViewController;
controller.managedObjectContext = self.managedObjectContext;
return YES;
</code></pre>

<p>}
<code>``
我们暂且只看</code>controller.managedObjectContext = self.managedObjectContext;<code>这句，调用</code>managedObjectContext<code>的getter方法并赋给程序启动后出现的</code>MasterViewController<code>，那么我们就看一下</code>managedObjectContext`的getter方法：</p>

<p>```
// Returns the managed object context for the application.
// If the context doesn&rsquo;t already exist, it is created and bound to the persistent store coordinator for the application.
&ndash; (NSManagedObjectContext *)managedObjectContext
{</p>

<pre><code>if (_managedObjectContext != nil) {
    return _managedObjectContext;
}

NSPersistentStoreCoordinator *coordinator = [self persistentStoreCoordinator];
if (coordinator != nil) {
    _managedObjectContext = [[NSManagedObjectContext alloc] init];
    [_managedObjectContext setPersistentStoreCoordinator:coordinator];
}
return _managedObjectContext;
</code></pre>

<p>}
```</p>

<p>嗯，英文注释不错，第一次调用的时候会实例化一个<code>NSManagedObjectContext</code>对象，并使用<code>persistentStoreCoordinator</code>方法返回的<code>NSPersistentStoreCoordinator</code>对象配置上下文，最后返回新实例化的<code>NSManagedObjectContext</code>对象。<br/>
顺藤摸瓜，我们再看看<code>persistentStoreCoordinator</code>的getter：</p>

<p>```
// Returns the persistent store coordinator for the application.
// If the coordinator doesn&rsquo;t already exist, it is created and the application&rsquo;s store added to it.
&ndash; (NSPersistentStoreCoordinator *)persistentStoreCoordinator
{</p>

<pre><code>if (_persistentStoreCoordinator != nil) {
    return _persistentStoreCoordinator;
}

NSURL *storeURL = [[self applicationDocumentsDirectory] URLByAppendingPathComponent:@"MyCDDemo.sqlite"];

NSError *error = nil;
_persistentStoreCoordinator = [[NSPersistentStoreCoordinator alloc] initWithManagedObjectModel:[self managedObjectModel]];
if (![_persistentStoreCoordinator addPersistentStoreWithType:NSSQLiteStoreType configuration:nil URL:storeURL options:nil error:&amp;error]) {
    /*
     Replace this implementation with code to handle the error appropriately.

     abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 

     Typical reasons for an error here include:
     * The persistent store is not accessible;
     * The schema for the persistent store is incompatible with current managed object model.
     Check the error message to determine what the actual problem was.


     If the persistent store is not accessible, there is typically something wrong with the file path. Often, a file URL is pointing into the application's resources directory instead of a writeable directory.

     If you encounter schema incompatibility errors during development, you can reduce their frequency by:
     * Simply deleting the existing store:
     [[NSFileManager defaultManager] removeItemAtURL:storeURL error:nil]

     * Performing automatic lightweight migration by passing the following dictionary as the options parameter:
     @{NSMigratePersistentStoresAutomaticallyOption:@YES, NSInferMappingModelAutomaticallyOption:@YES}

     Lightweight migration will only work for a limited set of schema changes; consult "Core Data Model Versioning and Data Migration Programming Guide" for details.

     */
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}    

return _persistentStoreCoordinator;
</code></pre>

<p>}
<code>``
为了访问documents目录中的SQLite存储文件MyCDDemo.sqlite，还定义了一个</code>applicationDocumentsDirectory`方法，它的作用是获取程序documents的路径，代码如下：</p>

<p>```
// Returns the URL to the application&rsquo;s Documents directory.
&ndash; (NSURL *)applicationDocumentsDirectory
{</p>

<pre><code>return [[[NSFileManager defaultManager] URLsForDirectory:NSDocumentDirectory inDomains:NSUserDomainMask] lastObject];
</code></pre>

<p>}
<code>``
MyCDDemo.sqlite文件是在编译MyCDDemo.xcdatamodeld时生成的，同样生成的还有MyCDDemo.momd文件，后面会提到。
</code>NSPersistentStoreCoordinator<code>初始化时需要传入</code>managedObjectModel<code>。</code>NSPersistentStoreCoordinator<code>对象在添加持久存储的时候不仅需要传入存储类型，还有配置，存储文件URL，选项以及错误类型。我们使用sqlite作为存储类型，配置为nil，还记得之前叫做default的配置么？这里我们只有一个持久存储，所以配置一项不需要。如果添加存储的时候出现错误，就会进入if判断，具体处理错误的细节可以看看模版生成的注释。  
既然</code>NSPersistentStoreCoordinator<code>又用到了</code>managedObjectModel<code>，我们再看看</code>managedObjectModel`方法吧：</p>

<p>```
// Returns the managed object model for the application.
// If the model doesn&rsquo;t already exist, it is created from the application&rsquo;s model.
&ndash; (NSManagedObjectModel *)managedObjectModel
{</p>

<pre><code>if (_managedObjectModel != nil) {
    return _managedObjectModel;
}
NSURL *modelURL = [[NSBundle mainBundle] URLForResource:@"MyCDDemo" withExtension:@"momd"];
_managedObjectModel = [[NSManagedObjectModel alloc] initWithContentsOfURL:modelURL];
return _managedObjectModel;
</code></pre>

<p>}
<code>``
依然是跟之前一样的代码风格，这次</code>NSManagedObjectModel`类在初始化的时候用到了MyCDDemo.momd文件，前面提到过，当你编译项目时，MyCDDemo.xcdatamodeld数据模型将被编译成MyCDDemo.momd资源，并且保存到app的Bundle目录。</p>

<p>最后，在程序退出时，会调用代理<code>applicationWillTerminate:</code></p>

<p>```
&ndash; (void)applicationWillTerminate:(UIApplication *)application
{</p>

<pre><code>// Saves changes in the application's managed object context before the application terminates.
[self saveContext];
</code></pre>

<p>}
<code>``
它调用了</code>saveContext`方法：</p>

<p>```
&ndash; (void)saveContext
{</p>

<pre><code>NSError *error = nil;
NSManagedObjectContext *managedObjectContext = self.managedObjectContext;
if (managedObjectContext != nil) {
    if ([managedObjectContext hasChanges] &amp;&amp; ![managedObjectContext save:&amp;error]) {
         // Replace this implementation with code to handle the error appropriately.
         // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
        NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
        abort();
    } 
}
</code></pre>

<p>}
<code>``
</code>managedObjectContext<code>对象中的数据无论怎么修改，都是发生在内存中的，需要调用</code>save`方法来保存到存储文件当中。</p>

<p>按理说接下来应该看看<code>MasterViewController中</code>被传入的<code>managedObjectContext</code>对象是如何使用的，但在这之前，我们先运行下程序，看看这个App有什么功能：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353397837.png" alt="" /></p>

<p>再普通不过的tableview了，点击加号便可添加一条记录，内容为时间戳，回想起之前看的名称为Event的Entity，是不是想起了什么，嘿嘿。再添加了四条记录后，不妨打开sqlite文件查看下，路径为<code>~/Library/Application Support/iPhone Simulator/[OS version]/Applications/[appGUID]/Documents/</code>，目录内包含了三个文件MyCDDemo.sqlite、MyCDDemo.sqlite-shm、MyCDDemo.sqlite-wal。如上文所述，根据AppDelegate.m文件中的<code>persistentStoreCoordinator</code>方法可知，时间戳记录被存储在MyCDDemo.sqlite文件中。我用Navicat Premium将其打开：</p>

<p><img src="http://yulingtianxia.qiniudn.com/14035339876.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353398727.png" alt="" /></p>

<p>相信你对“三剑客”有了更深的理解，再附上一张图加深下印象：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353388879.png" alt="" /></p>

<p>一个<code>NSManagedObjectModel</code>对象处在<code>NSPersistentStoreCoordinator</code>对象和<code>NSManagedObjectContext</code>对象之间。Core Data根据<code>NSManagedObjectModel</code>对象确定如何将底层的持久化文件中的数据映射为<code>NSManagedObject</code>对象。一个<code>NSManagedObjectModel</code>对象用于表示数据的结构。<code>NSManagedObjectModel</code>对象也被称为对象图(object graph)。你可以简单的理解为：<strong>在数据库sqlite文件中，一张表中的一条数据（table row）就相当于代码中的一个NSManagedObject对象，他们之间的映射是通过<code>NSManagedObjectModel</code>对象完成的</strong></p>

<p>下面让我们进入到<code>MasterViewController</code>中来认识一下这个新出现的<code>NSManagedObject</code>“小弟”</p>

<p>既然数据库中的数据最终显示在了<code>UITableView</code>上，我们撇开<code>MasterViewController</code>中其他的方法，直奔<code>UITableViewDataSource</code>协议中已经实现的那几个方法：</p>

<p>```
&ndash; (NSInteger)numberOfSectionsInTableView:(UITableView *)tableView
{</p>

<pre><code>return [[self.fetchedResultsController sections] count];
</code></pre>

<p>}</p>

<ul>
<li><p>(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section
{
  id <NSFetchedResultsSectionInfo> sectionInfo = [self.fetchedResultsController sections][section];
  return [sectionInfo numberOfObjects];
}</p></li>
<li><p>(UITableViewCell <em>)tableView:(UITableView </em>)tableView cellForRowAtIndexPath:(NSIndexPath <em>)indexPath
{
  UITableViewCell </em>cell = [tableView dequeueReusableCellWithIdentifier:@&ldquo;Cell&rdquo; forIndexPath:indexPath];
  [self configureCell:cell atIndexPath:indexPath];
  return cell;
}</p></li>
<li><p>(BOOL)tableView:(UITableView <em>)tableView canEditRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  // Return NO if you do not want the specified item to be editable.
  return YES;
}</p></li>
<li><p>(void)tableView:(UITableView <em>)tableView commitEditingStyle:(UITableViewCellEditingStyle)editingStyle forRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  if (editingStyle == UITableViewCellEditingStyleDelete) {
      NSManagedObjectContext *context = [self.fetchedResultsController managedObjectContext];
      [context deleteObject:[self.fetchedResultsController objectAtIndexPath:indexPath]];</p>

<pre><code>  NSError *error = nil;
  if (![context save:&amp;error]) {
       // Replace this implementation with code to handle the error appropriately.
       // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
      NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
      abort();
  }
</code></pre>

<p>  } <br/>
}</p></li>
<li><p>(BOOL)tableView:(UITableView <em>)tableView canMoveRowAtIndexPath:(NSIndexPath </em>)indexPath
{
  // The table view should not be re-orderable.
  return NO;
}
```</p></li>
</ul>


<p>如果你对<code>UITableView</code>的使用很有经验，一眼就可看出数据是由<code>fetchedResultsController</code>对象提供的。即使在<code>tableView: cellForRowAtIndexPath:</code>方法中没出现<code>fetchedResultsController</code>，但是在其调用的<code>configureCell: atIndexPath:</code>方法中依然用到了<code>fetchedResultsController</code>：</p>

<p>```
&ndash; (void)configureCell:(UITableViewCell <em>)cell atIndexPath:(NSIndexPath </em>)indexPath
{</p>

<pre><code>NSManagedObject *object = [self.fetchedResultsController objectAtIndexPath:indexPath];
cell.textLabel.text = [[object valueForKey:@"timeStamp"] description];
</code></pre>

<p>}
```
嗯看来NSManagedObject对象全都由这个fetchedResultsController提供咯，下面揭开它神秘的面纱：</p>

<p>```
&ndash; (NSFetchedResultsController *)fetchedResultsController
{</p>

<pre><code>if (_fetchedResultsController != nil) {
    return _fetchedResultsController;
}

NSFetchRequest *fetchRequest = [[NSFetchRequest alloc] init];
// Edit the entity name as appropriate.
NSEntityDescription *entity = [NSEntityDescription entityForName:@"Event" inManagedObjectContext:self.managedObjectContext];
[fetchRequest setEntity:entity];

// Set the batch size to a suitable number.
[fetchRequest setFetchBatchSize:20];

// Edit the sort key as appropriate.
NSSortDescriptor *sortDescriptor = [[NSSortDescriptor alloc] initWithKey:@"timeStamp" ascending:NO];
NSArray *sortDescriptors = @[sortDescriptor];

[fetchRequest setSortDescriptors:sortDescriptors];

// Edit the section name key path and cache name if appropriate.
// nil for section name key path means "no sections".
NSFetchedResultsController *aFetchedResultsController = [[NSFetchedResultsController alloc] initWithFetchRequest:fetchRequest managedObjectContext:self.managedObjectContext sectionNameKeyPath:nil cacheName:@"Master"];
aFetchedResultsController.delegate = self;
self.fetchedResultsController = aFetchedResultsController;

NSError *error = nil;
if (![self.fetchedResultsController performFetch:&amp;error]) {
     // Replace this implementation with code to handle the error appropriately.
     // abort() causes the application to generate a crash log and terminate. You should not use this function in a shipping application, although it may be useful during development. 
    NSLog(@"Unresolved error %@, %@", error, [error userInfo]);
    abort();
}

return _fetchedResultsController;
</code></pre>

<p>}
```</p>

<p>嗯，之前提到过，Core Data在iOS平台使用了<code>NSFetchedResultsController</code>对象来简化对提取结果和表格视图的处理。<code>NSFetchedResultsController</code>对象被惰性创建并只在表格视图数据源方法有需要时才提取数据。你会看到在<code>NSFetchRequest</code>对象的配置中，使用了Event实体，并提供了一个<code>NSSortDescriptor</code>对象以让提取结果按timeStamp进行排序。最后通过<code>NSFetchRequest</code>对象和<code>managedObjectContext</code>（在AppDelegate中传入的<code>NSManagedObjectContext</code>实例）作为参数传入<code>NSFetchedResultsController</code>的初始化方法。（<code>sectionNameKeyPath</code>参数传入nil时表示只有一个section，你会发现<code>NSFetchedResultsController</code>从数据库获取的结果跟<code>UITableView</code>需要的数据格式相同，都通过<code>NSIndexPath</code>地址来获取一条数据的内容）<br/>
<code>NSFetchedResultsController</code>也有它的代理，将<code>MasterViewController</code>设置为其代理，这样在fetched results 发生变化时，<code>MasterViewController</code>中实现的<code>NSFetchedResultsControllerDelegate</code>方法会被调用：</p>

<p>```
&ndash; (void)controllerWillChangeContent:(NSFetchedResultsController *)controller
{</p>

<pre><code>[self.tableView beginUpdates];
</code></pre>

<p>}</p>

<ul>
<li><p>(void)controller:(NSFetchedResultsController *)controller didChangeSection:(id <NSFetchedResultsSectionInfo>)sectionInfo
         atIndex:(NSUInteger)sectionIndex forChangeType:(NSFetchedResultsChangeType)type
{
  switch(type) {
      case NSFetchedResultsChangeInsert:
          [self.tableView insertSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade];
          break;</p>

<pre><code>  case NSFetchedResultsChangeDelete:
      [self.tableView deleteSections:[NSIndexSet indexSetWithIndex:sectionIndex] withRowAnimation:UITableViewRowAnimationFade];
      break;
</code></pre>

<p>  }
}</p></li>
<li><p>(void)controller:(NSFetchedResultsController <em>)controller didChangeObject:(id)anObject
     atIndexPath:(NSIndexPath </em>)indexPath forChangeType:(NSFetchedResultsChangeType)type
    newIndexPath:(NSIndexPath <em>)newIndexPath
{
  UITableView </em>tableView = self.tableView;</p>

<p>  switch(type) {
      case NSFetchedResultsChangeInsert:
          [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
          break;</p>

<pre><code>  case NSFetchedResultsChangeDelete:
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      break;

  case NSFetchedResultsChangeUpdate:
      [self configureCell:[tableView cellForRowAtIndexPath:indexPath] atIndexPath:indexPath];
      break;

  case NSFetchedResultsChangeMove:
      [tableView deleteRowsAtIndexPaths:@[indexPath] withRowAnimation:UITableViewRowAnimationFade];
      [tableView insertRowsAtIndexPaths:@[newIndexPath] withRowAnimation:UITableViewRowAnimationFade];
      break;
</code></pre>

<p>  }
}</p></li>
<li><p>(void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
  [self.tableView endUpdates];
}</p></li>
</ul>


<p>/*
// Implementing the above methods to update the table view in response to individual changes may have performance implications if a large number of changes are made simultaneously. If this proves to be an issue, you can instead just implement controllerDidChangeContent: which notifies the delegate that all section and object changes have been processed.</p>

<ul>
<li>(void)controllerDidChangeContent:(NSFetchedResultsController *)controller
{
 // In the simplest, most efficient, case, reload the table view.
 [self.tableView reloadData];
}</li>
</ul>


<p>```</p>

<p>相对于之前<code>UITableViewDataSource</code>协议方法对<code>NSFetchedResultsController</code>对象中数据的修改（通过<code>NSManagedObject</code>对象做载体），<code>NSFetchedResultsControllerDelegate</code>协议方法会在察觉到数据修改后被调用，用于产生tableview操作数据后对应的动画效果。</p>

<p>可能你会觉得有些混乱，这里贴上几张图梳理下各个类的关系和结构：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353388301.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353389167.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353388423.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353389646.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353389047.png" alt="" /></p>

<p><img src="http://yulingtianxia.qiniudn.com/140353388523.jpg" alt="" /></p>

<p>最后，找到<code>insertNewObject</code>方法，当用户尝试加入一个对象到表视图时，该方法将被调用。接着你将看到如下的处理过程：</p>

<ul>
<li>获得一个<code>NSManagedObjectContext</code>对象；</li>
<li>决定创建新对象的实体；</li>
<li>根据实体名称创建一个新的<code>NSManagedObject</code>对象并将其插入到<code>NSManagedObjectContext</code>对象；</li>
<li>对新创建的<code>NSManagedObject</code>对象设置timeStamp属性值</li>
<li><code>NSManagedObjectContext</code>对象执行保存。</li>
</ul>


<p>当上下文执行保存，新的对象将被写到持久存储区中。这是如此简单！</p>

<p>DetailViewController的内容比较简单，不在叙述，到此结束，新建Core Data的模版工程代码已经解析完毕了。在下一期文章中将会亲手修改代码，探索Core Data更多的使用技巧。</p>

<h2>总结</h2>

<p>Core Data框架基本的5个类：：NSPersistentStoreCoordinator、NSManagedObjectContext、NSManagedObjectModel、NSEntityDescription、NSManagedObject。</p>

<ul>
<li><p>NSPersistentStoreCoordinator持久化存储协调器（简称协调器）：负责从磁盘加载数据和将数据写入磁盘。协调器可以处理多种格式的数据库文件（NSPersistentStore），如二进制文件，XML文件、SQLite文件。你也可以实现自己的数据库文件格式（使用NSAtomicStore和NSIncrementalStore类），理论上你可以实现打开World或Photoshop文件的协调器。</p></li>
<li><p>NSEntityDescription实体描述（简称实体）：实体可以被看做是NSManagedObject对象的“class”。实体定义了一个NSManagedObject对象所拥有的所有属性（NSAttributeDescription）,关系（NSRelationshipDescription），提取属性（NSFetchedPropertyDescription）。</p></li>
<li><p>NSManagedObjectContext托管对象上下文（简称上下文）：上下文是内存中的一块暂存区域。查询对象（使用NSFetchRequest），创建对象，删除对象等操作都是在上下文中进行。在上下文没有保存之前，对数据的任何修改都只记录在暂存区中，不会影响磁盘上的数据。你可以创建多个上下文，但整个程序只能创建一个NSPersstentStoreCoordinator对象。</p></li>
<li><p>NSManagedObject托管对象：Core Data的核心单元。模型对象的数据被持有在NSManagedObject对象中。每一个NSManagedObject对象都对应一个实体（就像每一个对象都有一个类）</p></li>
<li><p>NSManagedObjectModel托管对象模型：NSManagedObjectModel通常被定义在一个.mom文件中，文件中保存了所有实体的定义。NSManagedObjectModel and the NS*Description 类完整定义了Core Data模型应该/可以包含的内容。</p></li>
</ul>

]]></content>
  </entry>
  
</feed>
