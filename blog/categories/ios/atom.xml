<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: ios | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-09-26T18:30:58+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS8自动调整UITableView和UICollectionView布局]]></title>
    <link href="http://yulingtianxia.com/blog/2014/08/17/New-in-Table-and-Collection-Views/"/>
    <updated>2014-08-17T16:57:42+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/08/17/New-in-Table-and-Collection-Views</id>
    <content type="html"><![CDATA[<p>本文讲述了<code>UITableView</code>、<code>UICollectionView</code>实现self-sizing cell布局的知识，以及如何用InvalidationContext优化<code>UICollectionView</code>布局的更新。</p>

<!--more-->


<h2>背景</h2>

<p>iOS越来越人性化了，用户可以在设置-通用-辅助功能中动态调整字体大小了。你会发现所有iOS自带的APP的字体大小都变了，可惜我们开发的第三方APP依然是以前的字体。在iOS7之后我们可以用<code>UIFont</code>的<code>preferredFontForTextStyle:</code>类方法来指定一个样式，并让字体大小符合用户设定的字体大小。目前可供选择的有六种样式：</p>

<p><code>swift
UIFontTextStyleHeadline
UIFontTextStyleBody
UIFontTextStyleSubheadline
UIFontTextStyleFootnote
UIFontTextStyleCaption1
UIFontTextStyleCaption2
</code></p>

<p>iOS会根据样式的用途来合理调整字体。</p>

<p>问题来了，诸如字体大小这种“动态类型”，我们需要对其进行动态的UI调整，否则总是觉得我们的界面怪怪的：</p>

<p><img src="http://yulingtianxia.qiniudn.com/image-DCBF_53F0DDDB.jpg" alt="" /></p>

<p>我们想要让Cell的高度随着字体大小而作出调整：</p>

<p><img src="http://yulingtianxia.qiniudn.com/image-0D8C_53F0DDDB.jpg" alt="" /></p>

<p>总之，还会有其他动态因素导致我们需要修改布局。</p>

<h2>解决方案</h2>

<h3>UITableView</h3>

<p>有三种策略可以调节Cell（或者是Header和Footer）的高度：</p>

<ul>
<li>调节Height属性</li>
<li>通过委托方法<code>tableView: heightForRowAtIndexPath:</code></li>
<li>Cell的“自排列”（self-sizing）</li>
</ul>


<p>前两种策略都是我们所熟悉的，后面将介绍第三种策略。<code>UITableViewCell</code>和<code>UICollectionViewCell</code>都支持self-sizing</p>

<p>在iOS7中，<code>UITableViewDelegate</code>新增了三个方法来满足用户设定Cell、Header和Footer预计高度的方法：</p>

<p><code>
- tableView:estimatedHeightForRowAtIndexPath:
- tableView:estimatedHeightForHeaderInSection:
- tableView:estimatedHeightForFooterInSection:
</code>
当然对应这三个方法<code>UITableView</code>也<code>estimatedRowHeight</code>、<code>estimatedSectionHeaderHeight</code>和<code>estimatedSectionFooterHeight</code>三个属性，局限性在于只能统一定义所有行和节的高度。</p>

<p>以Cell为例，iOS会根据给出的预计高度来创建一个Cell，但等到真正要显示它的时候，iOS8会在self-sizing计算得出新的Size并调整table的<code>contentSize</code>后，将Cell绘制显示出来。关键在于如何得出Cell新的Size，iOS提供了两种方法：</p>

<ul>
<li>自动布局
  这个两年前推出的神器虽然在一开始表现不佳，但随着Xcode的越来越给力，在iOS7中自动布局俨然成了默认勾选的选项，通过设定一系列约束来使得我们的UI能够适应各种尺寸的屏幕。如果你有使用约束的经验，想必已经有了解决思路：向Cell的<code>contentView</code>添加约束。iOS会先调用<code>UIView</code>的<code>systemLayoutSizeFittingSize:</code>方法来根据约束计算新的Size，如果你没实现约束，<code>systemLayoutSizeFittingSize:</code>会接着调用<code>sizeThatFits:</code>方法。</li>
<li>人工代码
  我们可以重写<code>sizeThatFits:</code>方法来自己定义新的Size，这样我们就不必学习约束相关的知识了。</li>
</ul>


<p>下面我给出了一个用Swift语言写的Demo-<a href="https://github.com/yulingtianxia/HardChoice">HardChoice</a>，使用自动布局来调整<code>UITableViewCell</code>的高度。我通过实现一个<code>UITableViewCell</code>的子类<code>DynamicCell</code>来实现自动布局，你可以再GitHub上下载<a href="https://github.com/yulingtianxia/HardChoice">源码</a>：</p>

<p>&#8220;`
import UIKit</p>

<p>class DynamicCell: UITableViewCell {</p>

<pre><code>required init(coder: NSCoder) {
    super.init(coder: coder)
    if textLabel != nil {
        textLabel.font = UIFont.preferredFontForTextStyle(UIFontTextStyleHeadline)
        textLabel.numberOfLines = 0
    }
    if detailTextLabel != nil {
        detailTextLabel.font = UIFont.preferredFontForTextStyle(UIFontTextStyleBody)
        detailTextLabel.numberOfLines = 0
    }
}

override func constraints() -&gt; [AnyObject] {
    var constraints = [AnyObject]()
    if textLabel != nil {
        constraints.extend(constraintsForView(textLabel))
    }
    if detailTextLabel != nil {
        constraints.extend(constraintsForView(detailTextLabel))
    }
    constraints.append(NSLayoutConstraint(item: contentView, attribute: NSLayoutAttribute.Height, relatedBy: NSLayoutRelation.GreaterThanOrEqual, toItem: contentView, attribute: NSLayoutAttribute.Height, multiplier: 0, constant: 44))
    contentView.addConstraints(constraints)
    return constraints
}

func constraintsForView(view:UIView) -&gt; [AnyObject]{
    var constraints = [NSLayoutConstraint]()
    constraints.append(NSLayoutConstraint(item: view, attribute: NSLayoutAttribute.FirstBaseline, relatedBy: NSLayoutRelation.Equal, toItem: contentView, attribute: NSLayoutAttribute.Top, multiplier: 1.8, constant: 30.0))
    constraints.append(NSLayoutConstraint(item: contentView, attribute: NSLayoutAttribute.Bottom, relatedBy: NSLayoutRelation.GreaterThanOrEqual, toItem: view, attribute: NSLayoutAttribute.Baseline, multiplier: 1.3, constant: 8))
    return constraints
}
</code></pre>

<p>}
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">上面的代码需要注意的是，</span><span class="n">Objective</span><span class="o">-</span><span class="n">C</span><span class="err">中的类在</span><span class="n">Swift</span><span class="err">中都可以被当做</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">AnyObject</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">，这在类型兼容问题上很管用。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">别忘了在相应的</span><span class="bp">UITableViewController</span><span class="err">中的</span><span class="n">viewDidLoad</span><span class="err">方法中加上：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="nb">self</span><span class="p">.</span><span class="n">tableView</span><span class="p">.</span><span class="n">estimatedRowHeight</span> <span class="o">=</span> <span class="mi">44</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">自适应效果如下：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">img</span> <span class="n">src</span><span class="o">=</span><span class="s">&quot;http://yulingtianxia.qiniudn.com/140833033058.gif&quot;</span> <span class="n">alt</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="o">/&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h3</span><span class="o">&gt;</span><span class="bp">UICollectionView</span><span class="o">&lt;/</span><span class="n">h3</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UITableView</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="err">和</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionView</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="err">都是</span> <span class="n">data</span><span class="o">-</span><span class="n">source</span> <span class="err">和</span> <span class="n">delegate</span> <span class="err">驱动的。</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionView</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">在此之上进行了进一步抽象。它将其子视图的位置，大小和外观的控制权委托给一个单独的布局对象。通过提供一个自定义布局对象，你几乎可以实现任何你能想象到的布局。布局继承自</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionViewLayout</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="err">抽象基类。</span><span class="n">iOS6</span> <span class="err">中以</span> <span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionViewFlowLayout</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span> <span class="err">类的形式提出了一个具体的布局实现。在</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionViewFlowLayout</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">中，</span><span class="nb">self</span><span class="o">-</span><span class="n">sizing</span><span class="err">同样适用：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">img</span> <span class="n">src</span><span class="o">=</span><span class="s">&quot;http://yulingtianxia.qiniudn.com/image-05D4_53F0E00F.jpg&quot;</span> <span class="n">alt</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="o">/&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">采用</span><span class="nb">self</span><span class="o">-</span><span class="n">sizing</span><span class="err">后：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">img</span> <span class="n">src</span><span class="o">=</span><span class="s">&quot;http://yulingtianxia.qiniudn.com/image-B1E8_53F0DDDB.jpg&quot;</span> <span class="n">alt</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="o">/&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionView</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">实现</span><span class="nb">self</span><span class="o">-</span><span class="n">sizing</span><span class="err">不仅可以通过在</span><span class="n">Cell</span><span class="err">的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">contentView</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">上加约束和重写</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nl">sizeThatFits</span><span class="p">:</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法，也能在</span><span class="n">Cell</span><span class="err">层面（以前都是在</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">contentSize</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">上进行</span><span class="nb">self</span><span class="o">-</span><span class="n">sizing</span><span class="err">）上做文章：重写</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionReusableView</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nl">preferredLayoutAttributesFittingAttributes</span><span class="p">:</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法来在</span><span class="nb">self</span><span class="o">-</span><span class="n">sizing</span><span class="err">计算出</span><span class="n">Size</span><span class="err">之后再修改，这样就达到了对</span><span class="n">Cell</span><span class="err">布局属性（</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionViewLayoutAttributes</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">）的全面控制。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">PS</span><span class="err">：</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nl">preferredLayoutAttributesFittingAttributes</span><span class="p">:</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法默认调整</span><span class="n">Size</span><span class="err">属性来适应</span><span class="nb">self</span><span class="o">-</span><span class="n">sizing</span> <span class="n">Cell</span><span class="err">，所以重写的时候需要先调用父类方法，再在返回的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionViewLayoutAttributes</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">对象上做你想要做的修改。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">由此我们从最经典的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionViewLayout</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">强制计算属性（还记得</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionViewLayoutAttributes</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">的一系列工厂方法么？）到使用</span><span class="nb">self</span><span class="o">-</span><span class="n">sizing</span><span class="err">来根据我们需求调整属性中的</span><span class="n">Size</span><span class="err">，再到重写</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionReusableView</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">（</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionViewCell</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">也是继承于它）的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nl">preferredLayoutAttributesFittingAttributes</span><span class="p">:</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法来从</span><span class="n">Cell</span><span class="err">层面对所有属性进行修改：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">img</span> <span class="n">src</span><span class="o">=</span><span class="s">&quot;http://yulingtianxia.qiniudn.com/image-95BA_53F0DDDB.jpg&quot;</span> <span class="n">alt</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="o">/&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">下面来说说如何在</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionViewFlowLayout</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">实现</span><span class="nb">self</span><span class="o">-</span><span class="n">sizing</span><span class="err">：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">首先，</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionViewFlowLayout</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">增加了</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">estimatedItemSize</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">属性，这与</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UITableView</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">中的</span><span class="s">&quot;&lt;code&gt;estimated...Height&lt;/code&gt;&amp;ldquo;很像（注意我用省略号囊括那三种属性），但毕竟&lt;code&gt;UICollectionView&lt;/code&gt;中的Item都需要约束Height和Width的，所以它是个&lt;code&gt;CGSIze&lt;/code&gt;，除了这点它与&lt;code&gt;UITableView&lt;/code&gt;中的&amp;rdquo;&lt;code&gt;estimated...Height&lt;/code&gt;&amp;ldquo;用法没区别。&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">其次。。。没有其次，在</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UICollectionView</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">中实现</span><span class="nb">self</span><span class="o">-</span><span class="n">sizing</span><span class="err">，只需给</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">estimatedItemSize</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">属性赋值（不能是</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">CGSizeZero</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">），一行代码足矣。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h3</span><span class="o">&gt;</span><span class="n">InvalidationContext</span><span class="o">&lt;/</span><span class="n">h3</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">假如设备屏幕旋转，或者需要展示一些其妙的效果（比如</span><span class="n">CoverFlow</span><span class="err">），我们需要将当前的布局失效，并重新计算布局。当然每次计算都有一定的开销，所以我们应该谨慎的仅在我们需要的时候调用</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">invalidateLayout</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法来让布局失效。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">在</span><span class="n">iOS6</span><span class="err">时代，有的人会“聪明地”这样做：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="p">(</span><span class="kt">BOOL</span><span class="p">)</span><span class="nl">shouldInvalidateLayoutForBoundsChange</span><span class="p">:(</span><span class="bp">CGRect</span><span class="p">)</span><span class="n">newBounds</span>
</span><span class='line'><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">CGRect</span> <span class="n">oldBounds</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">collectionView</span><span class="p">.</span><span class="n">bounds</span><span class="p">;</span>
</span><span class='line'><span class="k">if</span> <span class="p">(</span><span class="n">CGRectGetWidth</span><span class="p">(</span><span class="n">newBounds</span><span class="p">)</span> <span class="o">!=</span> <span class="n">CGRectGetWidth</span><span class="p">(</span><span class="n">oldBounds</span><span class="p">))</span> <span class="p">{</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'>    <span class="k">return</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>而iOS7新加入的<code>UICollectionViewLayoutInvalidationContext</code>类声明了在布局失效时布局的哪些部分需要被更新。当数据源变更时，<code>invalidateEverything</code>和<code>invalidateDataSourceCounts</code>这两个只读Bool属性标记了<code>UICollectionView</code>数据源“全部过期失效”和“Section和Item数量失效”，<code>UICollectionView</code>会将它们自动设定并提供给你。</p>

<p>你可以调用<code>invalidateLayoutWithContext:</code>方法并传入一个<code>UICollectionViewLayoutInvalidationContext</code>对象，这能优化布局的更新效率。</p>

<p>当你自定义一个<code>UICollectionViewLayout</code>子类时，你可以调用<code>invalidationContextClass</code>方法来返回一个你定义的<code>UICollectionViewLayoutInvalidationContext</code>的子类，这样你的Layout子类在失效时会使用你自定义的InvalidationContext子类来优化更新布局。</p>

<p>你还可以重写<code>invalidationContextForBoundsChange:</code>方法，在实现自定义Layout时通过重写这个方法返回一个InvalidationContext对象。</p>

<p>综上所述都是iOS7中新加入的内容，并且还可以应用在<code>UICollectionViewFlowLayout</code>中。在iOS8中，<code>UICollectionViewLayoutInvalidationContext</code>也被用在self-sizing cell上。</p>

<p>iOS8中<code>UICollectionViewLayoutInvalidationContext</code>新加入了三个方法使得我们可以更加细致精密地使某一行某一节Item（Cell）、Supplementary View或Decoration View失效：</p>

<p><code>
invalidateItemsAtIndexPaths:
invalidateSupplementaryElementsOfKind:atIndexPaths:
invalidateDecorationElementsOfKind:atIndexPaths:
</code></p>

<p>对应着添加了三个只读数组属性来标记上面那三种组件：</p>

<p><code>
invalidatedItemIndexPaths
invalidatedSupplementaryIndexPaths
invalidatedDecorationIndexPaths
</code></p>

<p>iOS自带的照片应用会将每一节照片的信息（时间、地点）停留显示在最顶部，实现这种将Header粘在顶端的功能其实就是将那个Index的Supplementary View失效，就这么简单。</p>

<p><code>UICollectionViewLayoutInvalidationContext</code>新加入的<code>contentOffsetAdjustment</code>和<code>contentSizeAdjustment</code>属性可以让我们更新CollectionView的content的位移和尺寸。</p>

<p>此外<code>UICollectionViewLayout</code>还加入了一对儿方法来帮助我们使用self-sizing：</p>

<p><code>
shouldInvalidateLayoutForPreferredLayoutAttributes:withOriginalAttributes:
invalidationContextForPreferredLayoutAttributes:withOriginalAttributes:
</code></p>

<p>当一个self-sizing Cell发生属性发生变化时，第一个方法会被调用，它询问是否应该更新布局（即原布局失效），默认为NO；而第二个方法更细化的指明了哪些属性应该更新，需要调用父类的方法获得一个InvalidationContext对象，然后对其做一些你想要的修改，最后返回。</p>

<p>试想，如果在你自定义的布局中，一个Cell的Size因为某种原因发生了变化（比如由于字体大小变化），其他的Cell会由于self-sizing而位置发生变化，你需要实现上面两个方法来让指定的Cell更新布局中的部分属性；别忘了整个CollectionView的<code>contentSize</code>和<code>contentOffset</code>因此也会发生变化，你需要给<code>contentOffsetAdjustment</code>和<code>contentSizeAdjustment</code>属性赋值。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用Swift和SpriteKit开发iOS游戏]]></title>
    <link href="http://yulingtianxia.com/blog/2014/07/17/a-ios-game-developed-by-swift-and-spritekit/"/>
    <updated>2014-07-17T12:54:13+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/07/17/a-ios-game-developed-by-swift-and-spritekit</id>
    <content type="html"><![CDATA[<p>之前用SpriteKit做过一个叫做<a href="https://github.com/yulingtianxia/ColorAtom">ColorAtom</a>的小游戏，用了访问者模式处理碰撞检测，还用了SpriteKit中的粒子系统、连接体、力场和动画等，可以说是一个学习SpriteKit比较不错的Demo，随着Swift的火热，我也用Swift和SpriteKit写了一个更为简单的小游戏<a href="https://github.com/yulingtianxia/Spiral">Spiral</a></p>

<!--more-->


<p>附上Spiral的动图：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140557437844.gif" alt="" /></p>

<p>游戏规则是：玩家是五角星小球，小球自动沿着陀螺线向外运动，当玩家点击屏幕时五角星小球会跳跃到内层螺旋，当五角星小球碰到红色旋风或滚动到螺旋线终点时游戏结束。玩家吃掉绿色旋风来得2分，吃到紫色三角得一分并获得保护罩，保护罩用来抵挡一次红色旋风。随着分数的增加游戏会升级，速度加快。游戏结束后可以截屏分享到社交网络，也可以选择重玩。</p>

<p>以下是本文内容：</p>

<ol>
<li>准备工作</li>
<li>绘制基本界面</li>
<li>Swift中用访问者模式处理碰撞</li>
<li>界面数据显示</li>
<li>按钮的绘制和截图分享</li>
</ol>


<h2>准备工作</h2>

<p>SpriteKit是苹果iOS7新推出的2D游戏引擎，这里不再过多介绍。我们新建工程的时候选取iOS中的Game，然后选择SpriteKit作为游戏引擎，语言选择Swift，Xcode6会为我们自动创建一个游戏场景<code>GameScene</code>，它包含<code>GameScene.swift</code>和<code>GameScene.sks</code>两个文件，<code>sks</code>文件可以让我们可视化拖拽游戏控件到场景上，然后再代码中加载<code>sks</code>文件来完成场景的初始化：</p>

<p>&#8220;` js</p>

<p>extension SKNode {</p>

<pre><code>class func unarchiveFromFile(file : NSString) -&gt; SKNode? {

    let path = NSBundle.mainBundle().pathForResource(file, ofType: "sks")

    var sceneData = NSData.dataWithContentsOfFile(path, options: .DataReadingMappedIfSafe, error: nil)
    var archiver = NSKeyedUnarchiver(forReadingWithData: sceneData)

    archiver.setClass(self.classForKeyedUnarchiver(), forClassName: "SKScene")
    let scene = archiver.decodeObjectForKey(NSKeyedArchiveRootObjectKey) as GameScene
    archiver.finishDecoding()
    return scene
}
</code></pre>

<p>}
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">但我比较喜欢纯写代码的方式来搭接面，因为</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">sks</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">文件作为游戏场景布局还不成熟，它是</span><span class="n">iOS8</span><span class="err">新加入的功能，以前在</span><span class="n">iOS7</span><span class="err">的时候</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">sks</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">文件只是作为粒子系统的可视化编辑文件。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">所以我们修改</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">GameViewController</span><span class="p">.</span><span class="n">swift</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">文件的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">viewDidLoad</span><span class="p">()</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">函数，像以前那样直接用代码加载游戏场景：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span>
</span><span class='line'><span class="n">override</span> <span class="n">func</span> <span class="n">viewDidLoad</span><span class="p">()</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="nb">super</span><span class="p">.</span><span class="n">viewDidLoad</span><span class="p">()</span>
</span><span class='line'>    <span class="c1">// Configure the view.</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">skView</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">view</span> <span class="n">as</span> <span class="bp">SKView</span>
</span><span class='line'>    <span class="cm">/* Sprite Kit applies additional optimizations to improve rendering performance */</span>
</span><span class='line'>    <span class="n">skView</span><span class="p">.</span><span class="n">ignoresSiblingOrder</span> <span class="o">=</span> <span class="nb">true</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">scene</span> <span class="o">=</span> <span class="n">GameScene</span><span class="p">(</span><span class="nl">size</span><span class="p">:</span> <span class="n">skView</span><span class="p">.</span><span class="n">bounds</span><span class="p">.</span><span class="n">size</span><span class="p">)</span>
</span><span class='line'>    <span class="cm">/* Set the scale mode to scale to fit the window */</span>
</span><span class='line'>    <span class="n">scene</span><span class="p">.</span><span class="n">scaleMode</span> <span class="o">=</span> <span class="p">.</span><span class="n">AspectFill</span>
</span><span class='line'>    <span class="n">skView</span><span class="p">.</span><span class="n">presentScene</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">GameScene</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">虽然是</span><span class="n">Xcode</span><span class="err">自动生成的，但是只是个空架子，我们需要把它生成的没用的代码删掉，比如初始化函数里内容为“</span><span class="n">HelloWorld</span><span class="err">”的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKLabelNode</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">，还有</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">touchesBegan</span><span class="p">(</span><span class="nl">touches</span><span class="p">:</span> <span class="bp">NSSet</span><span class="p">,</span> <span class="n">withEvent</span> <span class="nl">event</span><span class="p">:</span> <span class="bp">UIEvent</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法中绘制飞船的代码。把这些删光后，我们还需要有图片素材来绘制这四类精灵节点：</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Player</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">（五角星），</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Killer</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">（红色旋风），</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Score</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">（绿色旋风）和</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Shield</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">（紫色三角）。我是用</span><span class="n">Sketch</span><span class="err">来绘制这些矢量图形的，文件名为</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">spiral</span><span class="p">.</span><span class="n">sketch</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">，随同工程文件一同放到</span><span class="n">GitHub</span><span class="err">上了。当然你不需要手动导出图片到工程，直接下载工程文件就好了：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;https://github.com/yulingtianxia/Spiral&quot;</span><span class="o">&gt;</span><span class="nl">https</span><span class="p">:</span><span class="c1">//github.com/yulingtianxia/Spiral&lt;/a&gt;&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h2</span><span class="o">&gt;</span><span class="err">绘制基本界面</span><span class="o">&lt;/</span><span class="n">h2</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">这部分的工作主要是绘制出螺旋线作为地图，并让四种精灵节点动起来。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h3</span><span class="o">&gt;</span><span class="err">螺旋线的绘制</span><span class="o">&lt;/</span><span class="n">h3</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKNode</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">有一个子类</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKShapeNode</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">，专门用于绘制线条的，我们新建一个</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Map</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">类，继承</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKShapeNode</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">。下面我们需要生成一个</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">CGPath</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">来赋值给</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Map</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">path</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">属性：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span>
</span><span class='line'><span class="n">import</span> <span class="n">UIKit</span>
</span><span class='line'><span class="n">import</span> <span class="n">SpriteKit</span>
</span><span class='line'><span class="k">class</span> <span class="nl">Map</span><span class="p">:</span> <span class="bp">SKShapeNode</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">let</span> <span class="nl">spacing</span><span class="p">:</span><span class="n">CGFloat</span> <span class="o">=</span> <span class="mi">35</span>
</span><span class='line'><span class="n">var</span> <span class="nl">points</span><span class="p">:[</span><span class="bp">CGPoint</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
</span><span class='line'><span class="n">convenience</span> <span class="n">init</span><span class="p">(</span><span class="nl">origin</span><span class="p">:</span><span class="bp">CGPoint</span><span class="p">,</span><span class="nl">layer</span><span class="p">:</span><span class="n">CGFloat</span><span class="p">){</span>
</span><span class='line'>
</span><span class='line'>    <span class="n">var</span> <span class="nl">x</span><span class="p">:</span><span class="n">CGFloat</span> <span class="o">=</span> <span class="n">origin</span><span class="p">.</span><span class="n">x</span>
</span><span class='line'>    <span class="n">var</span> <span class="nl">y</span><span class="p">:</span><span class="n">CGFloat</span> <span class="o">=</span> <span class="n">origin</span><span class="p">.</span><span class="n">y</span>
</span><span class='line'>    <span class="n">var</span> <span class="n">path</span> <span class="o">=</span> <span class="n">CGPathCreateMutable</span><span class="p">()</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">init</span><span class="p">()</span>
</span><span class='line'>    <span class="n">CGPathMoveToPoint</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">nil</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>    <span class="n">points</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</span><span class='line'>    <span class="k">for</span> <span class="n">index</span> <span class="k">in</span> <span class="mf">1.</span><span class="p">.</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">layer</span><span class="p">{</span>
</span><span class='line'>        <span class="n">y</span><span class="o">-=</span><span class="n">spacing</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="n">CGPathAddLineToPoint</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">nil</span> <span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>        <span class="n">points</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</span><span class='line'>        <span class="n">x</span><span class="o">-=</span><span class="n">spacing</span><span class="o">*</span><span class="p">(</span><span class="mi">2</span><span class="o">*</span><span class="n">index</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</span><span class='line'>        <span class="n">CGPathAddLineToPoint</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">nil</span> <span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>        <span class="n">points</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</span><span class='line'>        <span class="n">y</span><span class="o">+=</span><span class="n">spacing</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">index</span>
</span><span class='line'>        <span class="n">CGPathAddLineToPoint</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">nil</span> <span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>        <span class="n">points</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</span><span class='line'>        <span class="n">x</span><span class="o">+=</span><span class="n">spacing</span><span class="o">*</span><span class="mi">2</span><span class="o">*</span><span class="n">index</span>
</span><span class='line'>        <span class="n">CGPathAddLineToPoint</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="nb">nil</span> <span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
</span><span class='line'>        <span class="n">points</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">CGPointMake</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">path</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">glowWidth</span> <span class="o">=</span> <span class="mi">1</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">antialiased</span> <span class="o">=</span> <span class="nb">true</span>
</span><span class='line'>    <span class="n">CGPathGetCurrentPoint</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>算法很简单，就是顺时针计算点坐标然后画线，这里把每一步的坐标都存入了<code>points</code>数组里，是为了以后计算其他数据时方便。因为这部分算法不难而且不是我们的重点，这里不过多介绍了。</p>

<h3>四种精灵的绘制</h3>

<p>因为四种精灵都是沿着<code>Map</code>类的路径来顺时针运动，它们的动画绘制是相似的，所以我建立了一个<code>Shape</code>类作为基类来绘制动画，它继承于<code>SKSpriteKit</code>类，并拥有半径（<code>radius</code>）、移动速度（<code>moveSpeed</code>）和线段计数（<code>lineNum</code>）这三个属性。其中<code>lineNum</code>是用于标记精灵在螺旋线第几条线段上的，这样比较方便计算动画的参数。</p>

<p>&#8220;`
class Shape: SKSpriteNode {</p>

<pre><code>let radius:CGFloat = 10
var moveSpeed:CGFloat = 50
var lineNum = 0
init(name:String,imageName:String){
    super.init(texture: SKTexture(imageNamed: imageName),color:SKColor.clearColor(), size: CGSizeMake(radius*2, radius*2))
    self.physicsBody = SKPhysicsBody(circleOfRadius: radius)
    self.physicsBody.usesPreciseCollisionDetection = true
    self.physicsBody.collisionBitMask = 0
    self.physicsBody.contactTestBitMask = playerCategory|killerCategory|scoreCategory
    moveSpeed += CGFloat(Data.speedScale) * self.moveSpeed
    self.name = name
    self.physicsBody.angularDamping = 0

}
</code></pre>

<p>}
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
<span class='line-number'>74</span>
<span class='line-number'>75</span>
<span class='line-number'>76</span>
<span class='line-number'>77</span>
<span class='line-number'>78</span>
<span class='line-number'>79</span>
<span class='line-number'>80</span>
<span class='line-number'>81</span>
<span class='line-number'>82</span>
<span class='line-number'>83</span>
<span class='line-number'>84</span>
<span class='line-number'>85</span>
<span class='line-number'>86</span>
<span class='line-number'>87</span>
<span class='line-number'>88</span>
<span class='line-number'>89</span>
<span class='line-number'>90</span>
<span class='line-number'>91</span>
<span class='line-number'>92</span>
<span class='line-number'>93</span>
<span class='line-number'>94</span>
<span class='line-number'>95</span>
<span class='line-number'>96</span>
<span class='line-number'>97</span>
<span class='line-number'>98</span>
<span class='line-number'>99</span>
<span class='line-number'>100</span>
<span class='line-number'>101</span>
<span class='line-number'>102</span>
<span class='line-number'>103</span>
<span class='line-number'>104</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">构造函数中设定了</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Shape</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">类的一些物理参数，比如物理体的形状大小，碰撞检测掩码等。这里设定</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">usesPreciseCollisionDetection</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">为</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="nb">true</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">是为了增加碰撞检测的精度，常用于体积小速度快的物体。</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">collisionBitMask</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">属性标记了需要模拟物理碰撞的类别，</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">contactTestBitMask</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">属性标记了需要检测到碰撞的类别。这里说的“类别”指的是物体的类别：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="n">let</span> <span class="nl">playerCategory</span><span class="p">:</span><span class="kt">UInt32</span>      <span class="o">=</span>  <span class="mh">0x1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">0</span><span class="p">;</span>
</span><span class='line'><span class="n">let</span> <span class="nl">killerCategory</span><span class="p">:</span><span class="kt">UInt32</span>      <span class="o">=</span>  <span class="mh">0x1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span>
</span><span class='line'><span class="n">let</span> <span class="nl">scoreCategory</span><span class="p">:</span><span class="kt">UInt32</span>       <span class="o">=</span>  <span class="mh">0x1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">2</span><span class="p">;</span>
</span><span class='line'><span class="n">let</span> <span class="nl">shieldCategory</span><span class="p">:</span><span class="kt">UInt32</span>      <span class="o">=</span>  <span class="mh">0x1</span> <span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span> <span class="mi">3</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span>
</span><span class='line'><span class="err">这种用位运算来判断和存储物体类别的方式很常用，上面这段代码写在了</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">NodeCategories</span><span class="p">.</span><span class="n">swift</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">文件中。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">为了描述</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Shape</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">的速度随着游戏等级上升而增加，这里速度的计算公式含有</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Data</span><span class="p">.</span><span class="n">speedScale</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">作为参数，关于</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Data</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">“类”在后面会讲到。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">为了让精灵动起来，需要知道动画的移动目的地是什么。虽然</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKAction</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">有</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">followPath</span><span class="p">(</span><span class="nl">path</span><span class="p">:</span> <span class="bp">CGPath</span><span class="o">?</span><span class="p">,</span> <span class="nl">speed</span><span class="p">:</span> <span class="n">CGFloat</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法，但是在这里并不实用，因为</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Player</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">会经常改变路线，所以我写了一个</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">runInMap</span><span class="p">(</span><span class="nl">map</span><span class="p">:</span><span class="n">Map</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法让精灵每次只移动到路径上的下一个节点（之前</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Map</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">类存储的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">points</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">属性用到了吧！嘿嘿）</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span>
</span><span class='line'><span class="n">func</span> <span class="n">runInMap</span><span class="p">(</span><span class="nl">map</span><span class="p">:</span><span class="n">Map</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="n">let</span> <span class="n">distance</span> <span class="o">=</span> <span class="n">calDistanceInMap</span><span class="p">(</span><span class="n">map</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">distance</span><span class="o">/</span><span class="n">moveSpeed</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">rotate</span> <span class="o">=</span> <span class="bp">SKAction</span><span class="p">.</span><span class="n">rotateByAngle</span><span class="p">(</span><span class="n">distance</span><span class="o">/</span><span class="mi">10</span><span class="p">,</span> <span class="nl">duration</span><span class="p">:</span> <span class="n">duration</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">move</span> <span class="o">=</span> <span class="bp">SKAction</span><span class="p">.</span><span class="n">moveTo</span><span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">lineNum</span><span class="o">+</span><span class="mi">1</span><span class="p">],</span> <span class="nl">duration</span><span class="p">:</span> <span class="n">duration</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">group</span> <span class="o">=</span> <span class="bp">SKAction</span><span class="p">.</span><span class="n">group</span><span class="p">([</span><span class="n">rotate</span><span class="p">,</span><span class="n">move</span><span class="p">])</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">runAction</span><span class="p">(</span><span class="n">group</span><span class="p">,</span> <span class="nl">completion</span><span class="p">:</span> <span class="p">{</span>
</span><span class='line'>        <span class="nb">self</span><span class="p">.</span><span class="n">lineNum</span><span class="o">++</span>
</span><span class='line'>        <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="n">lineNum</span><span class="o">==</span><span class="n">map</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">count</span><span class="o">-</span><span class="mi">1</span> <span class="p">{</span>
</span><span class='line'>            <span class="k">if</span> <span class="nb">self</span> <span class="n">is</span> <span class="n">Player</span><span class="p">{</span>
</span><span class='line'>                <span class="n">Data</span><span class="p">.</span><span class="n">gameOver</span> <span class="o">=</span> <span class="nb">true</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="nb">self</span> <span class="n">is</span> <span class="n">Killer</span><span class="p">{</span>
</span><span class='line'>                <span class="nb">self</span><span class="p">.</span><span class="n">removeFromParent</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="nb">self</span> <span class="n">is</span> <span class="n">Score</span><span class="p">{</span>
</span><span class='line'>                <span class="nb">self</span><span class="p">.</span><span class="n">removeFromParent</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>            <span class="k">if</span> <span class="nb">self</span> <span class="n">is</span> <span class="n">Shield</span><span class="p">{</span>
</span><span class='line'>                <span class="nb">self</span><span class="p">.</span><span class="n">removeFromParent</span><span class="p">()</span>
</span><span class='line'>            <span class="p">}</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>            <span class="nb">self</span><span class="p">.</span><span class="n">runInMap</span><span class="p">(</span><span class="n">map</span><span class="p">)</span>
</span><span class='line'>        <span class="p">}</span>
</span><span class='line'>        <span class="p">})</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">上面的代码先是调用</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">calDistanceInMap</span><span class="p">(</span><span class="nl">map</span><span class="p">:</span><span class="n">Map</span><span class="p">)</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">CGFloat</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法计算精灵距离下一个节点的距离（也就是需要移动的距离），然后计算精灵需要旋转动画时间和移动动画时间，最后将两个动画作为一个</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">group</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">来运行，在动画运行结束后判断精灵是否运行到了最后一个节点，也就是螺旋线的终点：如果到终点了则移除精灵，否则开始递归调用方法，来开始下一段动画（奔向下一个节点）。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">计算距离的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">calDistanceInMap</span><span class="p">(</span><span class="nl">map</span><span class="p">:</span><span class="n">Map</span><span class="p">)</span><span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span><span class="n">CGFloat</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法代码如下：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span>
</span><span class='line'><span class="n">func</span> <span class="n">calDistanceInMap</span><span class="p">(</span><span class="nl">map</span><span class="p">:</span><span class="n">Map</span><span class="p">)</span><span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span><span class="o">&gt;</span><span class="n">CGFloat</span><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="k">if</span> <span class="nb">self</span><span class="p">.</span><span class="n">lineNum</span><span class="o">==</span><span class="n">map</span><span class="p">.</span><span class="n">points</span><span class="p">.</span><span class="n">count</span> <span class="p">{</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">switch</span> <span class="n">lineNum</span><span class="o">%</span><span class="mi">4</span><span class="p">{</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">0</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="o">-</span><span class="n">map</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">lineNum</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">1</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="o">-</span><span class="n">map</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">lineNum</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">2</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">lineNum</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">y</span><span class="o">-</span><span class="n">position</span><span class="p">.</span><span class="n">y</span>
</span><span class='line'>    <span class="k">case</span> <span class="mi">3</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="n">points</span><span class="p">[</span><span class="n">lineNum</span><span class="o">+</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span><span class="o">-</span><span class="n">position</span><span class="p">.</span><span class="n">x</span>
</span><span class='line'>    <span class="k">default</span><span class="o">:</span>
</span><span class='line'>        <span class="k">return</span> <span class="mi">0</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">到此为止</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Shape</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">类完成了，</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Killer</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">、</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Score</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">和</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Shield</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">类比较简单，继承</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Shape</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">类并设置自身纹理和类别即可：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span>
</span><span class='line'><span class="k">class</span> <span class="nl">Killer</span><span class="p">:</span> <span class="n">Shape</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">convenience</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="s">&quot;Killer&quot;</span><span class="p">,</span><span class="nl">imageName</span><span class="p">:</span><span class="s">&quot;killer&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">physicsBody</span><span class="p">.</span><span class="n">categoryBitMask</span> <span class="o">=</span> <span class="n">killerCategory</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="nl">Score</span><span class="p">:</span> <span class="n">Shape</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">convenience</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="s">&quot;Score&quot;</span><span class="p">,</span><span class="nl">imageName</span><span class="p">:</span><span class="s">&quot;score&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">physicsBody</span><span class="p">.</span><span class="n">categoryBitMask</span> <span class="o">=</span> <span class="n">scoreCategory</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span><span class='line'><span class="k">class</span> <span class="nl">Shield</span><span class="p">:</span> <span class="n">Shape</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">convenience</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">init</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span><span class="s">&quot;Shield&quot;</span><span class="p">,</span><span class="nl">imageName</span><span class="p">:</span><span class="s">&quot;shield&quot;</span><span class="p">)</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">physicsBody</span><span class="p">.</span><span class="n">categoryBitMask</span> <span class="o">=</span> <span class="n">shieldCategory</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>而<code>Player</code>因为有护盾状态并可以在螺旋线上跳跃到内层，所以稍微复杂些：</p>

<p>&#8220;`
class Player: Shape {</p>

<pre><code>var jump = false
var shield:Bool = false {
willSet{
    if newValue{
        self.texture = SKTexture(imageNamed: "player0")
    }
    else{
        self.texture = SKTexture(imageNamed: "player")
    }
}
}
convenience init() {
    self.init(name:"Player",imageName:"player")
    self.physicsBody.categoryBitMask = playerCategory
    self.moveSpeed = 70
    self.lineNum = 3
}
func restart(map:Map) {
    self.alpha = 1
    self.removeAllActions()
    self.lineNum = 3
    self.moveSpeed = 70
    self.jump = false
    self.shield = false
    self.position = map.points[self.lineNum]
    self.runInMap(map)
}
</code></pre>

<p>}
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Player</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">类的初始位置是螺旋线第四个节点，而且移动速度要略快于其他三种精灵，所以在这里设置为</span><span class="mi">70</span><span class="err">（</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Shape</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">默认速度</span><span class="mi">50</span><span class="err">）。</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">jump</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">和</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">shield</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">是用来标记</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Player</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">当前状态的属性，其中</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">shield</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">属性还定义了属性监察器，这是</span><span class="n">Swift</span><span class="err">中存储属性具有的响应机制，类似于</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">KVO</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">。在</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">shield</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">状态改变时也同时改变</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Player</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">的纹理。</span><span class="o">&lt;</span><span class="k">strong</span><span class="o">&gt;</span><span class="err">需要注意的是构造器中对属性的改变并不会调用属性检查器，在</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">willSet</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">和</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">didSet</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">中改变自身属性也不会调用属性检查器，因为那样会造成死循环。</span><span class="o">&lt;/</span><span class="k">strong</span><span class="o">&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">restart</span><span class="p">(</span><span class="nl">map</span><span class="p">:</span><span class="n">Map</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法用于在游戏重新开始时重置</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Player</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">的相关数据。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h2</span><span class="o">&gt;</span><span class="n">Swift</span><span class="err">中用访问者模式处理碰撞</span><span class="o">&lt;/</span><span class="n">h2</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">访问者模式是双分派（</span><span class="n">Double</span> <span class="n">Dispatch</span><span class="err">）模式的一种实现，关于双分派模式的详细解释，参考我的另一篇文章：</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;http://yulingtianxia.com/blog/2014/04/13/double-dispatchmo-shi-ji-qi-zai-ioskai-fa-zhong-shi-zhan/&quot;</span><span class="o">&gt;</span><span class="n">Double</span> <span class="n">Dispatch</span><span class="err">模式及其在</span><span class="n">iOS</span><span class="err">开发中实践</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span><span class="err">，里面包含了</span><span class="n">C</span><span class="o">++</span><span class="err">，</span><span class="n">Java</span><span class="err">和</span><span class="n">Obje</span><span class="o">-</span><span class="n">C</span><span class="err">的实现，这次我们用</span><span class="n">Swift</span><span class="err">实现访问者模式。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">因为</span><span class="n">SpriteKit</span><span class="err">中物理碰撞检测到的都是</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKPhysicsBody</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">，所以我们的被访问者需要包含一个</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKPhysicsBody</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">对象：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span>
</span><span class='line'><span class="k">class</span> <span class="n">VisitablePhysicsBody</span><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">let</span> <span class="nl">body</span><span class="p">:</span><span class="bp">SKPhysicsBody</span>
</span><span class='line'><span class="n">init</span><span class="p">(</span><span class="nl">body</span><span class="p">:</span><span class="bp">SKPhysicsBody</span><span class="p">){</span>
</span><span class='line'>    <span class="nb">self</span><span class="p">.</span><span class="n">body</span> <span class="o">=</span> <span class="n">body</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="n">acceptVisitor</span><span class="p">(</span><span class="nl">visitor</span><span class="p">:</span><span class="n">ContactVisitor</span><span class="p">){</span>
</span><span class='line'>    <span class="n">visitor</span><span class="p">.</span><span class="n">visitBody</span><span class="p">(</span><span class="n">body</span><span class="p">)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p><code>acceptVisitor</code>方法传入的是一个<code>ContactVisitor</code>类，它是访问者的基类（也相当于接口），访问者的<code>visitBody(body:SKPhysicsBody)</code>方法会根据传入的<code>body</code>实例来推断出被访问者的真实类别，然后调用对应的方法来处理碰撞：</p>

<p>&#8220;`
func visitBody(body:SKPhysicsBody){</p>

<pre><code>    //第二次dispatch，通过构造方法名来执行对应方法
    // 生成方法名，比如"visitPlayer"
    var contactSelectorString = "visit" + body.node.name + ":"
    let selector = NSSelectorFromString(contactSelectorString)
    if self.respondsToSelector(selector){
        dispatch_after(0, dispatch_get_main_queue(), {
            NSThread.detachNewThreadSelector(selector, toTarget:self, withObject: body)
            })
    }

}
</code></pre>

<p>&#8220;`</p>

<p>Swift废弃了<code>performSelector</code>方法，所以这里耍了个小聪明来将消息传给具体的访问者。有关Swift中替代<code>performSelector</code>的方案，参见<a href="http://www.cnblogs.com/yangzhou1030/p/3830592.html">这里</a></p>

<p>下面让<code>GameScene</code>实现<code>SKPhysicsContactDelegate</code>协议：</p>

<p>&#8220;`
func didBeginContact(contact:SKPhysicsContact){</p>

<pre><code>    //A-&gt;B
    let visitorA = ContactVisitor.contactVisitorWithBody(contact.bodyA, forContact: contact)
    let visitableBodyB = VisitablePhysicsBody(body: contact.bodyB)
    visitableBodyB.acceptVisitor(visitorA)
    //B-&gt;A
    let visitorB = ContactVisitor.contactVisitorWithBody(contact.bodyB, forContact: contact)
    let visitableBodyA = VisitablePhysicsBody(body: contact.bodyA)
    visitableBodyA.acceptVisitor(visitorB)
}
</code></pre>

<p><code>``
跟Objective-C中实现访问者模式类似，也是通过</code>ContactVisitor<code>类的工厂方法返回一个对应的子类实例来作为访问者，然后实例化一个被访问者，被访问者接受访问者的访问。A访问B和B访问A在大多数场合是相同的，但是你不知道谁是A谁是B，所以需要两种情况都调用。下面是</code>ContactVisitor`类的工厂方法和构造器：</p>

<p>&#8220;`
class ContactVisitor:NSObject{</p>

<pre><code>let body:SKPhysicsBody!
let contact:SKPhysicsContact!
class func contactVisitorWithBody(body:SKPhysicsBody,forContact contact:SKPhysicsContact)-&gt;ContactVisitor!{
    //第一次dispatch，通过node类别返回对应的实例
    if 0 != body.categoryBitMask&amp;playerCategory {
        return PlayerContactVisitor(body: body, forContact: contact)
    }
    if 0 != body.categoryBitMask&amp;killerCategory {
        return KillerContactVisitor(body: body, forContact: contact)
    }
    if 0 != body.categoryBitMask&amp;scoreCategory {
        return ScoreContactVisitor(body: body, forContact: contact)
    }
    if 0 != body.categoryBitMask&amp;shieldCategory {
        return ShieldContactVisitor(body: body, forContact: contact)
    }
    return nil

}
init(body:SKPhysicsBody, forContact contact:SKPhysicsContact){
    self.body = body
    self.contact = contact
    super.init()

}
</code></pre>

<p>}
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">PS</span><span class="err">：上面的代码省略了已经提到过的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">visitBody</span><span class="p">(</span><span class="nl">body</span><span class="p">:</span><span class="bp">SKPhysicsBody</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">因为这个游戏逻辑比较简单，所有碰撞后的逻辑都写到了</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">PlayerContactVisitor</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">类里：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span>
</span><span class='line'><span class="n">func</span> <span class="n">visitKiller</span><span class="p">(</span><span class="nl">body</span><span class="p">:</span><span class="bp">SKPhysicsBody</span><span class="p">){</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="n">let</span> <span class="n">thisNode</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">body</span><span class="p">.</span><span class="n">node</span> <span class="n">as</span> <span class="n">Player</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">otherNode</span> <span class="o">=</span> <span class="n">body</span><span class="p">.</span><span class="n">node</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//        println(thisNode.name+&amp;ldquo;&amp;ndash;&gt;&amp;rdquo;+otherNode.name)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="k">if</span> <span class="n">thisNode</span><span class="p">.</span><span class="n">shield</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">otherNode</span><span class="p">.</span><span class="n">removeFromParent</span><span class="p">()</span>
</span><span class='line'>        <span class="n">thisNode</span><span class="p">.</span><span class="n">shield</span> <span class="o">=</span> <span class="nb">false</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="k">else</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">Data</span><span class="p">.</span><span class="n">gameOver</span> <span class="o">=</span> <span class="nb">true</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="n">visitScore</span><span class="p">(</span><span class="nl">body</span><span class="p">:</span><span class="bp">SKPhysicsBody</span><span class="p">){</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">thisNode</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">body</span><span class="p">.</span><span class="n">node</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">otherNode</span> <span class="o">=</span> <span class="n">body</span><span class="p">.</span><span class="n">node</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="c1">//        println(thisNode.name+&amp;ldquo;&amp;ndash;&gt;&amp;rdquo;+otherNode.name)&lt;/p&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="n">otherNode</span><span class="p">.</span><span class="n">removeFromParent</span><span class="p">()</span>
</span><span class='line'>    <span class="n">Data</span><span class="p">.</span><span class="n">score</span> <span class="o">+=</span> <span class="mi">2</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="n">func</span> <span class="n">visitShield</span><span class="p">(</span><span class="nl">body</span><span class="p">:</span><span class="bp">SKPhysicsBody</span><span class="p">){</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">thisNode</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">body</span><span class="p">.</span><span class="n">node</span> <span class="n">as</span> <span class="n">Player</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">otherNode</span> <span class="o">=</span> <span class="n">body</span><span class="p">.</span><span class="n">node</span>
</span><span class='line'>    <span class="n">otherNode</span><span class="p">.</span><span class="n">removeFromParent</span><span class="p">()</span>
</span><span class='line'>    <span class="n">thisNode</span><span class="p">.</span><span class="n">shield</span> <span class="o">=</span> <span class="nb">true</span>
</span><span class='line'>    <span class="n">Data</span><span class="p">.</span><span class="n">score</span><span class="o">++</span>
</span><span class='line'>    <span class="c1">//        println(thisNode.name+&quot;-&amp;gt;&quot;+otherNode.name)</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">上面的方法都是“</span><span class="n">visit</span><span class="o">+</span><span class="err">类名”格式的，处理的是</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Player</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">碰撞到其他三种精灵的逻辑。而其他三种精灵之间的碰撞不需要处理，所以</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">KillerContactVisitor</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">、</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ScoreContactVisitor</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">和</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ShieldContactVisitor</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">这三个</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ContactVisitor</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">的子类很空旷，这里不再赘述。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">我们设置</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Player</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">碰撞到</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Killer</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">游戏结束，碰撞到</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Score</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">加两分，碰撞到</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Shield</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">加一分并获得护甲（</span><span class="n">shield</span><span class="err">属性设为</span><span class="nb">true</span><span class="err">）。可以看到这里大量用到了</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Data</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">“类“”，它其实是一个存储并管理全局数据的结构体，它里面存储了一些静态的成员属性，也可看做非线程安全的单例。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h2</span><span class="o">&gt;</span><span class="err">界面数据显示</span><span class="o">&lt;/</span><span class="n">h2</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">这部分很简单，主要是将</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Data</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">结构体中存储的分数和等级等数据通过</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKLabelNode</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">显示在界面上，只不过我封装了一个</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Display</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">类来将所有的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKLabelNode</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">统一管理，并让其实现我定义的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">DisplayData</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">协议来让</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Data</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">中的数据变化驱动界面更新：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span>
</span><span class='line'><span class="n">protocol</span> <span class="n">DisplayData</span><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">func</span> <span class="n">updateData</span><span class="p">()</span>
</span><span class='line'><span class="n">func</span> <span class="n">levelUp</span><span class="p">()</span>
</span><span class='line'><span class="n">func</span> <span class="n">gameOver</span><span class="p">()</span>
</span><span class='line'><span class="n">func</span> <span class="n">restart</span><span class="p">()</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>下面是Data结构体代码，大量使用了存储属性的监察器来响应数据变化：</p>

<p>&#8220;`
struct Data{</p>

<pre><code>static var display:DisplayData?
static var updateScore:Int = 5
static var score:Int = 0{
willSet{
    if newValue&gt;=updateScore{
        updateScore+=5 * ++level
    }
}
didSet{
    display?.updateData()
}
}
static var highScore:Int = 0
static var gameOver:Bool = false {
willSet{
    if newValue {
        let standardDefaults = NSUserDefaults.standardUserDefaults()
        Data.highScore = standardDefaults.integerForKey("highscore")
        if Data.highScore &lt; Data.score {
            Data.highScore = Data.score
            standardDefaults.setInteger(Data.score, forKey: "highscore")
            standardDefaults.synchronize()
        }
        display?.gameOver()
    }
    else {
        display?.restart()
    }
}
didSet{

}
}
static var level:Int = 1{
willSet{
    speedScale = Float(newValue)*0.1
    if newValue != 1{
        display?.levelUp()
    }
}
didSet{
    display?.updateData()

}
}
static var speedScale:Float = 0{
willSet{

}
didSet{

}
}

static func restart(){
    Data.updateScore = 5
    Data.score = 0
    Data.level = 1
    Data.speedScale = 0
}
</code></pre>

<p>}
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
<span class='line-number'>40</span>
<span class='line-number'>41</span>
<span class='line-number'>42</span>
<span class='line-number'>43</span>
<span class='line-number'>44</span>
<span class='line-number'>45</span>
<span class='line-number'>46</span>
<span class='line-number'>47</span>
<span class='line-number'>48</span>
<span class='line-number'>49</span>
<span class='line-number'>50</span>
<span class='line-number'>51</span>
<span class='line-number'>52</span>
<span class='line-number'>53</span>
<span class='line-number'>54</span>
<span class='line-number'>55</span>
<span class='line-number'>56</span>
<span class='line-number'>57</span>
<span class='line-number'>58</span>
<span class='line-number'>59</span>
<span class='line-number'>60</span>
<span class='line-number'>61</span>
<span class='line-number'>62</span>
<span class='line-number'>63</span>
<span class='line-number'>64</span>
<span class='line-number'>65</span>
<span class='line-number'>66</span>
<span class='line-number'>67</span>
<span class='line-number'>68</span>
<span class='line-number'>69</span>
<span class='line-number'>70</span>
<span class='line-number'>71</span>
<span class='line-number'>72</span>
<span class='line-number'>73</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">这里不得不提到一个更新界面时遇到的一个坑，当我想通过名字遍历</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">GameScene</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">子节点的时候，一般会用到</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">enumerateChildNodesWithName</span><span class="p">(</span><span class="nl">name</span><span class="p">:</span> <span class="n">String</span><span class="o">?</span><span class="p">,</span> <span class="nl">usingBlock</span><span class="p">:</span> <span class="p">((</span><span class="bp">SKNode</span><span class="o">!</span><span class="p">,</span> <span class="n">UnsafePointer</span><span class="o">&amp;</span><span class="n">lt</span><span class="p">;</span><span class="n">ObjCBool</span><span class="o">&amp;</span><span class="n">gt</span><span class="p">;)</span> <span class="o">-&amp;</span><span class="n">gt</span><span class="p">;</span> <span class="n">Void</span><span class="p">)</span><span class="o">?</span><span class="p">)</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">方法，但是这个方法在</span><span class="n">Xcode6Beta3</span><span class="err">更新后经常会抛异常强退，这让我很费解，恰巧遇到此问题的不只是我一个人，所以还是老老实实的自己写循环遍历加判断吧。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h2</span><span class="o">&gt;</span><span class="err">按钮的绘制和截图分享</span><span class="o">&lt;/</span><span class="n">h2</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">参考我的另外两篇文章：</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button/&quot;</span><span class="o">&gt;</span><span class="err">在游戏的</span><span class="bp">SKScene</span><span class="err">中添加</span><span class="n">Button</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span><span class="err">和</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;http://yulingtianxia.com/blog/2014/04/22/spritekitjie-ping-bing-fen-xiang-zhi-she-jiao-wang-luo/&quot;</span><span class="o">&gt;</span><span class="n">SpriteKit</span><span class="err">截屏并分享至社交网络</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">在本工程中只有</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ShareButton</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">和</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ReplayButton</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">两个按钮，</span><span class="n">Swift</span><span class="err">版本的代码很简洁，而我通过</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">Social</span><span class="p">.</span><span class="n">Framework</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">中的</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">UIActivityViewController</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">来分享得分，这部分代码写在了</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="n">ShareButton</span><span class="p">.</span><span class="n">swift</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">中：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span>
</span><span class='line'><span class="n">let</span> <span class="n">scene</span> <span class="o">=</span> <span class="nb">self</span><span class="p">.</span><span class="n">scene</span> <span class="n">as</span> <span class="n">GameScene</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span>    <span class="n">let</span> <span class="n">image</span> <span class="o">=</span> <span class="n">scene</span><span class="p">.</span><span class="n">imageFromNode</span><span class="p">(</span><span class="n">scene</span><span class="p">)</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">text</span> <span class="o">=</span> <span class="s">&quot;我在Spiral游戏中得了\(Data.score)分，快来追逐我的步伐吧！&quot;</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">activityItems</span> <span class="o">=</span> <span class="p">[</span><span class="n">image</span><span class="p">,</span><span class="n">text</span><span class="p">]</span>
</span><span class='line'>    <span class="n">let</span> <span class="n">activityController</span> <span class="o">=</span> <span class="bp">UIActivityViewController</span><span class="p">(</span><span class="nl">activityItems</span><span class="p">:</span> <span class="n">activityItems</span><span class="p">,</span> <span class="nl">applicationActivities</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'>    <span class="p">(</span><span class="n">scene</span><span class="p">.</span><span class="n">view</span><span class="p">.</span><span class="n">nextResponder</span><span class="p">()</span> <span class="n">as</span> <span class="bp">UIViewController</span><span class="p">).</span><span class="n">presentViewController</span><span class="p">(</span><span class="n">activityController</span><span class="p">,</span> <span class="nl">animated</span><span class="p">:</span> <span class="nb">true</span><span class="p">,</span> <span class="nl">completion</span><span class="p">:</span> <span class="nb">nil</span><span class="p">)</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'><span class="p">]]</span><span class="o">&gt;&lt;/</span><span class="n">content</span><span class="o">&gt;</span>
</span><span class='line'>  <span class="o">&lt;/</span><span class="n">entry</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'>  <span class="o">&lt;</span><span class="n">entry</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">title</span> <span class="n">type</span><span class="o">=</span><span class="s">&quot;html&quot;</span><span class="o">&gt;&lt;!</span><span class="p">[</span><span class="n">CDATA</span><span class="p">[</span><span class="n">SpriteKit</span><span class="err">坐标系</span><span class="p">]]</span><span class="o">&gt;&lt;/</span><span class="n">title</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">link</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;http://yulingtianxia.com/blog/2014/05/04/spritekitzuo-biao-xi/&quot;</span><span class="o">/&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">updated</span><span class="o">&gt;</span><span class="mi">2014</span><span class="o">-</span><span class="mo">05</span><span class="o">-</span><span class="mo">04</span><span class="nl">T19</span><span class="p">:</span><span class="mi">36</span><span class="o">:</span><span class="mi">26</span><span class="o">+</span><span class="mi">08</span><span class="o">:</span><span class="mo">00</span><span class="o">&lt;/</span><span class="n">updated</span><span class="o">&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="kt">id</span><span class="o">&gt;</span><span class="nl">http</span><span class="p">:</span><span class="c1">//yulingtianxia.com/blog/2014/05/04/spritekitzuo-biao-xi&lt;/id&gt;</span>
</span><span class='line'>    <span class="o">&lt;</span><span class="n">content</span> <span class="n">type</span><span class="o">=</span><span class="s">&quot;html&quot;</span><span class="o">&gt;&lt;!</span><span class="p">[</span><span class="n">CDATA</span><span class="p">[</span><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">前一阵子在用</span><span class="n">SpriteKit</span><span class="err">写一个小游戏的时候，因为对坐标系系统不是很熟悉，结果耽误了不少时间，现在将这些</span><span class="bp">SKNode</span><span class="p">(</span><span class="err">及其子类</span><span class="p">)</span><span class="err">中常用的部分记下来，以利于以后快速查找</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">本文测试用到的工程代码可以在</span><span class="o">&lt;</span><span class="n">a</span> <span class="n">href</span><span class="o">=</span><span class="s">&quot;https://github.com/yulingtianxia/NodesCoordinates/tree/master&quot;</span><span class="o">&gt;</span><span class="err">这里</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span><span class="err">下载</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="k">strong</span><span class="o">&gt;</span><span class="err">一般来说，</span><span class="n">SpriteKit</span><span class="err">中所有坐标系都是</span><span class="n">x</span><span class="err">轴正方向向右，</span><span class="n">y</span><span class="err">轴正方向向上的，后面不再重复</span><span class="o">&lt;/</span><span class="k">strong</span><span class="o">&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;!--</span><span class="n">more</span><span class="o">--&gt;</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h2</span><span class="o">&gt;</span><span class="bp">SKScene</span><span class="o">&lt;/</span><span class="n">h2</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">虽然是</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKNode</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">的子类的子类，但是因为所有</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKNode</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">都需要在场景上构建布局，所以比较重要，其原点在左下角，</span><span class="n">y</span><span class="err">轴向上，</span><span class="n">x</span><span class="err">轴向右；正是因为</span><span class="bp">UIView</span><span class="err">的原点在左上角，</span><span class="n">y</span><span class="err">轴向下，</span><span class="n">x</span><span class="err">轴向右，所以在</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKScene</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">中判别手势坐标的时候需要将</span><span class="n">y</span><span class="err">轴反向：</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span> <span class="n">objc</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">ndash</span><span class="p">;</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="nl">handlePanFrom</span><span class="p">:(</span><span class="bp">UIPanGestureRecognizer</span> <span class="o">*</span><span class="p">)</span><span class="n">recognizer</span> <span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="n">recognizer</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateBegan</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">touchLocation</span> <span class="o">=</span> <span class="p">[</span><span class="n">recognizer</span> <span class="nl">locationInView</span><span class="p">:</span><span class="n">recognizer</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>    <span class="n">touchLocation</span> <span class="o">=</span> <span class="p">[</span><span class="nb">self</span> <span class="nl">convertPointFromView</span><span class="p">:</span><span class="n">touchLocation</span><span class="p">];</span>
</span><span class='line'>    <span class="n">AtomNode</span> <span class="o">*</span><span class="n">touchedNode</span> <span class="o">=</span> <span class="p">(</span><span class="n">AtomNode</span> <span class="o">*</span><span class="p">)[</span><span class="nb">self</span> <span class="nl">nodeAtPoint</span><span class="p">:</span><span class="n">touchLocation</span><span class="p">];</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">isAllAtomStatic</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;</span><span class="o">&amp;</span><span class="n">amp</span><span class="p">;[</span><span class="n">touchedNode</span><span class="p">.</span><span class="n">name</span> <span class="nl">isEqualToString</span><span class="p">:</span><span class="n">AtomName</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">touchedAtom</span> <span class="o">=</span> <span class="n">touchedNode</span><span class="p">;</span>
</span><span class='line'>        <span class="n">isPanningAtom</span> <span class="o">=</span> <span class="nb">YES</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>
</span><span class='line'>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">recognizer</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateChanged</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="bp">CGPoint</span> <span class="n">translation</span> <span class="o">=</span> <span class="p">[</span><span class="n">recognizer</span> <span class="nl">translationInView</span><span class="p">:</span><span class="n">recognizer</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>    <span class="n">translation</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">translation</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">translation</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">isPanningAtom</span><span class="o">==</span><span class="nb">YES</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="n">touchedAtom</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">CGPointMake</span><span class="p">(</span><span class="n">touchedAtom</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">x</span><span class="o">+</span><span class="n">translation</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">touchedAtom</span><span class="p">.</span><span class="n">position</span><span class="p">.</span><span class="n">y</span><span class="o">+</span><span class="n">translation</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'>    <span class="p">[</span><span class="n">recognizer</span> <span class="nl">setTranslation</span><span class="p">:</span><span class="n">CGPointZero</span> <span class="nl">inView</span><span class="p">:</span><span class="n">recognizer</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">recognizer</span><span class="p">.</span><span class="n">state</span> <span class="o">==</span> <span class="n">UIGestureRecognizerStateEnded</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>
</span><span class='line'>    <span class="k">if</span> <span class="p">(</span><span class="n">isPanningAtom</span><span class="o">==</span><span class="nb">YES</span><span class="p">)</span> <span class="p">{</span>
</span><span class='line'>        <span class="bp">CGPoint</span> <span class="n">velocity</span> <span class="o">=</span> <span class="p">[</span><span class="n">recognizer</span> <span class="nl">velocityInView</span><span class="p">:</span><span class="n">recognizer</span><span class="p">.</span><span class="n">view</span><span class="p">];</span>
</span><span class='line'>        <span class="n">touchedAtom</span><span class="p">.</span><span class="n">physicsBody</span><span class="p">.</span><span class="n">velocity</span> <span class="o">=</span><span class="n">CGVectorMake</span><span class="p">(</span><span class="n">velocity</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="o">-</span><span class="n">velocity</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
</span><span class='line'>        <span class="n">isPanningAtom</span> <span class="o">=</span> <span class="nb">NO</span><span class="p">;</span>
</span><span class='line'>    <span class="p">}</span>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>在第一个判断分支中，因为用了<code>convertPointFromView</code>方法，已经将<code>CGPoint</code>从<code>UIView</code>坐标系转为<code>SKScene</code>坐标系，所以不用反转，其余两个分支中的代码均需要反转y轴。</p>

<h2>SKNode</h2>

<p>SKNode的原点在正中央，也就是(0.5,0.5)<br/>
我构建了一个App，分别将被测试的Node放置在场景中央，并用一个黑色的小圆圈代表Node的坐标系的原点<br/>
因为SKNode比较抽象，没填充内容，所以只显示了一个原点：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353411185.png" alt="" /></p>

<p>如果想填充些东西来证明SKNode的坐标系原点的确在其中央，将下面代码注释部分取消注释即可：</p>

<p>&#8220;`</p>

<h1>import &ldquo;NodeButton.h&rdquo;</h1>

<p>@implementation NodeButton
&ndash;(id)init{</p>

<pre><code>if (self = [super initWithName:@"SKNode"]) {
    SKNode *sknode = (SKNode *)self.node;
    SKSpriteNode *fill = [[SKSpriteNode alloc] init];
    fill.size = CGSizeMake(100, 100);
    fill.color = [UIColor redColor];
    fill.colorBlendFactor = 1;
</code></pre>

<p>//        [sknode addChild:fill];</p>

<pre><code>}
return self;
</code></pre>

<p>}
@end
<figure class='code'><figcaption><span></span></figcaption><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
</pre></td><td class='code'><pre><code class='objc'><span class='line'><span class="o">&lt;</span><span class="n">h2</span><span class="o">&gt;</span><span class="bp">SKEmitterNode</span><span class="o">&lt;/</span><span class="n">h2</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">粒子系统比较有趣，它从原点发射大量粒子，不同的粒子系统也会构筑不同的效果，因为它没有边界，还可调节发射粒子的数量方向速度等，这也使得原点在整个粒子系统中的位置有了错觉，但其本质还是</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span><span class="err">，也就是在中心</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">img</span> <span class="n">src</span><span class="o">=</span><span class="s">&quot;http://yulingtianxia.qiniudn.com/140353410978.png&quot;</span> <span class="n">alt</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="o">/&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">这个火苗看起来中心在哪呢？当然在圆圈处！因为粒子是从圆圈处的区域产生的，然后向上发射</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h2</span><span class="o">&gt;</span><span class="bp">SKLabelNode</span><span class="o">&lt;/</span><span class="n">h2</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">label</span><span class="err">比较特殊，可能是因为需要现实文字的关系吧，其坐标原点在中下方，但不是</span><span class="p">(</span><span class="mf">0.5</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span><span class="err">，因为如果文字包含</span><span class="n">y</span><span class="err">，</span><span class="n">p</span><span class="err">之类的“带尾巴”的字符，那么将会突出十字线下方，可以理解为写英文用的四线本的第三条线？因为字号大小不同或者提子不同，也会影响到原点位置。</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">知道其原点精确位置对于编程来说意义不大，以后有时间会深究下</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;&lt;</span><span class="n">img</span> <span class="n">src</span><span class="o">=</span><span class="s">&quot;http://yulingtianxia.qiniudn.com/140353410886.png&quot;</span> <span class="n">alt</span><span class="o">=</span><span class="s">&quot;&quot;</span> <span class="o">/&gt;&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">h2</span><span class="o">&gt;</span><span class="bp">SKShapeNode</span><span class="o">&lt;/</span><span class="n">h2</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">这个类也很特殊，因为其</span><span class="n">frame</span><span class="err">是根据</span><span class="n">path</span><span class="err">填充内容来确定的，而原点又是其在父坐标的</span><span class="n">position</span><span class="err">处，那么</span><span class="o">&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="bp">SKShapeNode</span><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;</span><span class="err">的原点具体位置在哪也就没意义了，只要按照其</span><span class="n">position</span><span class="err">的位置当作原点建立坐标系就好</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="err">```</span>
</span><span class='line'><span class="k">@implementation</span> <span class="nc">ShapeButton</span>
</span><span class='line'><span class="o">&amp;</span><span class="n">ndash</span><span class="p">;(</span><span class="kt">id</span><span class="p">)</span><span class="n">init</span><span class="p">{</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">pre</span><span class="o">&gt;&lt;</span><span class="n">code</span><span class="o">&gt;</span><span class="k">if</span> <span class="p">(</span><span class="nb">self</span> <span class="o">=</span> <span class="p">[</span><span class="nb">super</span> <span class="nl">initWithName</span><span class="p">:</span><span class="s">@&quot;SKShapeNode&quot;</span><span class="p">])</span> <span class="p">{</span>
</span><span class='line'>    <span class="bp">SKShapeNode</span> <span class="o">*</span><span class="n">shape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">SKShapeNode</span> <span class="o">*</span><span class="p">)</span><span class="nb">self</span><span class="p">.</span><span class="n">node</span><span class="p">;</span>
</span><span class='line'>    <span class="n">shape</span><span class="p">.</span><span class="n">path</span> <span class="o">=</span> <span class="n">CGPathCreateWithRect</span><span class="p">(</span><span class="n">CGRectMake</span><span class="p">(</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span><span class="o">-</span><span class="mi">50</span><span class="p">,</span> <span class="mi">100</span><span class="p">,</span> <span class="mi">100</span><span class="p">),</span> <span class="nb">NULL</span><span class="p">);</span>
</span><span class='line'>    <span class="n">shape</span><span class="p">.</span><span class="n">strokeColor</span> <span class="o">=</span> <span class="p">[</span><span class="bp">UIColor</span> <span class="n">redColor</span><span class="p">];</span>
</span><span class='line'>
</span><span class='line'><span class="p">}</span>
</span><span class='line'><span class="k">return</span> <span class="nb">self</span><span class="p">;</span>
</span><span class='line'><span class="o">&lt;/</span><span class="n">code</span><span class="o">&gt;&lt;/</span><span class="n">pre</span><span class="o">&gt;</span>
</span><span class='line'>
</span><span class='line'><span class="o">&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="p">}</span>
</span><span class='line'><span class="k">@end</span>
</span></code></pre></td></tr></table></div></figure></p>

<p>下图是我故意画了个正方形使其居中：</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353411872.png" alt="" /></p>

<h2>SKSpriteNode</h2>

<p>坐标原点在其frame中心，也就是(0.5,0.5)</p>

<p><img src="http://yulingtianxia.qiniudn.com/140353412174.png" alt="" /></p>

<h2>总结</h2>

<p>其实之所以会出现坐标系原点位置一说，是因为不同类型的Node其frame大小也不一样，而其原点在其frame中的位置也不一样，这就给人一种错觉：有的Node原点在左下角，只暴漏给我们第一象限；有的Node原点在中间，其四个象限都被填充了。。。无论原点在哪，其x轴，y轴方向都是不变的，所以本质都是一样的，只是写代码的时候需要注意，比如如果觉得将一个<code>SKLabelNode</code>的position设置为屏幕中心，则其文字内容就会正好居中，其实那就错了，因为y轴并没有居中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在游戏的SKScene中添加Button]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button/"/>
    <updated>2014-04-27T13:18:04+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button</id>
    <content type="html"><![CDATA[<p>偶然发现<code>SpriteKit</code>中的<code>SKNode</code>也有<code>userInteractionEnabled</code>属性，就像<code>UIKit</code>中的<code>userInteractionEnabled</code>一样，于是我对以前的代码进行重构，发现了在游戏中添加交互button的新的方式（估计很多大神们早就发现了）</p>

<!--more-->


<h2>在SKScene中添加SKNode对象作为Button</h2>

<p>不得不承认，我以前在<code>SKScene</code>中添加一个<code>Button</code>的过程是这样的：</p>

<p><strong>添加一个<code>SKNode</code>（一般都是它的子类：<code>SKLabelNode</code>和<code>SKSpriteNode</code>）属性</strong></p>

<p><code>objc
SKLabelNode *button = [SKLabelNode labelNodeWithFontNamed:@"Chalkduster"];
</code></p>

<p><strong>设置其填充的内容和放置位置，还有<code>SKNode</code>的<code>name</code></strong></p>

<p><code>
button.text = @"Click me";
button.name = @"button";
button.fontSize = 40;
button.fontColor = [SKColor purpleColor];
button.position = CGPointMake(self.size.width/2, self.size.height/2);
[self addChild:button];
</code></p>

<p><strong>在<code>SKScene</code>重写<code>touchesEnded: withEvent:</code>方法，并在方法中判断触摸到哪个<code>SKNode</code></strong></p>

<p>&#8220;`
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event{</p>

<pre><code>UITouch * touch = [touches anyObject];
CGPoint location = [touch locationInNode:self];
SKSpriteNode *touchedNode = (SKSpriteNode *)[self nodeAtPoint:location];
if ([touchedNode.name isEqualToString:@"button"]) {
    //TODO:
}
</code></pre>

<p>}
<code>``
如果某个场景中需要设置很多Button，比如游戏设置界面，那么在</code>touchesEnded: withEvent: `方法中就会出现好多if判断，这么多分支，每个分支可能还有很多操作，这样增加了SKScene的体积，使得代码可读性变差，维护也困难</p>

<h2>通过继承来封装自己的Button</h2>

<p><code>UIKit</code>中的<code>userInteractionEnabled</code>大家一定都很熟悉，它默认值是<code>YES</code>，也就是默认接受触摸事件，偶然发现<code>SKNode</code>也有<code>userInteractionEnabled</code>属性，但是默认值是<code>NO</code>，而且<code>SKNode</code>是继承<code>UIResponder</code>的，这么说，我们可以在SKNode中一展拳脚了，不必再麻烦SKScene了<br/>
下面添加一个用于跳转到主菜单场景页面的Button为例：<br/>
<strong>新建一个类，名字叫MainSceneButton，继承<code>SKLabelNode</code>，并构造出时候方法</strong></p>

<p>&#8220;`
&ndash;(id)init{</p>

<pre><code>if (self = [super initWithFontNamed:@"Chalkduster"]) {
    self.text = @"MENU";
    self.fontSize = 20;
    self.userInteractionEnabled = YES;
}
return self;
</code></pre>

<p>}</p>

<p><code>``
这里碰到一个问题：如果用上面的代码初始化，将会出现</code>EXC_BAD_ACCESS` 错误，问题的解决方法是在超类初始化时用init方法代替，然后再设置字体：</p>

<p>&#8220;`
&ndash;(id)init{</p>

<pre><code>if (self = [super init]) {
    self.fontName = @"Chalkduster";
    self.text = @"MENU";
    self.fontSize = 20;
    self.userInteractionEnabled = YES;
}
return self;
</code></pre>

<p>}
<code>``
至于原因，我也没弄清楚，估计是</code>SKLabelNode<code>的bug吧，因为初始化</code>SKSpriteNode<code>时用</code>initWithTexture: color: size:<code>方法就不会报错  
**在MainSceneButton中重写</code>touchesEnded: withEvent: `方法**</p>

<p>&#8220;`
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event{</p>

<pre><code>SKTransition *reveal = [SKTransition flipHorizontalWithDuration:0.5];
SKScene * myScene = [[MainScene alloc] initWithSize:self.scene.size];
[self.scene.view presentScene:myScene transition: reveal];
</code></pre>

<p>}
&#8220;`
MainScene是我的一个SKScene，通过点击MainSceneButton来切换到MainScene<br/>
<strong>最后在某个场景中将button添加上去，跟之前的类似</strong></p>

<p><code>
MainSceneButton *mainScene = [[MainSceneButton alloc] init];
mainScene.position = CGPointMake(self.size.width/2, self.size.height/2);
[self addChild:mainScene];
</code>
感觉这样做是不是很像以前继承一个UIView然后封装自己的Custom View呢？给SKScene瘦身的方法还有很多，参照给UIViewController瘦身的方法，我们还可以把其他SKNode也从SKScene中剥离出去，一些用于设置SKNode的方法也会随之剥离到自定义的类中，便于以后维护代码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7字体汇总]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/24/ios7zi-ti-hui-zong/"/>
    <updated>2014-04-24T18:12:43+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/24/ios7zi-ti-hui-zong</id>
    <content type="html"><![CDATA[<p>本文列举了iOS7所有字体以及获取字体的方式</p>

<!--more-->


<p>运行下面的代码可以获得所有的字体样式</p>

<p>&#8220;` objc</p>

<pre><code>    NSArray *familyNames = [UIFont familyNames];

    for( NSString *familyName in familyNames ){

        NSLog(@"Family: %@",familyName);

        NSArray *fontNames = [UIFont fontNamesForFamilyName:familyName];
        for( NSString *fontName in fontNames ){
            NSLog(@"Font: %@",fontName);
        }

    } 
</code></pre>

<p>&#8220;`</p>

<p>在iOS7运行，获得结果如下：</p>

<p> Family: Marion<br/>
 Font: Marion-Italic<br/>
 Font: Marion-Bold<br/>
 Font: Marion-Regular<br/>
 Family: Copperplate<br/>
 Font: Copperplate-Light<br/>
 Font: Copperplate<br/>
 Font: Copperplate-Bold<br/>
 Family: Heiti SC<br/>
 Font: STHeitiSC-Medium<br/>
 Font: STHeitiSC-Light<br/>
 Family: Iowan Old Style<br/>
 Font: IowanOldStyle-Italic<br/>
 Font: IowanOldStyle-Roman<br/>
 Font: IowanOldStyle-BoldItalic<br/>
 Font: IowanOldStyle-Bold<br/>
 Family: Courier New<br/>
 Font: CourierNewPS-BoldMT<br/>
 Font: CourierNewPS-ItalicMT<br/>
 Font: CourierNewPSMT<br/>
 Font: CourierNewPS-BoldItalicMT<br/>
 Family: Apple SD Gothic Neo<br/>
 Font: AppleSDGothicNeo-Bold<br/>
 Font: AppleSDGothicNeo-Thin<br/>
 Font: AppleSDGothicNeo-Regular<br/>
 Font: AppleSDGothicNeo-Light<br/>
 Font: AppleSDGothicNeo-Medium<br/>
 Font: AppleSDGothicNeo-SemiBold<br/>
 Family: Heiti TC<br/>
 Font: STHeitiTC-Medium<br/>
 Font: STHeitiTC-Light<br/>
 Family: Gill Sans<br/>
 Font: GillSans-Italic<br/>
 Font: GillSans-Bold  <br/>
 Font: GillSans-BoldItalic<br/>
 Font: GillSans-LightItalic<br/>
 Font: GillSans<br/>
 Font: GillSans-Light<br/>
 Family: Thonburi<br/>
 Font: Thonburi<br/>
 Font: Thonburi-Bold<br/>
 Font: Thonburi-Light<br/>
 Family: Marker Felt<br/>
 Font: MarkerFelt-Thin
 Font: MarkerFelt-Wide<br/>
 Family: Avenir Next Condensed<br/>
 Font: AvenirNextCondensed-BoldItalic<br/>
 Font: AvenirNextCondensed-Heavy<br/>
 Font: AvenirNextCondensed-Medium<br/>
 Font: AvenirNextCondensed-Regular<br/>
 Font: AvenirNextCondensed-HeavyItalic<br/>
 Font: AvenirNextCondensed-MediumItalic<br/>
 Font: AvenirNextCondensed-Italic<br/>
 Font: AvenirNextCondensed-UltraLightItalic<br/>
 Font: AvenirNextCondensed-UltraLight<br/>
 Font: AvenirNextCondensed-DemiBold<br/>
 Font: AvenirNextCondensed-Bold<br/>
 Font: AvenirNextCondensed-DemiBoldItalic<br/>
 Family: Tamil Sangam MN<br/>
 Font: TamilSangamMN<br/>
 Font: TamilSangamMN-Bold<br/>
 Family: Helvetica Neue<br/>
 Font: HelveticaNeue-Italic<br/>
 Font: HelveticaNeue-Bold<br/>
 Font: HelveticaNeue-UltraLight<br/>
 Font: HelveticaNeue-CondensedBlack<br/>
 Font: HelveticaNeue-BoldItalic<br/>
 Font: HelveticaNeue-CondensedBold<br/>
 Font: HelveticaNeue-Medium<br/>
 Font: HelveticaNeue-Light  <br/>
 Font: HelveticaNeue-Thin<br/>
 Font: HelveticaNeue-ThinItalic<br/>
 Font: HelveticaNeue-LightItalic<br/>
 Font: HelveticaNeue-UltraLightItalic<br/>
 Font: HelveticaNeue-MediumItalicv
 Font: HelveticaNeue<br/>
 Family: Gurmukhi MN<br/>
 Font: GurmukhiMN-Bold<br/>
 Font: GurmukhiMN<br/>
 Family: Times New Roman<br/>
 Font: TimesNewRomanPSMTv
 Font: TimesNewRomanPS-BoldItalicMT<br/>
 Font: TimesNewRomanPS-ItalicMT<br/>
 Font: TimesNewRomanPS-BoldMT<br/>
 Family: Georgia<br/>
 Font: Georgia-BoldItalic<br/>
 Font: Georgia  <br/>
 Font: Georgia-Italic<br/>
 Font: Georgia-Bold<br/>
 Family: Apple Color Emoji<br/>
 Font: AppleColorEmoji<br/>
 Family: Arial Rounded MT Bold<br/>
 Font: ArialRoundedMTBold<br/>
 Family: Kailasa<br/>
 Font: Kailasa-Bold<br/>
 Font: Kailasa<br/>
 Family: Sinhala Sangam MN<br/>
 Font: SinhalaSangamMN-Bold<br/>
 Font: SinhalaSangamMN<br/>
 Family: Chalkboard SE<br/>
 Font: ChalkboardSE-Bold<br/>
 Font: ChalkboardSE-Light<br/>
 Font: ChalkboardSE-Regular<br/>
 Family: Superclarendon<br/>
 Font: Superclarendon-Italic<br/>
 Font: Superclarendon-Black<br/>
 Font: Superclarendon-LightItalic
 Font: Superclarendon-BlackItalic<br/>
 Font: Superclarendon-BoldItalic<br/>
 Font: Superclarendon-Light<br/>
 Font: Superclarendon-Regular<br/>
 Font: Superclarendon-Bold<br/>
 Family: Gujarati Sangam MN<br/>
 Font: GujaratiSangamMN-Bold<br/>
 Font: GujaratiSangamMN<br/>
 Family: Geeza Pro<br/>
 Font: GeezaPro-Light<br/>
 Font: GeezaPro<br/>
 Font: GeezaPro-Bold<br/>
 Family: Noteworthy<br/>
 Font: Noteworthy-Light<br/>
 Font: Noteworthy-Bold<br/>
 Family: Damascus<br/>
 Font: DamascusBold<br/>
 Font: DamascusSemiBold<br/>
 Font: DamascusMedium<br/>
 Font: Damascus
 Family: Avenir<br/>
 Font: Avenir-Medium<br/>
 Font: Avenir-HeavyOblique<br/>
 Font: Avenir-Book<br/>
 Font: Avenir-Light<br/>
 Font: Avenir-Roman<br/>
 Font: Avenir-BookOblique<br/>
 Font: Avenir-Black<br/>
 Font: Avenir-MediumOblique<br/>
 Font: Avenir-BlackOblique<br/>
 Font: Avenir-Heavy<br/>
 Font: Avenir-LightOblique<br/>
 Font: Avenir-Oblique<br/>
 Family: Academy Engraved LET<br/>
 Font: AcademyEngravedLetPlain<br/>
 Family: Mishafi<br/>
 Font: DiwanMishafi<br/>
 Family: Futura<br/>
 Font: Futura-CondensedMedium<br/>
 Font: Futura-CondensedExtraBold<br/>
 Font: Futura-Medium<br/>
 Font: Futura-MediumItalicv
 Family: Farah<br/>
 Font: Farah<br/>
 Family: Kannada Sangam MN<br/>
 Font: KannadaSangamMN<br/>
 Font: KannadaSangamMN-Bold<br/>
 Family: Arial Hebrew<br/>
 Font: ArialHebrew-Bold<br/>
 Font: ArialHebrew-Light<br/>
 Font: ArialHebrew<br/>
 Family: Arial<br/>
 Font: ArialMT<br/>
 Font: Arial-BoldItalicMT<br/>
 Font: Arial-BoldMT<br/>
 Font: Arial-ItalicMT<br/>
 Family: Party LET<br/>
 Font: PartyLetPlain<br/>
 Family: Chalkduster<br/>
 Font: Chalkduster<br/>
 Family: Hiragino Kaku Gothic ProN<br/>
 Font: HiraKakuProN-W6<br/>
 Font: HiraKakuProN-W3  <br/>
 Family: Hoefler Text<br/>
 Font: HoeflerText-Italicv
 Font: HoeflerText-Regular<br/>
 Font: HoeflerText-Black<br/>
 Font: HoeflerText-BlackItalicv
 Family: Optima<br/>
 Font: Optima-Regular<br/>
 Font: Optima-ExtraBlack<br/>
 Font: Optima-BoldItalic<br/>
 Font: Optima-Italic<br/>
 Font: Optima-Bold<br/>
 Family: Palatino<br/>
 Font: Palatino-Bold<br/>
 Font: Palatino-Roman<br/>
 Font: Palatino-BoldItalic<br/>
 Font: Palatino-Italic<br/>
 Family: Malayalam Sangam MN<br/>
 Font: MalayalamSangamMN-Bold<br/>
 Font: MalayalamSangamMN<br/>
 Family: Al Nile<br/>
 Font: AlNile-Bold<br/>
 Font: AlNile<br/>
 Family: Bradley Hand<br/>
 Font: BradleyHandITCTT-Bold<br/>
 Family: Hiragino Mincho ProN<br/>
 Font: HiraMinProN-W6<br/>
 Font: HiraMinProN-W3<br/>
 Family: Trebuchet MS<br/>
 Font: Trebuchet-BoldItalic<br/>
 Font: TrebuchetMS<br/>
 Font: TrebuchetMS-Bold<br/>
 Font: TrebuchetMS-Italic<br/>
 Family: Helvetica<br/>
 Font: Helvetica-Bold<br/>
 Font: Helvetica<br/>
 Font: Helvetica-LightOblique<br/>
 Font: Helvetica-Oblique<br/>
 Font: Helvetica-BoldOblique<br/>
 Font: Helvetica-Light<br/>
 Family: Courier<br/>
 Font: Courier-BoldObliquev
 Font: Courier<br/>
 Font: Courier-Bold<br/>
 Font: Courier-Oblique<br/>
 Family: Cochin<br/>
 Font: Cochin-Bold<br/>
 Font: Cochin<br/>
 Font: Cochin-Italic<br/>
 Font: Cochin-BoldItalic<br/>
 Family: Devanagari Sangam MNv
 Font: DevanagariSangamMN<br/>
 Font: DevanagariSangamMN-Bold<br/>
 Family: Oriya Sangam MN<br/>
 Font: OriyaSangamMN<br/>
 Font: OriyaSangamMN-Bold<br/>
 Family: Snell Roundhand<br/>
 Font: SnellRoundhand-Bold<br/>
 Font: SnellRoundhand<br/>
 Font: SnellRoundhand-Black<br/>
 Family: Zapf Dingbats<br/>
 Font: ZapfDingbatsITC<br/>
 Family: Bodoni 72<br/>
 Font: BodoniSvtyTwoITCTT-Bold<br/>
 Font: BodoniSvtyTwoITCTT-Book<br/>
 Font: BodoniSvtyTwoITCTT-BookIta<br/>
 Family: Verdana<br/>
 Font: Verdana-Italic<br/>
 Font: Verdana-BoldItalic<br/>
 Font: Verdana<br/>
 Font: Verdana-Bold<br/>
 Family: American Typewriter<br/>
 Font: AmericanTypewriter-CondensedLight<br/>
 Font: AmericanTypewriter<br/>
 Font: AmericanTypewriter-CondensedBold<br/>
 Font: AmericanTypewriter-Light<br/>
 Font: AmericanTypewriter-Bold<br/>
 Font: AmericanTypewriter-Condensed<br/>
 Family: Avenir Next<br/>
 Font: AvenirNext-UltraLight<br/>
 Font: AvenirNext-UltraLightItalic<br/>
 Font: AvenirNext-Bold<br/>
 Font: AvenirNext-BoldItalic<br/>
 Font: AvenirNext-DemiBold<br/>
 Font: AvenirNext-DemiBoldItalic<br/>
 Font: AvenirNext-Medium<br/>
 Font: AvenirNext-HeavyItalic<br/>
 Font: AvenirNext-Heavy<br/>
 Font: AvenirNext-Italic<br/>
 Font: AvenirNext-Regular<br/>
 Font: AvenirNext-MediumItalic<br/>
 Family: Baskerville<br/>
 Font: Baskerville-Italic<br/>
 Font: Baskerville-SemiBold<br/>
 Font: Baskerville-BoldItalic<br/>
 Font: Baskerville-SemiBoldItalic<br/>
 Font: Baskerville-Bold<br/>
 Font: Baskerville<br/>
 Family: Didot<br/>
 Font: Didot-Italicv
 Font: Didot-Bold<br/>
 Font: Didot<br/>
 Family: Savoye LET<br/>
 Font: SavoyeLetPlain<br/>
 Family: Bodoni Ornaments<br/>
 Font: BodoniOrnamentsITCTT<br/>
 Family: Symbol<br/>
 Font: Symbol<br/>
 Family: Menlo<br/>
 Font: Menlo-Italic<br/>
 Font: Menlo-Bold<br/>
 Font: Menlo-Regular<br/>
 Font: Menlo-BoldItalic<br/>
 Family: Bodoni 72 Smallcaps<br/>
 Font: BodoniSvtyTwoSCITCTT-Book<br/>
 Family: DIN Alternate<br/>
 Font: DINAlternate-Bold<br/>
 Family: Papyrus<br/>
 Font: Papyrus<br/>
 Font: Papyrus-Condensed<br/>
 Family: Euphemia UCAS<br/>
 Font: EuphemiaUCAS-Italic<br/>
 Font: EuphemiaUCAS<br/>
 Font: EuphemiaUCAS-Bold<br/>
 Family: Telugu Sangam MN<br/>
 Font: TeluguSangamMN<br/>
 Font: TeluguSangamMN-Bold<br/>
 Family: Bangla Sangam MN<br/>
 Font: BanglaSangamMN-Bold<br/>
 Font: BanglaSangamMN<br/>
 Family: Zapfino<br/>
 Font: Zapfino<br/>
 Family: Bodoni 72 Oldstyle<br/>
 Font: BodoniSvtyTwoOSITCTT-Book<br/>
 Font: BodoniSvtyTwoOSITCTT-Bold<br/>
 Font: BodoniSvtyTwoOSITCTT-BookIt<br/>
 Family: DIN Condensed<br/>
 Font: DINCondensed-Bold</p>
]]></content>
  </entry>
  
</feed>
