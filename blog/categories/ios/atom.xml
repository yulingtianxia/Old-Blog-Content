<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-06-18T17:00:03+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SpriteKit坐标系]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/04/spritekitzuo-biao-xi/"/>
    <updated>2014-05-04T19:36:26+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/04/spritekitzuo-biao-xi</id>
    <content type="html"><![CDATA[<p>前一阵子在用SpriteKit写一个小游戏的时候，因为对坐标系系统不是很熟悉，结果耽误了不少时间，现在将这些SKNode(及其子类)中常用的部分记下来，以利于以后快速查找</p>

<p>本文测试用到的工程代码可以在<a href="https://github.com/yulingtianxia/NodesCoordinates/tree/master">这里</a>下载</p>

<p><strong>一般来说，SpriteKit中所有坐标系都是x轴正方向向右，y轴正方向向上的，后面不再重复</strong></p>

<!--more-->


<h2>SKScene</h2>

<p>虽然是<code>SKNode</code>的子类的子类，但是因为所有<code>SKNode</code>都需要在场景上构建布局，所以比较重要，其原点在左下角，y轴向上，x轴向右；正是因为UIView的原点在左上角，y轴向下，x轴向右，所以在<code>SKScene</code>中判别手势坐标的时候需要将y轴反向：</p>

<p>``` objc
&ndash; (void)handlePanFrom:(UIPanGestureRecognizer *)recognizer {</p>

<pre><code>if (recognizer.state == UIGestureRecognizerStateBegan) {
    CGPoint touchLocation = [recognizer locationInView:recognizer.view];
    touchLocation = [self convertPointFromView:touchLocation];
    AtomNode *touchedNode = (AtomNode *)[self nodeAtPoint:touchLocation];
    if (isAllAtomStatic&amp;&amp;[touchedNode.name isEqualToString:AtomName]) {
        touchedAtom = touchedNode;
        isPanningAtom = YES;
    }


} else if (recognizer.state == UIGestureRecognizerStateChanged) {

    CGPoint translation = [recognizer translationInView:recognizer.view];
    translation = CGPointMake(translation.x, -translation.y);
    if (isPanningAtom==YES) {
        touchedAtom.position = CGPointMake(touchedAtom.position.x+translation.x, touchedAtom.position.y+translation.y);
    }
    [recognizer setTranslation:CGPointZero inView:recognizer.view];

} else if (recognizer.state == UIGestureRecognizerStateEnded) {

    if (isPanningAtom==YES) {
        CGPoint velocity = [recognizer velocityInView:recognizer.view];
        touchedAtom.physicsBody.velocity =CGVectorMake(velocity.x, -velocity.y);
        isPanningAtom = NO;
    }
}
</code></pre>

<p>}
```</p>

<p>在第一个判断分支中，因为用了<code>convertPointFromView</code>方法，已经将<code>CGPoint</code>从<code>UIView</code>坐标系转为<code>SKScene</code>坐标系，所以不用反转，其余两个分支中的代码均需要反转y轴。</p>

<h2>SKNode</h2>

<p>SKNode的原点在正中央，也就是(0.5,0.5)<br/>
我构建了一个App，分别将被测试的Node放置在场景中央，并用一个黑色的小圆圈代表Node的坐标系的原点<br/>
因为SKNode比较抽象，没填充内容，所以只显示了一个原点：</p>

<p><img src="/images/blog/SKNode.png" alt="" /></p>

<p>如果想填充些东西来证明SKNode的坐标系原点的确在其中央，将下面代码注释部分取消注释即可：</p>

<p>```</p>

<h1>import &ldquo;NodeButton.h&rdquo;</h1>

<p>@implementation NodeButton
&ndash;(id)init{</p>

<pre><code>if (self = [super initWithName:@"SKNode"]) {
    SKNode *sknode = (SKNode *)self.node;
    SKSpriteNode *fill = [[SKSpriteNode alloc] init];
    fill.size = CGSizeMake(100, 100);
    fill.color = [UIColor redColor];
    fill.colorBlendFactor = 1;
</code></pre>

<p>//        [sknode addChild:fill];</p>

<pre><code>}
return self;
</code></pre>

<p>}
@end
```</p>

<h2>SKEmitterNode</h2>

<p>粒子系统比较有趣，它从原点发射大量粒子，不同的粒子系统也会构筑不同的效果，因为它没有边界，还可调节发射粒子的数量方向速度等，这也使得原点在整个粒子系统中的位置有了错觉，但其本质还是(0.5,0.5)，也就是在中心</p>

<p><img src="/images/blog/SKEmitterNode.png" alt="" /></p>

<p>这个火苗看起来中心在哪呢？当然在圆圈处！因为粒子是从圆圈处的区域产生的，然后向上发射</p>

<h2>SKLabelNode</h2>

<p>label比较特殊，可能是因为需要现实文字的关系吧，其坐标原点在中下方，但不是(0.5,0)，因为如果文字包含y，p之类的“带尾巴”的字符，那么将会突出十字线下方，可以理解为写英文用的四线本的第三条线？因为字号大小不同或者提子不同，也会影响到原点位置。</p>

<p>知道其原点精确位置对于编程来说意义不大，以后有时间会深究下</p>

<p><img src="/images/blog/SKLabelNode.png" alt="" /></p>

<h2>SKShapeNode</h2>

<p>这个类也很特殊，因为其frame是根据path填充内容来确定的，而原点又是其在父坐标的position处，那么<code>SKShapeNode</code>的原点具体位置在哪也就没意义了，只要按照其position的位置当作原点建立坐标系就好</p>

<p>```
@implementation ShapeButton
&ndash;(id)init{</p>

<pre><code>if (self = [super initWithName:@"SKShapeNode"]) {
    SKShapeNode *shape = (SKShapeNode *)self.node;
    shape.path = CGPathCreateWithRect(CGRectMake(-50,-50, 100, 100), NULL);
    shape.strokeColor = [UIColor redColor];

}
return self;
</code></pre>

<p>}
@end
```</p>

<p>下图是我故意画了个正方形使其居中：</p>

<p><img src="/images/blog/SKShapeNode.png" alt="" /></p>

<h2>SKSpriteNode</h2>

<p>坐标原点在其frame中心，也就是(0.5,0.5)</p>

<p><img src="/images/blog/SKSpriteNode.png" alt="" /></p>

<h2>总结</h2>

<p>其实之所以会出现坐标系原点位置一说，是因为不同类型的Node其frame大小也不一样，而其原点在其frame中的位置也不一样，这就给人一种错觉：有的Node原点在左下角，只暴漏给我们第一象限；有的Node原点在中间，其四个象限都被填充了。。。无论原点在哪，其x轴，y轴方向都是不变的，所以本质都是一样的，只是写代码的时候需要注意，比如如果觉得将一个<code>SKLabelNode</code>的position设置为屏幕中心，则其文字内容就会正好居中，其实那就错了，因为y轴并没有居中。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS单元测试-XCTest]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/28/iosdan-yuan-ce-shi-xctest/"/>
    <updated>2014-04-28T13:25:12+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/28/iosdan-yuan-ce-shi-xctest</id>
    <content type="html"><![CDATA[<p>第一次接触单元测试还是在SQA课程上，那时我用的是JUnit来对Java程序进行单元测试。如今XCode自带的单元测试工具已经从OCUnit演变到了XCTest，但其本质还是差不多的，其好处在于XCode集成，简单方便</p>

<!--more-->


<p>在XCode5中新建一个工程的时候，会默认带一个用于单元测试的target，其名字为工程名加Test后缀，并且文件名也以Test结尾。你会发现已经有了一个默认的测试用例，其中有三个方法：<code>setUp</code>,<code>tearDown</code>,<code>testExample</code>。其中<code>testExample</code>方法左侧有一个播放按钮，点击它就会对这个方法进行测试，而在整个文件的<code>@implementation</code>那行也有个同样的按钮，点击后会对当前测试用例的所有方法进行测试，也可通过Command＋U快捷键来触发。这个测试用例类没有头文件，因为测试用例不需要给外部暴漏接口。按照苹果官方的文档，建立一个测试用例的过程应该是这样的：<br/>
1. 建立一个<code>XCTestCase</code>的子类
2. 实现测试方法
3. 选择性的定义一些实例变量来存储fixture的状态
4. 通过重写<code>setUp</code>方法选择性的实例化fixture
5. 通过重写<code>tearDown</code>方法来在测试后清除
测试方法没有参数和返回值，用test作为前缀，比如：</p>

<p><code>objc
 - (void) testSomething;
</code>
会自动被<code>XCTest</code>架构识别为测试用例，每个<code>XCTestCase</code>的子类中的<code>defaultTestSuite</code>都是一个<code>XCTestSuite</code>，它包含了这些测试用例。<br/>
测试方法的实现经常包含断言，必须通过验证才能通过测试，举个例子：</p>

<p>```
 @interface MathTest : XCTestCase {
 @private</p>

<pre><code>float f1;
float f2;
</code></pre>

<p> }</p>

<ul>
<li>(void) testAddition;</li>
</ul>


<p> @end</p>

<p> @implementation MathTest</p>

<ul>
<li><p>(void) setUp
{
 f1 = 2.0;
 f2 = 3.0;
}</p></li>
<li><p>(void) testAddition
{
 XCTAssertTrue (f1 + f2 == 5.0, @&ldquo;%f + %f should equal 5.0&rdquo;, f1, f2);
}
@end
```
感觉这根JUnit很像的，下面列出所有的断言：<br/>
XCTFail(format…) 生成一个失败的测试；</p></li>
</ul>


<p>XCTAssertNil(a1, format&hellip;)为空判断，a1为空时通过，反之不通过；</p>

<p>XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；</p>

<p>XCTAssert(expression, format&hellip;)当expression求值为TRUE时通过；</p>

<p>XCTAssertTrue(expression, format&hellip;)当expression求值为TRUE时通过；</p>

<p>XCTAssertFalse(expression, format&hellip;)当expression求值为False时通过；</p>

<p>XCTAssertEqualObjects(a1, a2, format&hellip;)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；</p>

<p>XCTAssertNotEqualObjects(a1, a2, format&hellip;)判断不等，[a1 isEqual:a2]值为False时通过，</p>

<p>XCTAssertEqual(a1, a2, format&hellip;)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</p>

<p>XCTAssertNotEqual(a1, a2, format&hellip;)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</p>

<p>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format&hellip;)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</p>

<p>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format&hellip;) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</p>

<p>XCTAssertThrows(expression, format&hellip;)异常测试，当expression发生异常时通过；反之不通过；（很变态）</p>

<p>XCTAssertThrowsSpecific(expression, specificException, format&hellip;) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</p>

<p>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format&hellip;)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p>

<p>XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；</p>

<p>XCTAssertNoThrowSpecific(expression, specificException, format&hellip;)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p>

<p>XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format&hellip;)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</p>

<p>关于测试函数执行的顺序：以函数名中test后面的字符大小有关，比如-（void）test001XXX会先于-（void）test002XXX执行；</p>

<p>这里只是Mark下单元测试的基本知识，具体应用的话这里推荐几篇不错的教程：<br/>
<a href="http://objccn.io/issue-1-3/">测试 View Controllers</a><br/>
<a href="http://blog.csdn.net/jymn_chen/article/details/21552941">Xcode 5 单元测试（一）使用XCTest进行单元测试</a><br/>
<a href="http://blog.csdn.net/jymn_chen/article/details/21562869">Xcode 5 单元测试（二）OCMock和GHUnit</a><br/>
可能有的测试工具会用到CocoaPods来管理，给出一篇入门文章：<br/>
<a href="http://blog.csdn.net/mysevenmi/article/details/17878421">iOS中使用cocoaPods管理第三方类库</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在游戏的SKScene中添加Button]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button/"/>
    <updated>2014-04-27T13:18:04+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button</id>
    <content type="html"><![CDATA[<p>偶然发现<code>SpriteKit</code>中的<code>SKNode</code>也有<code>userInteractionEnabled</code>属性，就像<code>UIKit</code>中的<code>userInteractionEnabled</code>一样，于是我对以前的代码进行重构，发现了在游戏中添加交互button的新的方式（估计很多大神们早就发现了）</p>

<!--more-->


<h2>在SKScene中添加SKNode对象作为Button</h2>

<p>不得不承认，我以前在<code>SKScene</code>中添加一个<code>Button</code>的过程是这样的：</p>

<p><strong>添加一个<code>SKNode</code>（一般都是它的子类：<code>SKLabelNode</code>和<code>SKSpriteNode</code>）属性</strong></p>

<p><code>objc
SKLabelNode *button = [SKLabelNode labelNodeWithFontNamed:@"Chalkduster"];
</code></p>

<p><strong>设置其填充的内容和放置位置，还有<code>SKNode</code>的<code>name</code></strong></p>

<p><code>
button.text = @"Click me";
button.name = @"button";
button.fontSize = 40;
button.fontColor = [SKColor purpleColor];
button.position = CGPointMake(self.size.width/2, self.size.height/2);
[self addChild:button];
</code></p>

<p><strong>在<code>SKScene</code>重写<code>touchesEnded: withEvent:</code>方法，并在方法中判断触摸到哪个<code>SKNode</code></strong></p>

<p>```
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event{</p>

<pre><code>UITouch * touch = [touches anyObject];
CGPoint location = [touch locationInNode:self];
SKSpriteNode *touchedNode = (SKSpriteNode *)[self nodeAtPoint:location];
if ([touchedNode.name isEqualToString:@"button"]) {
    //TODO:
}
</code></pre>

<p>}
<code>``
如果某个场景中需要设置很多Button，比如游戏设置界面，那么在</code>touchesEnded: withEvent: `方法中就会出现好多if判断，这么多分支，每个分支可能还有很多操作，这样增加了SKScene的体积，使得代码可读性变差，维护也困难</p>

<h2>通过继承来封装自己的Button</h2>

<p><code>UIKit</code>中的<code>userInteractionEnabled</code>大家一定都很熟悉，它默认值是<code>YES</code>，也就是默认接受触摸事件，偶然发现<code>SKNode</code>也有<code>userInteractionEnabled</code>属性，但是默认值是<code>NO</code>，而且<code>SKNode</code>是继承<code>UIResponder</code>的，这么说，我们可以在SKNode中一展拳脚了，不必再麻烦SKScene了<br/>
下面添加一个用于跳转到主菜单场景页面的Button为例：<br/>
<strong>新建一个类，名字叫MainSceneButton，继承<code>SKLabelNode</code>，并构造出时候方法</strong></p>

<p>```
&ndash;(id)init{</p>

<pre><code>if (self = [super initWithFontNamed:@"Chalkduster"]) {
    self.text = @"MENU";
    self.fontSize = 20;
    self.userInteractionEnabled = YES;
}
return self;
</code></pre>

<p>}</p>

<p><code>``
这里碰到一个问题：如果用上面的代码初始化，将会出现</code>EXC_BAD_ACCESS` 错误，问题的解决方法是在超类初始化时用init方法代替，然后再设置字体：</p>

<p>```
&ndash;(id)init{</p>

<pre><code>if (self = [super init]) {
    self.fontName = @"Chalkduster";
    self.text = @"MENU";
    self.fontSize = 20;
    self.userInteractionEnabled = YES;
}
return self;
</code></pre>

<p>}
<code>``
至于原因，我也没弄清楚，估计是</code>SKLabelNode<code>的bug吧，因为初始化</code>SKSpriteNode<code>时用</code>initWithTexture: color: size:<code>方法就不会报错  
**在MainSceneButton中重写</code>touchesEnded: withEvent: `方法**</p>

<p>```
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event{</p>

<pre><code>SKTransition *reveal = [SKTransition flipHorizontalWithDuration:0.5];
SKScene * myScene = [[MainScene alloc] initWithSize:self.scene.size];
[self.scene.view presentScene:myScene transition: reveal];
</code></pre>

<p>}
```
MainScene是我的一个SKScene，通过点击MainSceneButton来切换到MainScene<br/>
<strong>最后在某个场景中将button添加上去，跟之前的类似</strong></p>

<p><code>
MainSceneButton *mainScene = [[MainSceneButton alloc] init];
mainScene.position = CGPointMake(self.size.width/2, self.size.height/2);
[self addChild:mainScene];
</code>
感觉这样做是不是很像以前继承一个UIView然后封装自己的Custom View呢？给SKScene瘦身的方法还有很多，参照给UIViewController瘦身的方法，我们还可以把其他SKNode也从SKScene中剥离出去，一些用于设置SKNode的方法也会随之剥离到自定义的类中，便于以后维护代码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7字体汇总]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/24/ios7zi-ti-hui-zong/"/>
    <updated>2014-04-24T18:12:43+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/24/ios7zi-ti-hui-zong</id>
    <content type="html"><![CDATA[<p>本文列举了iOS7所有字体以及获取字体的方式</p>

<!--more-->


<p>运行下面的代码可以获得所有的字体样式</p>

<p>``` objc</p>

<pre><code>    NSArray *familyNames = [UIFont familyNames];

    for( NSString *familyName in familyNames ){

        NSLog(@"Family: %@",familyName);

        NSArray *fontNames = [UIFont fontNamesForFamilyName:familyName];
        for( NSString *fontName in fontNames ){
            NSLog(@"Font: %@",fontName);
        }

    } 
</code></pre>

<p>```</p>

<p>在iOS7运行，获得结果如下：</p>

<p> Family: Marion<br/>
 Font: Marion-Italic<br/>
 Font: Marion-Bold<br/>
 Font: Marion-Regular<br/>
 Family: Copperplate<br/>
 Font: Copperplate-Light<br/>
 Font: Copperplate<br/>
 Font: Copperplate-Bold<br/>
 Family: Heiti SC<br/>
 Font: STHeitiSC-Medium<br/>
 Font: STHeitiSC-Light<br/>
 Family: Iowan Old Style<br/>
 Font: IowanOldStyle-Italic<br/>
 Font: IowanOldStyle-Roman<br/>
 Font: IowanOldStyle-BoldItalic<br/>
 Font: IowanOldStyle-Bold<br/>
 Family: Courier New<br/>
 Font: CourierNewPS-BoldMT<br/>
 Font: CourierNewPS-ItalicMT<br/>
 Font: CourierNewPSMT<br/>
 Font: CourierNewPS-BoldItalicMT<br/>
 Family: Apple SD Gothic Neo<br/>
 Font: AppleSDGothicNeo-Bold<br/>
 Font: AppleSDGothicNeo-Thin<br/>
 Font: AppleSDGothicNeo-Regular<br/>
 Font: AppleSDGothicNeo-Light<br/>
 Font: AppleSDGothicNeo-Medium<br/>
 Font: AppleSDGothicNeo-SemiBold<br/>
 Family: Heiti TC<br/>
 Font: STHeitiTC-Medium<br/>
 Font: STHeitiTC-Light<br/>
 Family: Gill Sans<br/>
 Font: GillSans-Italic<br/>
 Font: GillSans-Bold  <br/>
 Font: GillSans-BoldItalic<br/>
 Font: GillSans-LightItalic<br/>
 Font: GillSans<br/>
 Font: GillSans-Light<br/>
 Family: Thonburi<br/>
 Font: Thonburi<br/>
 Font: Thonburi-Bold<br/>
 Font: Thonburi-Light<br/>
 Family: Marker Felt<br/>
 Font: MarkerFelt-Thin
 Font: MarkerFelt-Wide<br/>
 Family: Avenir Next Condensed<br/>
 Font: AvenirNextCondensed-BoldItalic<br/>
 Font: AvenirNextCondensed-Heavy<br/>
 Font: AvenirNextCondensed-Medium<br/>
 Font: AvenirNextCondensed-Regular<br/>
 Font: AvenirNextCondensed-HeavyItalic<br/>
 Font: AvenirNextCondensed-MediumItalic<br/>
 Font: AvenirNextCondensed-Italic<br/>
 Font: AvenirNextCondensed-UltraLightItalic<br/>
 Font: AvenirNextCondensed-UltraLight<br/>
 Font: AvenirNextCondensed-DemiBold<br/>
 Font: AvenirNextCondensed-Bold<br/>
 Font: AvenirNextCondensed-DemiBoldItalic<br/>
 Family: Tamil Sangam MN<br/>
 Font: TamilSangamMN<br/>
 Font: TamilSangamMN-Bold<br/>
 Family: Helvetica Neue<br/>
 Font: HelveticaNeue-Italic<br/>
 Font: HelveticaNeue-Bold<br/>
 Font: HelveticaNeue-UltraLight<br/>
 Font: HelveticaNeue-CondensedBlack<br/>
 Font: HelveticaNeue-BoldItalic<br/>
 Font: HelveticaNeue-CondensedBold<br/>
 Font: HelveticaNeue-Medium<br/>
 Font: HelveticaNeue-Light  <br/>
 Font: HelveticaNeue-Thin<br/>
 Font: HelveticaNeue-ThinItalic<br/>
 Font: HelveticaNeue-LightItalic<br/>
 Font: HelveticaNeue-UltraLightItalic<br/>
 Font: HelveticaNeue-MediumItalicv
 Font: HelveticaNeue<br/>
 Family: Gurmukhi MN<br/>
 Font: GurmukhiMN-Bold<br/>
 Font: GurmukhiMN<br/>
 Family: Times New Roman<br/>
 Font: TimesNewRomanPSMTv
 Font: TimesNewRomanPS-BoldItalicMT<br/>
 Font: TimesNewRomanPS-ItalicMT<br/>
 Font: TimesNewRomanPS-BoldMT<br/>
 Family: Georgia<br/>
 Font: Georgia-BoldItalic<br/>
 Font: Georgia  <br/>
 Font: Georgia-Italic<br/>
 Font: Georgia-Bold<br/>
 Family: Apple Color Emoji<br/>
 Font: AppleColorEmoji<br/>
 Family: Arial Rounded MT Bold<br/>
 Font: ArialRoundedMTBold<br/>
 Family: Kailasa<br/>
 Font: Kailasa-Bold<br/>
 Font: Kailasa<br/>
 Family: Sinhala Sangam MN<br/>
 Font: SinhalaSangamMN-Bold<br/>
 Font: SinhalaSangamMN<br/>
 Family: Chalkboard SE<br/>
 Font: ChalkboardSE-Bold<br/>
 Font: ChalkboardSE-Light<br/>
 Font: ChalkboardSE-Regular<br/>
 Family: Superclarendon<br/>
 Font: Superclarendon-Italic<br/>
 Font: Superclarendon-Black<br/>
 Font: Superclarendon-LightItalic
 Font: Superclarendon-BlackItalic<br/>
 Font: Superclarendon-BoldItalic<br/>
 Font: Superclarendon-Light<br/>
 Font: Superclarendon-Regular<br/>
 Font: Superclarendon-Bold<br/>
 Family: Gujarati Sangam MN<br/>
 Font: GujaratiSangamMN-Bold<br/>
 Font: GujaratiSangamMN<br/>
 Family: Geeza Pro<br/>
 Font: GeezaPro-Light<br/>
 Font: GeezaPro<br/>
 Font: GeezaPro-Bold<br/>
 Family: Noteworthy<br/>
 Font: Noteworthy-Light<br/>
 Font: Noteworthy-Bold<br/>
 Family: Damascus<br/>
 Font: DamascusBold<br/>
 Font: DamascusSemiBold<br/>
 Font: DamascusMedium<br/>
 Font: Damascus
 Family: Avenir<br/>
 Font: Avenir-Medium<br/>
 Font: Avenir-HeavyOblique<br/>
 Font: Avenir-Book<br/>
 Font: Avenir-Light<br/>
 Font: Avenir-Roman<br/>
 Font: Avenir-BookOblique<br/>
 Font: Avenir-Black<br/>
 Font: Avenir-MediumOblique<br/>
 Font: Avenir-BlackOblique<br/>
 Font: Avenir-Heavy<br/>
 Font: Avenir-LightOblique<br/>
 Font: Avenir-Oblique<br/>
 Family: Academy Engraved LET<br/>
 Font: AcademyEngravedLetPlain<br/>
 Family: Mishafi<br/>
 Font: DiwanMishafi<br/>
 Family: Futura<br/>
 Font: Futura-CondensedMedium<br/>
 Font: Futura-CondensedExtraBold<br/>
 Font: Futura-Medium<br/>
 Font: Futura-MediumItalicv
 Family: Farah<br/>
 Font: Farah<br/>
 Family: Kannada Sangam MN<br/>
 Font: KannadaSangamMN<br/>
 Font: KannadaSangamMN-Bold<br/>
 Family: Arial Hebrew<br/>
 Font: ArialHebrew-Bold<br/>
 Font: ArialHebrew-Light<br/>
 Font: ArialHebrew<br/>
 Family: Arial<br/>
 Font: ArialMT<br/>
 Font: Arial-BoldItalicMT<br/>
 Font: Arial-BoldMT<br/>
 Font: Arial-ItalicMT<br/>
 Family: Party LET<br/>
 Font: PartyLetPlain<br/>
 Family: Chalkduster<br/>
 Font: Chalkduster<br/>
 Family: Hiragino Kaku Gothic ProN<br/>
 Font: HiraKakuProN-W6<br/>
 Font: HiraKakuProN-W3  <br/>
 Family: Hoefler Text<br/>
 Font: HoeflerText-Italicv
 Font: HoeflerText-Regular<br/>
 Font: HoeflerText-Black<br/>
 Font: HoeflerText-BlackItalicv
 Family: Optima<br/>
 Font: Optima-Regular<br/>
 Font: Optima-ExtraBlack<br/>
 Font: Optima-BoldItalic<br/>
 Font: Optima-Italic<br/>
 Font: Optima-Bold<br/>
 Family: Palatino<br/>
 Font: Palatino-Bold<br/>
 Font: Palatino-Roman<br/>
 Font: Palatino-BoldItalic<br/>
 Font: Palatino-Italic<br/>
 Family: Malayalam Sangam MN<br/>
 Font: MalayalamSangamMN-Bold<br/>
 Font: MalayalamSangamMN<br/>
 Family: Al Nile<br/>
 Font: AlNile-Bold<br/>
 Font: AlNile<br/>
 Family: Bradley Hand<br/>
 Font: BradleyHandITCTT-Bold<br/>
 Family: Hiragino Mincho ProN<br/>
 Font: HiraMinProN-W6<br/>
 Font: HiraMinProN-W3<br/>
 Family: Trebuchet MS<br/>
 Font: Trebuchet-BoldItalic<br/>
 Font: TrebuchetMS<br/>
 Font: TrebuchetMS-Bold<br/>
 Font: TrebuchetMS-Italic<br/>
 Family: Helvetica<br/>
 Font: Helvetica-Bold<br/>
 Font: Helvetica<br/>
 Font: Helvetica-LightOblique<br/>
 Font: Helvetica-Oblique<br/>
 Font: Helvetica-BoldOblique<br/>
 Font: Helvetica-Light<br/>
 Family: Courier<br/>
 Font: Courier-BoldObliquev
 Font: Courier<br/>
 Font: Courier-Bold<br/>
 Font: Courier-Oblique<br/>
 Family: Cochin<br/>
 Font: Cochin-Bold<br/>
 Font: Cochin<br/>
 Font: Cochin-Italic<br/>
 Font: Cochin-BoldItalic<br/>
 Family: Devanagari Sangam MNv
 Font: DevanagariSangamMN<br/>
 Font: DevanagariSangamMN-Bold<br/>
 Family: Oriya Sangam MN<br/>
 Font: OriyaSangamMN<br/>
 Font: OriyaSangamMN-Bold<br/>
 Family: Snell Roundhand<br/>
 Font: SnellRoundhand-Bold<br/>
 Font: SnellRoundhand<br/>
 Font: SnellRoundhand-Black<br/>
 Family: Zapf Dingbats<br/>
 Font: ZapfDingbatsITC<br/>
 Family: Bodoni 72<br/>
 Font: BodoniSvtyTwoITCTT-Bold<br/>
 Font: BodoniSvtyTwoITCTT-Book<br/>
 Font: BodoniSvtyTwoITCTT-BookIta<br/>
 Family: Verdana<br/>
 Font: Verdana-Italic<br/>
 Font: Verdana-BoldItalic<br/>
 Font: Verdana<br/>
 Font: Verdana-Bold<br/>
 Family: American Typewriter<br/>
 Font: AmericanTypewriter-CondensedLight<br/>
 Font: AmericanTypewriter<br/>
 Font: AmericanTypewriter-CondensedBold<br/>
 Font: AmericanTypewriter-Light<br/>
 Font: AmericanTypewriter-Bold<br/>
 Font: AmericanTypewriter-Condensed<br/>
 Family: Avenir Next<br/>
 Font: AvenirNext-UltraLight<br/>
 Font: AvenirNext-UltraLightItalic<br/>
 Font: AvenirNext-Bold<br/>
 Font: AvenirNext-BoldItalic<br/>
 Font: AvenirNext-DemiBold<br/>
 Font: AvenirNext-DemiBoldItalic<br/>
 Font: AvenirNext-Medium<br/>
 Font: AvenirNext-HeavyItalic<br/>
 Font: AvenirNext-Heavy<br/>
 Font: AvenirNext-Italic<br/>
 Font: AvenirNext-Regular<br/>
 Font: AvenirNext-MediumItalic<br/>
 Family: Baskerville<br/>
 Font: Baskerville-Italic<br/>
 Font: Baskerville-SemiBold<br/>
 Font: Baskerville-BoldItalic<br/>
 Font: Baskerville-SemiBoldItalic<br/>
 Font: Baskerville-Bold<br/>
 Font: Baskerville<br/>
 Family: Didot<br/>
 Font: Didot-Italicv
 Font: Didot-Bold<br/>
 Font: Didot<br/>
 Family: Savoye LET<br/>
 Font: SavoyeLetPlain<br/>
 Family: Bodoni Ornaments<br/>
 Font: BodoniOrnamentsITCTT<br/>
 Family: Symbol<br/>
 Font: Symbol<br/>
 Family: Menlo<br/>
 Font: Menlo-Italic<br/>
 Font: Menlo-Bold<br/>
 Font: Menlo-Regular<br/>
 Font: Menlo-BoldItalic<br/>
 Family: Bodoni 72 Smallcaps<br/>
 Font: BodoniSvtyTwoSCITCTT-Book<br/>
 Family: DIN Alternate<br/>
 Font: DINAlternate-Bold<br/>
 Family: Papyrus<br/>
 Font: Papyrus<br/>
 Font: Papyrus-Condensed<br/>
 Family: Euphemia UCAS<br/>
 Font: EuphemiaUCAS-Italic<br/>
 Font: EuphemiaUCAS<br/>
 Font: EuphemiaUCAS-Bold<br/>
 Family: Telugu Sangam MN<br/>
 Font: TeluguSangamMN<br/>
 Font: TeluguSangamMN-Bold<br/>
 Family: Bangla Sangam MN<br/>
 Font: BanglaSangamMN-Bold<br/>
 Font: BanglaSangamMN<br/>
 Family: Zapfino<br/>
 Font: Zapfino<br/>
 Family: Bodoni 72 Oldstyle<br/>
 Font: BodoniSvtyTwoOSITCTT-Book<br/>
 Font: BodoniSvtyTwoOSITCTT-Bold<br/>
 Font: BodoniSvtyTwoOSITCTT-BookIt<br/>
 Family: DIN Condensed<br/>
 Font: DINCondensed-Bold</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpriteKit截屏并分享至社交网络]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/22/spritekitjie-ping-bing-fen-xiang-zhi-she-jiao-wang-luo/"/>
    <updated>2014-04-22T17:36:25+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/22/spritekitjie-ping-bing-fen-xiang-zhi-she-jiao-wang-luo</id>
    <content type="html"><![CDATA[<p>本文讲述在用<code>SpriteKit</code>制作iOS游戏的时候，如何让在用户在达到某种成就后分享自己的成就或分数，并附上一张游戏截屏，然后发到社交网络上</p>

<!--more-->


<h2>SpriteKit截屏</h2>

<p>传统的截屏方法是用UIView的layer来读取渲染上下文，生成图片</p>

<p>``` objc</p>

<p>UIGraphicsBeginImageContext(self.view.frame.size); //currentView 当前的view
[self.view.layer renderInContext:UIGraphicsGetCurrentContext()];
UIImage *viewImage = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
```</p>

<p>viewImage就是获取的截图，如果要将图片存入相册，只需在后面调用</p>

<p><code>
UIImageWriteToSavedPhotosAlbum(viewImage,nil,nil,nil);
</code>
而这一切都是基于<code>UIKit</code>的，在<code>SpriteKit</code>中，上面的方法是实效的，截屏的效果就是一张白色图片
但在苹果的官方文档中，明确提到了<code>SKTexture</code>的作用，最后一条是说可以将节点树渲染成纹理，可以应用于对游戏截屏。苹果还告诉了我们<code>SKView</code>的一个方法：<code>textureFromNode:</code>，该方法将以node包含的内容渲染成一个纹理，但是如何将<code>SKTexture</code>转换为<code>UIView</code>呢？我在workoverflow的一个<a href="http://stackoverflow.com/questions/21061248/uiimage-from-sktexture">提问</a>中找到了答案：</p>

<h3>方法一：</h3>

<p>```
&ndash; (UIImage<em>) imageWithView:(UIView </em>)view
{</p>

<pre><code>UIGraphicsBeginImageContextWithOptions(view.bounds.size, view.opaque, 0.0);

[view drawViewHierarchyInRect:view.bounds afterScreenUpdates:YES];

UIImage * img = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

return img;
</code></pre>

<p>}</p>

<ul>
<li><p>(UIImage<em>) imageFromNode:(SKNode</em>)node
{
  SKTexture<em>      tex     = [self.scene.view textureFromNode:node];
  SKView</em>         view    = [[SKView alloc]initWithFrame:CGRectMake(0, 0, tex.size.width, tex.size.height)];
  SKScene<em>        scene   = [SKScene sceneWithSize:tex.size];
  SKSpriteNode</em>   sprite  = [SKSpriteNode spriteNodeWithTexture:tex];
  sprite.position = CGPointMake( CGRectGetMidX(view.frame), CGRectGetMidY(view.frame) );
  [scene addChild:sprite];
  [view presentScene:scene];</p>

<p>  return [self imageWithView:view];
}
```</p></li>
<li>get the SKTexture for your node using the current SKView</li>
<li>make another SKView that is just big enough for your texture</li>
<li>add a SKSpriteNode with the texture into your new scene, placing it in the middle</li>
<li>render the view into a graphics context</li>
</ul>


<h3>方法二:</h3>

<p>```
&ndash;(UIImage <em>)imageFromNode:(SKNode </em>)node {</p>

<pre><code>SKView *view = node.scene.view;
CGFloat scale = [UIScreen mainScreen].scale;
CGRect nodeFrame = [node calculateAccumulatedFrame];

// render SKView into UIImage
UIGraphicsBeginImageContextWithOptions(view.bounds.size, YES, 0.0);
[view drawViewHierarchyInRect:view.bounds afterScreenUpdates:YES];
UIImage *sceneSnapshot = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

// crop to the requested node (making sure to flip the y-coordinate)
CGFloat originY = sceneSnapshot.size.height*scale - nodeFrame.origin.y*scale - nodeFrame.size.height*scale;
CGRect cropRect = CGRectMake(nodeFrame.origin.x * scale, originY, nodeFrame.size.width*scale, nodeFrame.size.height*scale);
CGImageRef croppedSnapshot = CGImageCreateWithImageInRect(sceneSnapshot.CGImage, cropRect);
UIImage *nodeSnapshot = [UIImage imageWithCGImage:croppedSnapshot];
CGImageRelease(croppedSnapshot);

return nodeSnapshot;
</code></pre>

<p>}
```
<strong>以上两个方法亲测好使！</strong></p>

<h2>使用Social.Framework分享游戏战绩</h2>

<p>因为比较懒不想在各种第三方社交网站申请APP注册然后使用SDK等，有点复杂，所以暂时用了苹果自带的Social.Framework</p>

<p>首先推荐一个比较好的<a href="https://github.com/yulingtianxia/ios6ShareDemo.git">Demo</a>，代码很容易读，容易上手</p>

<p>首先到target，Build Phases->link binary with libraries，添加social.framework，然后在要使用这个framework的文件头添加<code>@import Social;</code></p>

<p>记得要到iphone或者simulator里设置好对应社交网络的账号，填上用户名密码登录上，不然找不到account，不能post。如果找不到新浪微博，把系统语言调到中文。如果没有预先设置好账号，social.framework在真机和simulator上表现会不同。</p>

<h3>使用UIActivityViewController</h3>

<p>```
//某个SKScene中添加的代码</p>

<pre><code>    sharingImage = [self imageFromNode:self];//获取截屏图片
    NSArray *activityItems;
    if (sharingImage != nil) {
        activityItems = @[sharingText, sharingImage];
    } else {
        activityItems = @[sharingText];
    }

    UIActivityViewController *activityController =
    [[UIActivityViewController alloc] initWithActivityItems:activityItems
                                      applicationActivities:nil];

    [(UIViewController *)[self.view nextResponder] presentViewController:activityController
                       animated:YES completion:nil];
</code></pre>

<p>```</p>

<p><code>[self.view nextResponder]</code>的作用是获取当前<code>SKScene</code>的<code>UIViewController</code></p>

<p>如果想系统的学一下<code>UIActivityViewController</code>，建立看看这篇翻译自<a href="http://nshipster.com/uiactivityviewcontroller/">Mattt Thompson</a>的<a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-22-ui-activity-viewcontroller.md">博文</a></p>

<h3>使用SLComposeViewController</h3>

<p>这个就相当于上面里介绍的单个分享service
目前支持的平台有以下这些：</p>

<p><code>
SOCIAL_EXTERN NSString *const SLServiceTypeTwitter NS_AVAILABLE(10_8, 6_0);
SOCIAL_EXTERN NSString *const SLServiceTypeFacebook NS_AVAILABLE(10_8, 6_0);
SOCIAL_EXTERN NSString *const SLServiceTypeSinaWeibo NS_AVAILABLE(10_8, 6_0);
SOCIAL_EXTERN NSString *const SLServiceTypeTencentWeibo NS_AVAILABLE(10_9, 7_0);
SOCIAL_EXTERN NSString *const SLServiceTypeLinkedIn NS_AVAILABLE(10_9, NA);
</code>
先声明一个<code>SLComposeViewController *slComposerSheet;</code>，然后在需要添加分享逻辑的地方加入下面代码：(依然以微博为例子)</p>

<p>```</p>

<pre><code>[slComposerSheet setCompletionHandler:^(SLComposeViewControllerResult result) {
    NSLog(@"start completion block");
    NSString *output;
    switch (result) {
        case SLComposeViewControllerResultCancelled:
            output = @"Action Cancelled";
            break;
        case SLComposeViewControllerResultDone:
            output = @"Post Successfull";
            break;
        default:
            break;
    }
    if (result != SLComposeViewControllerResultCancelled)
    {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Weibo Message" message:output delegate:nil cancelButtonTitle:@"Ok" otherButtonTitles:nil];
        [alert show];
    }
}];

if([SLComposeViewController isAvailableForServiceType:SLServiceTypeSinaWeibo])
{
    slComposerSheet = [SLComposeViewController composeViewControllerForServiceType:SLServiceTypeSinaWeibo];
    [slComposerSheet setInitialText:self.sharingText];
    [slComposerSheet addImage:self.sharingImage];
    [slComposerSheet addURL:[NSURL URLWithString:@"http://www.weibo.com/"]];
    [self presentViewController:slComposerSheet animated:YES completion:nil];
}
</code></pre>

<p>```
这种方法我没试过，代码是照抄自前面提到的<a href="https://github.com/yulingtianxia/ios6ShareDemo.git">Demo</a>里</p>
]]></content>
  </entry>
  
</feed>
