<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: iOS | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/ios/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-05-02T14:27:00+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[iOS单元测试－XCTest]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/28/iosdan-yuan-ce-shi-%5Bnil%5Dxctest/"/>
    <updated>2014-04-28T13:25:12+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/28/iosdan-yuan-ce-shi-[nil]xctest</id>
    <content type="html"><![CDATA[<p>第一次接触单元测试还是在SQA课程上，那时我用的是JUnit来对Java程序进行单元测试。如今XCode自带的单元测试工具已经从OCUnit演变到了XCTest，但其本质还是差不多的，其好处在于XCode集成，简单方便</p>

<!--more-->


<p>在XCode5中新建一个工程的时候，会默认带一个用于单元测试的target，其名字为工程名加Test后缀，并且文件名也以Test结尾。你会发现已经有了一个默认的测试用例，其中有三个方法：<code>setUp</code>,<code>tearDown</code>,<code>testExample</code>。其中<code>testExample</code>方法左侧有一个播放按钮，点击它就会对这个方法进行测试，而在整个文件的<code>@implementation</code>那行也有个同样的按钮，点击后会对当前测试用例的所有方法进行测试，也可通过Command＋U快捷键来触发。这个测试用例类没有头文件，因为测试用例不需要给外部暴漏接口。按照苹果官方的文档，建立一个测试用例的过程应该是这样的：<br/>
1. 建立一个<code>XCTestCase</code>的子类
2. 实现测试方法
3. 选择性的定义一些实例变量来存储fixture的状态
4. 通过重写<code>setUp</code>方法选择性的实例化fixture
5. 通过重写<code>tearDown</code>方法来在测试后清除
测试方法没有参数和返回值，用test作为前缀，比如：</p>

<p><code>objc
 - (void) testSomething;
</code>
会自动被<code>XCTest</code>架构识别为测试用例，每个<code>XCTestCase</code>的子类中的<code>defaultTestSuite</code>都是一个<code>XCTestSuite</code>，它包含了这些测试用例。<br/>
测试方法的实现经常包含断言，必须通过验证才能通过测试，举个例子：</p>

<p>```
 @interface MathTest : XCTestCase {
 @private</p>

<pre><code>float f1;
float f2;
</code></pre>

<p> }</p>

<ul>
<li>(void) testAddition;</li>
</ul>


<p> @end</p>

<p> @implementation MathTest</p>

<ul>
<li><p>(void) setUp
{
 f1 = 2.0;
 f2 = 3.0;
}</p></li>
<li><p>(void) testAddition
{
 XCTAssertTrue (f1 + f2 == 5.0, @&ldquo;%f + %f should equal 5.0&rdquo;, f1, f2);
}
@end
```
感觉这根JUnit很像的，下面列出所有的断言：<br/>
XCTFail(format…) 生成一个失败的测试；</p></li>
</ul>


<p>XCTAssertNil(a1, format&hellip;)为空判断，a1为空时通过，反之不通过；</p>

<p>XCTAssertNotNil(a1, format…)不为空判断，a1不为空时通过，反之不通过；</p>

<p>XCTAssert(expression, format&hellip;)当expression求值为TRUE时通过；</p>

<p>XCTAssertTrue(expression, format&hellip;)当expression求值为TRUE时通过；</p>

<p>XCTAssertFalse(expression, format&hellip;)当expression求值为False时通过；</p>

<p>XCTAssertEqualObjects(a1, a2, format&hellip;)判断相等，[a1 isEqual:a2]值为TRUE时通过，其中一个不为空时，不通过；</p>

<p>XCTAssertNotEqualObjects(a1, a2, format&hellip;)判断不等，[a1 isEqual:a2]值为False时通过，</p>

<p>XCTAssertEqual(a1, a2, format&hellip;)判断相等（当a1和a2是 C语言标量、结构体或联合体时使用,实际测试发现NSString也可以）；</p>

<p>XCTAssertNotEqual(a1, a2, format&hellip;)判断不等（当a1和a2是 C语言标量、结构体或联合体时使用）；</p>

<p>XCTAssertEqualWithAccuracy(a1, a2, accuracy, format&hellip;)判断相等，（double或float类型）提供一个误差范围，当在误差范围（+/-accuracy）以内相等时通过测试；</p>

<p>XCTAssertNotEqualWithAccuracy(a1, a2, accuracy, format&hellip;) 判断不等，（double或float类型）提供一个误差范围，当在误差范围以内不等时通过测试；</p>

<p>XCTAssertThrows(expression, format&hellip;)异常测试，当expression发生异常时通过；反之不通过；（很变态）</p>

<p>XCTAssertThrowsSpecific(expression, specificException, format&hellip;) 异常测试，当expression发生specificException异常时通过；反之发生其他异常或不发生异常均不通过；</p>

<p>XCTAssertThrowsSpecificNamed(expression, specificException, exception_name, format&hellip;)异常测试，当expression发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p>

<p>XCTAssertNoThrow(expression, format…)异常测试，当expression没有发生异常时通过测试；</p>

<p>XCTAssertNoThrowSpecific(expression, specificException, format&hellip;)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过；</p>

<p>XCTAssertNoThrowSpecificNamed(expression, specificException, exception_name, format&hellip;)异常测试，当expression没有发生具体异常、具体异常名称的异常时通过测试，反之不通过</p>

<p>关于测试函数执行的顺序：以函数名中test后面的字符大小有关，比如-（void）test001XXX会先于-（void）test002XXX执行；</p>

<p>这里只是Mark下单元测试的基本知识，具体应用的话这里推荐几篇不错的教程：<br/>
<a href="http://objccn.io/issue-1-3/">测试 View Controllers</a><br/>
<a href="http://blog.csdn.net/jymn_chen/article/details/21552941">Xcode 5 单元测试（一）使用XCTest进行单元测试</a><br/>
<a href="http://blog.csdn.net/jymn_chen/article/details/21562869">Xcode 5 单元测试（二）OCMock和GHUnit</a><br/>
可能有的测试工具会用到CocoaPods来管理，给出一篇入门文章：<br/>
<a href="http://blog.csdn.net/mysevenmi/article/details/17878421">iOS中使用cocoaPods管理第三方类库</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[在游戏的SKScene中添加Button]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button/"/>
    <updated>2014-04-27T13:18:04+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/27/zai-you-xi-de-skscenezhong-tian-jia-button</id>
    <content type="html"><![CDATA[<p>偶然发现<code>SpriteKit</code>中的<code>SKNode</code>也有<code>userInteractionEnabled</code>属性，就像<code>UIKit</code>中的<code>userInteractionEnabled</code>一样，于是我对以前的代码进行重构，发现了在游戏中添加交互button的新的方式（估计很多大神们早就发现了）</p>

<!--more-->


<h2>在SKScene中添加SKNode对象作为Button</h2>

<p>不得不承认，我以前在<code>SKScene</code>中添加一个<code>Button</code>的过程是这样的：</p>

<p><strong>添加一个<code>SKNode</code>（一般都是它的子类：<code>SKLabelNode</code>和<code>SKSpriteNode</code>）属性</strong></p>

<p><code>objc
SKLabelNode *button = [SKLabelNode labelNodeWithFontNamed:@"Chalkduster"];
</code></p>

<p><strong>设置其填充的内容和放置位置，还有<code>SKNode</code>的<code>name</code></strong></p>

<p><code>
button.text = @"Click me";
button.name = @"button";
button.fontSize = 40;
button.fontColor = [SKColor purpleColor];
button.position = CGPointMake(self.size.width/2, self.size.height/2);
[self addChild:button];
</code></p>

<p><strong>在<code>SKScene</code>重写<code>touchesEnded: withEvent:</code>方法，并在方法中判断触摸到哪个<code>SKNode</code></strong></p>

<p>```
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event{</p>

<pre><code>UITouch * touch = [touches anyObject];
CGPoint location = [touch locationInNode:self];
SKSpriteNode *touchedNode = (SKSpriteNode *)[self nodeAtPoint:location];
if ([touchedNode.name isEqualToString:@"button"]) {
    //TODO:
}
</code></pre>

<p>}
<code>``
如果某个场景中需要设置很多Button，比如游戏设置界面，那么在</code>touchesEnded: withEvent: `方法中就会出现好多if判断，这么多分支，每个分支可能还有很多操作，这样增加了SKScene的体积，使得代码可读性变差，维护也困难</p>

<h2>通过继承来封装自己的Button</h2>

<p><code>UIKit</code>中的<code>userInteractionEnabled</code>大家一定都很熟悉，它默认值是<code>YES</code>，也就是默认接受触摸事件，偶然发现<code>SKNode</code>也有<code>userInteractionEnabled</code>属性，但是默认值是<code>NO</code>，而且<code>SKNode</code>是继承<code>UIResponder</code>的，这么说，我们可以在SKNode中一展拳脚了，不必再麻烦SKScene了<br/>
下面添加一个用于跳转到主菜单场景页面的Button为例：<br/>
<strong>新建一个类，名字叫MainSceneButton，继承<code>SKLabelNode</code>，并构造出时候方法</strong></p>

<p>```
&ndash;(id)init{</p>

<pre><code>if (self = [super initWithFontNamed:@"Chalkduster"]) {
    self.text = @"MENU";
    self.fontSize = 20;
    self.userInteractionEnabled = YES;
}
return self;
</code></pre>

<p>}</p>

<p><code>``
这里碰到一个问题：如果用上面的代码初始化，将会出现</code>EXC_BAD_ACCESS` 错误，问题的解决方法是在超类初始化时用init方法代替，然后再设置字体：</p>

<p>```
&ndash;(id)init{</p>

<pre><code>if (self = [super init]) {
    self.fontName = @"Chalkduster";
    self.text = @"MENU";
    self.fontSize = 20;
    self.userInteractionEnabled = YES;
}
return self;
</code></pre>

<p>}
<code>``
至于原因，我也没弄清楚，估计是</code>SKLabelNode<code>的bug吧，因为初始化</code>SKSpriteNode<code>时用</code>initWithTexture: color: size:<code>方法就不会报错  
**在MainSceneButton中重写</code>touchesEnded: withEvent: `方法**</p>

<p>```
&ndash;(void)touchesEnded:(NSSet <em>)touches withEvent:(UIEvent </em>)event{</p>

<pre><code>SKTransition *reveal = [SKTransition flipHorizontalWithDuration:0.5];
SKScene * myScene = [[MainScene alloc] initWithSize:self.scene.size];
[self.scene.view presentScene:myScene transition: reveal];
</code></pre>

<p>}
```
MainScene是我的一个SKScene，通过点击MainSceneButton来切换到MainScene<br/>
<strong>最后在某个场景中将button添加上去，跟之前的类似</strong></p>

<p><code>
MainSceneButton *mainScene = [[MainSceneButton alloc] init];
mainScene.position = CGPointMake(self.size.width/2, self.size.height/2);
[self addChild:mainScene];
</code>
感觉这样做是不是很像以前继承一个UIView然后封装自己的Custom View呢？给SKScene瘦身的方法还有很多，参照给UIViewController瘦身的方法，我们还可以把其他SKNode也从SKScene中剥离出去，一些用于设置SKNode的方法也会随之剥离到自定义的类中，便于以后维护代码</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[iOS7字体汇总]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/24/ios7zi-ti-hui-zong/"/>
    <updated>2014-04-24T18:12:43+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/24/ios7zi-ti-hui-zong</id>
    <content type="html"><![CDATA[<p>本文列举了iOS7所有字体以及获取字体的方式</p>

<!--more-->


<p>运行下面的代码可以获得所有的字体样式</p>

<p>``` objc</p>

<pre><code>    NSArray *familyNames = [UIFont familyNames];

    for( NSString *familyName in familyNames ){

        NSLog(@"Family: %@",familyName);

        NSArray *fontNames = [UIFont fontNamesForFamilyName:familyName];
        for( NSString *fontName in fontNames ){
            NSLog(@"Font: %@",fontName);
        }

    } 
</code></pre>

<p>```</p>

<p>在iOS7运行，获得结果如下：</p>

<p> Family: Marion<br/>
 Font: Marion-Italic<br/>
 Font: Marion-Bold<br/>
 Font: Marion-Regular<br/>
 Family: Copperplate<br/>
 Font: Copperplate-Light<br/>
 Font: Copperplate<br/>
 Font: Copperplate-Bold<br/>
 Family: Heiti SC<br/>
 Font: STHeitiSC-Medium<br/>
 Font: STHeitiSC-Light<br/>
 Family: Iowan Old Style<br/>
 Font: IowanOldStyle-Italic<br/>
 Font: IowanOldStyle-Roman<br/>
 Font: IowanOldStyle-BoldItalic<br/>
 Font: IowanOldStyle-Bold<br/>
 Family: Courier New<br/>
 Font: CourierNewPS-BoldMT<br/>
 Font: CourierNewPS-ItalicMT<br/>
 Font: CourierNewPSMT<br/>
 Font: CourierNewPS-BoldItalicMT<br/>
 Family: Apple SD Gothic Neo<br/>
 Font: AppleSDGothicNeo-Bold<br/>
 Font: AppleSDGothicNeo-Thin<br/>
 Font: AppleSDGothicNeo-Regular<br/>
 Font: AppleSDGothicNeo-Light<br/>
 Font: AppleSDGothicNeo-Medium<br/>
 Font: AppleSDGothicNeo-SemiBold<br/>
 Family: Heiti TC<br/>
 Font: STHeitiTC-Medium<br/>
 Font: STHeitiTC-Light<br/>
 Family: Gill Sans<br/>
 Font: GillSans-Italic<br/>
 Font: GillSans-Bold  <br/>
 Font: GillSans-BoldItalic<br/>
 Font: GillSans-LightItalic<br/>
 Font: GillSans<br/>
 Font: GillSans-Light<br/>
 Family: Thonburi<br/>
 Font: Thonburi<br/>
 Font: Thonburi-Bold<br/>
 Font: Thonburi-Light<br/>
 Family: Marker Felt<br/>
 Font: MarkerFelt-Thin
 Font: MarkerFelt-Wide<br/>
 Family: Avenir Next Condensed<br/>
 Font: AvenirNextCondensed-BoldItalic<br/>
 Font: AvenirNextCondensed-Heavy<br/>
 Font: AvenirNextCondensed-Medium<br/>
 Font: AvenirNextCondensed-Regular<br/>
 Font: AvenirNextCondensed-HeavyItalic<br/>
 Font: AvenirNextCondensed-MediumItalic<br/>
 Font: AvenirNextCondensed-Italic<br/>
 Font: AvenirNextCondensed-UltraLightItalic<br/>
 Font: AvenirNextCondensed-UltraLight<br/>
 Font: AvenirNextCondensed-DemiBold<br/>
 Font: AvenirNextCondensed-Bold<br/>
 Font: AvenirNextCondensed-DemiBoldItalic<br/>
 Family: Tamil Sangam MN<br/>
 Font: TamilSangamMN<br/>
 Font: TamilSangamMN-Bold<br/>
 Family: Helvetica Neue<br/>
 Font: HelveticaNeue-Italic<br/>
 Font: HelveticaNeue-Bold<br/>
 Font: HelveticaNeue-UltraLight<br/>
 Font: HelveticaNeue-CondensedBlack<br/>
 Font: HelveticaNeue-BoldItalic<br/>
 Font: HelveticaNeue-CondensedBold<br/>
 Font: HelveticaNeue-Medium<br/>
 Font: HelveticaNeue-Light  <br/>
 Font: HelveticaNeue-Thin<br/>
 Font: HelveticaNeue-ThinItalic<br/>
 Font: HelveticaNeue-LightItalic<br/>
 Font: HelveticaNeue-UltraLightItalic<br/>
 Font: HelveticaNeue-MediumItalicv
 Font: HelveticaNeue<br/>
 Family: Gurmukhi MN<br/>
 Font: GurmukhiMN-Bold<br/>
 Font: GurmukhiMN<br/>
 Family: Times New Roman<br/>
 Font: TimesNewRomanPSMTv
 Font: TimesNewRomanPS-BoldItalicMT<br/>
 Font: TimesNewRomanPS-ItalicMT<br/>
 Font: TimesNewRomanPS-BoldMT<br/>
 Family: Georgia<br/>
 Font: Georgia-BoldItalic<br/>
 Font: Georgia  <br/>
 Font: Georgia-Italic<br/>
 Font: Georgia-Bold<br/>
 Family: Apple Color Emoji<br/>
 Font: AppleColorEmoji<br/>
 Family: Arial Rounded MT Bold<br/>
 Font: ArialRoundedMTBold<br/>
 Family: Kailasa<br/>
 Font: Kailasa-Bold<br/>
 Font: Kailasa<br/>
 Family: Sinhala Sangam MN<br/>
 Font: SinhalaSangamMN-Bold<br/>
 Font: SinhalaSangamMN<br/>
 Family: Chalkboard SE<br/>
 Font: ChalkboardSE-Bold<br/>
 Font: ChalkboardSE-Light<br/>
 Font: ChalkboardSE-Regular<br/>
 Family: Superclarendon<br/>
 Font: Superclarendon-Italic<br/>
 Font: Superclarendon-Black<br/>
 Font: Superclarendon-LightItalic
 Font: Superclarendon-BlackItalic<br/>
 Font: Superclarendon-BoldItalic<br/>
 Font: Superclarendon-Light<br/>
 Font: Superclarendon-Regular<br/>
 Font: Superclarendon-Bold<br/>
 Family: Gujarati Sangam MN<br/>
 Font: GujaratiSangamMN-Bold<br/>
 Font: GujaratiSangamMN<br/>
 Family: Geeza Pro<br/>
 Font: GeezaPro-Light<br/>
 Font: GeezaPro<br/>
 Font: GeezaPro-Bold<br/>
 Family: Noteworthy<br/>
 Font: Noteworthy-Light<br/>
 Font: Noteworthy-Bold<br/>
 Family: Damascus<br/>
 Font: DamascusBold<br/>
 Font: DamascusSemiBold<br/>
 Font: DamascusMedium<br/>
 Font: Damascus
 Family: Avenir<br/>
 Font: Avenir-Medium<br/>
 Font: Avenir-HeavyOblique<br/>
 Font: Avenir-Book<br/>
 Font: Avenir-Light<br/>
 Font: Avenir-Roman<br/>
 Font: Avenir-BookOblique<br/>
 Font: Avenir-Black<br/>
 Font: Avenir-MediumOblique<br/>
 Font: Avenir-BlackOblique<br/>
 Font: Avenir-Heavy<br/>
 Font: Avenir-LightOblique<br/>
 Font: Avenir-Oblique<br/>
 Family: Academy Engraved LET<br/>
 Font: AcademyEngravedLetPlain<br/>
 Family: Mishafi<br/>
 Font: DiwanMishafi<br/>
 Family: Futura<br/>
 Font: Futura-CondensedMedium<br/>
 Font: Futura-CondensedExtraBold<br/>
 Font: Futura-Medium<br/>
 Font: Futura-MediumItalicv
 Family: Farah<br/>
 Font: Farah<br/>
 Family: Kannada Sangam MN<br/>
 Font: KannadaSangamMN<br/>
 Font: KannadaSangamMN-Bold<br/>
 Family: Arial Hebrew<br/>
 Font: ArialHebrew-Bold<br/>
 Font: ArialHebrew-Light<br/>
 Font: ArialHebrew<br/>
 Family: Arial<br/>
 Font: ArialMT<br/>
 Font: Arial-BoldItalicMT<br/>
 Font: Arial-BoldMT<br/>
 Font: Arial-ItalicMT<br/>
 Family: Party LET<br/>
 Font: PartyLetPlain<br/>
 Family: Chalkduster<br/>
 Font: Chalkduster<br/>
 Family: Hiragino Kaku Gothic ProN<br/>
 Font: HiraKakuProN-W6<br/>
 Font: HiraKakuProN-W3  <br/>
 Family: Hoefler Text<br/>
 Font: HoeflerText-Italicv
 Font: HoeflerText-Regular<br/>
 Font: HoeflerText-Black<br/>
 Font: HoeflerText-BlackItalicv
 Family: Optima<br/>
 Font: Optima-Regular<br/>
 Font: Optima-ExtraBlack<br/>
 Font: Optima-BoldItalic<br/>
 Font: Optima-Italic<br/>
 Font: Optima-Bold<br/>
 Family: Palatino<br/>
 Font: Palatino-Bold<br/>
 Font: Palatino-Roman<br/>
 Font: Palatino-BoldItalic<br/>
 Font: Palatino-Italic<br/>
 Family: Malayalam Sangam MN<br/>
 Font: MalayalamSangamMN-Bold<br/>
 Font: MalayalamSangamMN<br/>
 Family: Al Nile<br/>
 Font: AlNile-Bold<br/>
 Font: AlNile<br/>
 Family: Bradley Hand<br/>
 Font: BradleyHandITCTT-Bold<br/>
 Family: Hiragino Mincho ProN<br/>
 Font: HiraMinProN-W6<br/>
 Font: HiraMinProN-W3<br/>
 Family: Trebuchet MS<br/>
 Font: Trebuchet-BoldItalic<br/>
 Font: TrebuchetMS<br/>
 Font: TrebuchetMS-Bold<br/>
 Font: TrebuchetMS-Italic<br/>
 Family: Helvetica<br/>
 Font: Helvetica-Bold<br/>
 Font: Helvetica<br/>
 Font: Helvetica-LightOblique<br/>
 Font: Helvetica-Oblique<br/>
 Font: Helvetica-BoldOblique<br/>
 Font: Helvetica-Light<br/>
 Family: Courier<br/>
 Font: Courier-BoldObliquev
 Font: Courier<br/>
 Font: Courier-Bold<br/>
 Font: Courier-Oblique<br/>
 Family: Cochin<br/>
 Font: Cochin-Bold<br/>
 Font: Cochin<br/>
 Font: Cochin-Italic<br/>
 Font: Cochin-BoldItalic<br/>
 Family: Devanagari Sangam MNv
 Font: DevanagariSangamMN<br/>
 Font: DevanagariSangamMN-Bold<br/>
 Family: Oriya Sangam MN<br/>
 Font: OriyaSangamMN<br/>
 Font: OriyaSangamMN-Bold<br/>
 Family: Snell Roundhand<br/>
 Font: SnellRoundhand-Bold<br/>
 Font: SnellRoundhand<br/>
 Font: SnellRoundhand-Black<br/>
 Family: Zapf Dingbats<br/>
 Font: ZapfDingbatsITC<br/>
 Family: Bodoni 72<br/>
 Font: BodoniSvtyTwoITCTT-Bold<br/>
 Font: BodoniSvtyTwoITCTT-Book<br/>
 Font: BodoniSvtyTwoITCTT-BookIta<br/>
 Family: Verdana<br/>
 Font: Verdana-Italic<br/>
 Font: Verdana-BoldItalic<br/>
 Font: Verdana<br/>
 Font: Verdana-Bold<br/>
 Family: American Typewriter<br/>
 Font: AmericanTypewriter-CondensedLight<br/>
 Font: AmericanTypewriter<br/>
 Font: AmericanTypewriter-CondensedBold<br/>
 Font: AmericanTypewriter-Light<br/>
 Font: AmericanTypewriter-Bold<br/>
 Font: AmericanTypewriter-Condensed<br/>
 Family: Avenir Next<br/>
 Font: AvenirNext-UltraLight<br/>
 Font: AvenirNext-UltraLightItalic<br/>
 Font: AvenirNext-Bold<br/>
 Font: AvenirNext-BoldItalic<br/>
 Font: AvenirNext-DemiBold<br/>
 Font: AvenirNext-DemiBoldItalic<br/>
 Font: AvenirNext-Medium<br/>
 Font: AvenirNext-HeavyItalic<br/>
 Font: AvenirNext-Heavy<br/>
 Font: AvenirNext-Italic<br/>
 Font: AvenirNext-Regular<br/>
 Font: AvenirNext-MediumItalic<br/>
 Family: Baskerville<br/>
 Font: Baskerville-Italic<br/>
 Font: Baskerville-SemiBold<br/>
 Font: Baskerville-BoldItalic<br/>
 Font: Baskerville-SemiBoldItalic<br/>
 Font: Baskerville-Bold<br/>
 Font: Baskerville<br/>
 Family: Didot<br/>
 Font: Didot-Italicv
 Font: Didot-Bold<br/>
 Font: Didot<br/>
 Family: Savoye LET<br/>
 Font: SavoyeLetPlain<br/>
 Family: Bodoni Ornaments<br/>
 Font: BodoniOrnamentsITCTT<br/>
 Family: Symbol<br/>
 Font: Symbol<br/>
 Family: Menlo<br/>
 Font: Menlo-Italic<br/>
 Font: Menlo-Bold<br/>
 Font: Menlo-Regular<br/>
 Font: Menlo-BoldItalic<br/>
 Family: Bodoni 72 Smallcaps<br/>
 Font: BodoniSvtyTwoSCITCTT-Book<br/>
 Family: DIN Alternate<br/>
 Font: DINAlternate-Bold<br/>
 Family: Papyrus<br/>
 Font: Papyrus<br/>
 Font: Papyrus-Condensed<br/>
 Family: Euphemia UCAS<br/>
 Font: EuphemiaUCAS-Italic<br/>
 Font: EuphemiaUCAS<br/>
 Font: EuphemiaUCAS-Bold<br/>
 Family: Telugu Sangam MN<br/>
 Font: TeluguSangamMN<br/>
 Font: TeluguSangamMN-Bold<br/>
 Family: Bangla Sangam MN<br/>
 Font: BanglaSangamMN-Bold<br/>
 Font: BanglaSangamMN<br/>
 Family: Zapfino<br/>
 Font: Zapfino<br/>
 Family: Bodoni 72 Oldstyle<br/>
 Font: BodoniSvtyTwoOSITCTT-Book<br/>
 Font: BodoniSvtyTwoOSITCTT-Bold<br/>
 Font: BodoniSvtyTwoOSITCTT-BookIt<br/>
 Family: DIN Condensed<br/>
 Font: DINCondensed-Bold</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[SpriteKit截屏并分享至社交网络]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/22/spritekitjie-ping-bing-fen-xiang-zhi-she-jiao-wang-luo/"/>
    <updated>2014-04-22T17:36:25+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/22/spritekitjie-ping-bing-fen-xiang-zhi-she-jiao-wang-luo</id>
    <content type="html"><![CDATA[<p>本文讲述在用<code>SpriteKit</code>制作iOS游戏的时候，如何让在用户在达到某种成就后分享自己的成就或分数，并附上一张游戏截屏，然后发到社交网络上</p>

<!--more-->


<h2>SpriteKit截屏</h2>

<p>传统的截屏方法是用UIView的layer来读取渲染上下文，生成图片</p>

<p>``` objc</p>

<p>UIGraphicsBeginImageContext(self.view.frame.size); //currentView 当前的view
[self.view.layer renderInContext:UIGraphicsGetCurrentContext()];
UIImage *viewImage = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();
```</p>

<p>viewImage就是获取的截图，如果要将图片存入相册，只需在后面调用</p>

<p><code>
UIImageWriteToSavedPhotosAlbum(viewImage,nil,nil,nil);
</code>
而这一切都是基于<code>UIKit</code>的，在<code>SpriteKit</code>中，上面的方法是实效的，截屏的效果就是一张白色图片
但在苹果的官方文档中，明确提到了<code>SKTexture</code>的作用，最后一条是说可以将节点树渲染成纹理，可以应用于对游戏截屏。苹果还告诉了我们<code>SKView</code>的一个方法：<code>textureFromNode:</code>，该方法将以node包含的内容渲染成一个纹理，但是如何将<code>SKTexture</code>转换为<code>UIView</code>呢？我在workoverflow的一个<a href="http://stackoverflow.com/questions/21061248/uiimage-from-sktexture">提问</a>中找到了答案：</p>

<h3>方法一：</h3>

<p>```
&ndash; (UIImage<em>) imageWithView:(UIView </em>)view
{</p>

<pre><code>UIGraphicsBeginImageContextWithOptions(view.bounds.size, view.opaque, 0.0);

[view drawViewHierarchyInRect:view.bounds afterScreenUpdates:YES];

UIImage * img = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

return img;
</code></pre>

<p>}</p>

<ul>
<li><p>(UIImage<em>) imageFromNode:(SKNode</em>)node
{
  SKTexture<em>      tex     = [self.scene.view textureFromNode:node];
  SKView</em>         view    = [[SKView alloc]initWithFrame:CGRectMake(0, 0, tex.size.width, tex.size.height)];
  SKScene<em>        scene   = [SKScene sceneWithSize:tex.size];
  SKSpriteNode</em>   sprite  = [SKSpriteNode spriteNodeWithTexture:tex];
  sprite.position = CGPointMake( CGRectGetMidX(view.frame), CGRectGetMidY(view.frame) );
  [scene addChild:sprite];
  [view presentScene:scene];</p>

<p>  return [self imageWithView:view];
}
```</p></li>
<li>get the SKTexture for your node using the current SKView</li>
<li>make another SKView that is just big enough for your texture</li>
<li>add a SKSpriteNode with the texture into your new scene, placing it in the middle</li>
<li>render the view into a graphics context</li>
</ul>


<h3>方法二:</h3>

<p>```
&ndash;(UIImage <em>)imageFromNode:(SKNode </em>)node {</p>

<pre><code>SKView *view = node.scene.view;
CGFloat scale = [UIScreen mainScreen].scale;
CGRect nodeFrame = [node calculateAccumulatedFrame];

// render SKView into UIImage
UIGraphicsBeginImageContextWithOptions(view.bounds.size, YES, 0.0);
[view drawViewHierarchyInRect:view.bounds afterScreenUpdates:YES];
UIImage *sceneSnapshot = UIGraphicsGetImageFromCurrentImageContext();
UIGraphicsEndImageContext();

// crop to the requested node (making sure to flip the y-coordinate)
CGFloat originY = sceneSnapshot.size.height*scale - nodeFrame.origin.y*scale - nodeFrame.size.height*scale;
CGRect cropRect = CGRectMake(nodeFrame.origin.x * scale, originY, nodeFrame.size.width*scale, nodeFrame.size.height*scale);
CGImageRef croppedSnapshot = CGImageCreateWithImageInRect(sceneSnapshot.CGImage, cropRect);
UIImage *nodeSnapshot = [UIImage imageWithCGImage:croppedSnapshot];
CGImageRelease(croppedSnapshot);

return nodeSnapshot;
</code></pre>

<p>}
```
<strong>以上两个方法亲测好使！</strong></p>

<h2>使用Social.Framework分享游戏战绩</h2>

<p>因为比较懒不想在各种第三方社交网站申请APP注册然后使用SDK等，有点复杂，所以暂时用了苹果自带的Social.Framework</p>

<p>首先推荐一个比较好的<a href="https://github.com/yulingtianxia/ios6ShareDemo.git">Demo</a>，代码很容易读，容易上手</p>

<p>首先到target，Build Phases->link binary with libraries，添加social.framework，然后在要使用这个framework的文件头添加<code>@import Social;</code></p>

<p>记得要到iphone或者simulator里设置好对应社交网络的账号，填上用户名密码登录上，不然找不到account，不能post。如果找不到新浪微博，把系统语言调到中文。如果没有预先设置好账号，social.framework在真机和simulator上表现会不同。</p>

<h3>使用UIActivityViewController</h3>

<p>```
//某个SKScene中添加的代码</p>

<pre><code>    sharingImage = [self imageFromNode:self];//获取截屏图片
    NSArray *activityItems;
    if (sharingImage != nil) {
        activityItems = @[sharingText, sharingImage];
    } else {
        activityItems = @[sharingText];
    }

    UIActivityViewController *activityController =
    [[UIActivityViewController alloc] initWithActivityItems:activityItems
                                      applicationActivities:nil];

    [(UIViewController *)[self.view nextResponder] presentViewController:activityController
                       animated:YES completion:nil];
</code></pre>

<p>```</p>

<p><code>[self.view nextResponder]</code>的作用是获取当前<code>SKScene</code>的<code>UIViewController</code></p>

<p>如果想系统的学一下<code>UIActivityViewController</code>，建立看看这篇翻译自<a href="http://nshipster.com/uiactivityviewcontroller/">Mattt Thompson</a>的<a href="https://github.com/nixzhu/dev-blog/blob/master/2014-04-22-ui-activity-viewcontroller.md">博文</a></p>

<h3>使用SLComposeViewController</h3>

<p>这个就相当于上面里介绍的单个分享service
目前支持的平台有以下这些：</p>

<p><code>
SOCIAL_EXTERN NSString *const SLServiceTypeTwitter NS_AVAILABLE(10_8, 6_0);
SOCIAL_EXTERN NSString *const SLServiceTypeFacebook NS_AVAILABLE(10_8, 6_0);
SOCIAL_EXTERN NSString *const SLServiceTypeSinaWeibo NS_AVAILABLE(10_8, 6_0);
SOCIAL_EXTERN NSString *const SLServiceTypeTencentWeibo NS_AVAILABLE(10_9, 7_0);
SOCIAL_EXTERN NSString *const SLServiceTypeLinkedIn NS_AVAILABLE(10_9, NA);
</code>
先声明一个<code>SLComposeViewController *slComposerSheet;</code>，然后在需要添加分享逻辑的地方加入下面代码：(依然以微博为例子)</p>

<p>```</p>

<pre><code>[slComposerSheet setCompletionHandler:^(SLComposeViewControllerResult result) {
    NSLog(@"start completion block");
    NSString *output;
    switch (result) {
        case SLComposeViewControllerResultCancelled:
            output = @"Action Cancelled";
            break;
        case SLComposeViewControllerResultDone:
            output = @"Post Successfull";
            break;
        default:
            break;
    }
    if (result != SLComposeViewControllerResultCancelled)
    {
        UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@"Weibo Message" message:output delegate:nil cancelButtonTitle:@"Ok" otherButtonTitles:nil];
        [alert show];
    }
}];

if([SLComposeViewController isAvailableForServiceType:SLServiceTypeSinaWeibo])
{
    slComposerSheet = [SLComposeViewController composeViewControllerForServiceType:SLServiceTypeSinaWeibo];
    [slComposerSheet setInitialText:self.sharingText];
    [slComposerSheet addImage:self.sharingImage];
    [slComposerSheet addURL:[NSURL URLWithString:@"http://www.weibo.com/"]];
    [self presentViewController:slComposerSheet animated:YES completion:nil];
}
</code></pre>

<p>```
这种方法我没试过，代码是照抄自前面提到的<a href="https://github.com/yulingtianxia/ios6ShareDemo.git">Demo</a>里</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[用DFS算法计算SpriteKit中复合体的构成]]></title>
    <link href="http://yulingtianxia.com/blog/2014/04/21/yong-dfssuan-fa-ji-suan-spritekitzhong-fu-he-ti-de-gou-cheng/"/>
    <updated>2014-04-21T21:06:55+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/04/21/yong-dfssuan-fa-ji-suan-spritekitzhong-fu-he-ti-de-gou-cheng</id>
    <content type="html"><![CDATA[<p>在使用Sprite Kit开发iOS游戏的时候，有时我们需要把一些<code>SKNode</code>(或者其子类)的物理体(<code>SKPhysicsBody</code>)通过某种方式连在一起组合成一个<code>SKPhysicsJoint</code>，这样就可以让这个连接体在物理世界一起被模拟。例如我们可以将两个<code>SKNode</code>用绳子(<code>SKPhysicsJointLimit</code>)，弹簧(<code>SKPhysicsJointSpring</code>)，胶水(<code>SKPhysicsJointFixed</code>)，钉子(<code>SKPhysicsJointPin</code>)，滑轨(<code>SKPhysicsJointSliding</code>)组合在一起。</p>

<p>想象一些复杂的情况，比如玩家需要将游戏中多个相同的<code>SKNode</code>按照某种规则组合到一起，每个组合体包含<code>SKNode</code>的多少甚至形状(树或是环)都是游戏衡量玩家得分的标准。举个简单的例子：游戏里有好多彩色的球，玩家操作小球把它们粘在一起，将5个球粘在一起那么就能获得一份奖励</p>

<p>但是每个<code>SKPhysicsJoint</code>只负责将两个<code>SKPhysicsBody</code>连在一起</p>

<!--more-->


<p>其实这个问题可以简单归结为求图论中的联通图<br/>
我写了个<code>Graph</code>类，只需在初始化的时候传入想要参加计算的<code>SKNode</code>数组即可，主要是用递归实现<code>DFS(深度优先搜索)</code>，维护N个集合(<code>NSSet</code>)，N的个数就是游戏中子图的个数，最小的子图就是一个<code>SKNode</code>。</p>

<p>代码：</p>

<script src="https://gist.github.com/yulingtianxia/11142742.js"></script>


<p>可以在任意你需要的时候获取联通图信息：</p>

<p>``` objc</p>

<p>NSMutableArray <em>nodes = [NSMutableArray array];
[thisAtom.scene enumerateChildNodesWithName:AtomName usingBlock:^(SKNode </em>node, BOOL *stop) {</p>

<pre><code>    [nodes addObject:node];
}];
</code></pre>

<p>Graph *graph = [[Graph alloc] initWithNodes:nodes];
for (int i=0; i&lt;[graph.sets count]; i++) {</p>

<pre><code>NSLog(@"%@",graph.sets[i]);
</code></pre>

<p>}
```</p>

<p>完整代码在<a href="https://github.com/yulingtianxia/MyFirstGame.git">这里</a>的<code>ColorAtom</code>工程<br/>
在向<code>SKSpriteNode.userdata</code>写键值对的时候，发现写进去后再读取依然是nil，这是因为<code>userdata</code>属性完全归用户随意使用，苹果甚至在SKSpriteNode初始化的时候干脆默认<code>userdata</code>是<code>nil</code>，所以需要初始化下：</p>

<p><code>
((SKSpriteNode *)nodes[i]).userData = [NSMutableDictionary dictionary];
</code>
感谢StackOverFlow网友的回答：<a href="http://stackoverflow.com/questions/19073199/sprite-kit-ios7-sknode-userdata-property-not-storing-values">http://stackoverflow.com/questions/19073199/sprite-kit-ios7-sknode-userdata-property-not-storing-values</a></p>
]]></content>
  </entry>
  
</feed>
