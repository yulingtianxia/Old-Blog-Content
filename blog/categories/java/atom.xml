<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-05-10T17:56:12+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[装饰者模式]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi/"/>
    <updated>2014-05-10T09:47:05+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>

<p><img src="/images/blog/QQ20140510-1@2x.png" alt="" /></p>

<!--more-->


<ul>
<li>装饰者和被装饰对象有相同的超类型。- 你可以用一个或多个装饰者包装一个对象。- 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合 ,可以用装饰过的对象代替它。- <strong>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。</strong>&ndash; 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。<br/>
<strong>类应该对扩展开放，对修改关闭。</strong></li>
</ul>


<h2>用配置咖啡饮料做例子</h2>

<p>比如，现在有一个饮料类（Beverage），向饮料中添加不同的配料（蒸奶（Steamed Milk）、豆浆（Soy）、摩卡（Mocha，也就是巧克力风味）或覆盖奶泡），就会配制出很多种不同的种类的饮料，其价格也随着添加的配料而变化，饮料店需要计算价格，如果用具体子类继承饮料类并考虑到所有组合的话，将是一个“类爆炸”：<br/>
<img src="/images/blog/QQ20140510-2@2x.png" alt="" /><br/>
更恶心的是，如果某种配料的价格有变化，就必须含有此配料相应的更改一些饮料子类的实现，记住：<strong>类应该对扩展开放，对修改关闭。</strong> <br/>
应用装饰者模式，就像给对象穿衣服一样一层一层将拓展动态的添加上去，灵活多变有弹性<br/>
<img src="/images/blog/QQ20140510-3@2x.png" alt="" /></p>

<p>``` objc</p>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (BaseFilter)
&ndash; (CGContextRef) beginContext
{</p>

<pre><code>CGSize size = [self size];
UIGraphicsBeginImageContextWithOptions(size, NO, 0);
CGContextRef context = UIGraphicsGetCurrentContext();

return context;
</code></pre>

<p>}</p>

<ul>
<li><p>(UIImage *) getImageFromCurrentImageContext
{
  [self drawAtPoint:CGPointZero];</p>

<p>  // Retrieve the UIImage from the current context
  UIImage *imageOut = UIGraphicsGetImageFromCurrentImageContext();</p>

<p>  return imageOut;
}</p></li>
<li><p>(void) endContext
{
  UIGraphicsEndImageContext();
}
@end
<code>
Transform类别定义了一个`imageWithTransform:transform`方法，接受一个转换引用，然后把应用于内部的图像引用，并让它把自己画出来，然后返回变换后的图像:  
</code> #import &ldquo;UIImage+Transform.h&rdquo;</p>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (Transform)</p></li>
<li><p>(UIImage *) imageWithTransform:(CGAffineTransform)transform
{
  CGContextRef context = [self beginContext];</p>

<p>  // setup transformation
  CGContextConcatCTM(context, transform);</p>

<p>  // Draw the original image to the context
  UIImage *imageOut = [self getImageFromCurrentImageContext];</p>

<p>  [self endContext];</p>

<p>  return imageOut;
}
@end
```</p></li>
</ul>


<p>Shadow类别定义了一个<code>imageWithDropShadow</code>方法，向图像的内部引用添加阴影效果，并返回应用效果之后的最终图像。</p>

<p>```</p>

<h1>import &ldquo;UIImage+Shadow.h&rdquo;</h1>

<h1>import &ldquo;UIImage+BaseFilter.h&rdquo;</h1>

<p>@implementation UIImage (Shadow)
&ndash; (UIImage *) imageWithDropShadow
{</p>

<pre><code>CGContextRef context = [self beginContext];

// set up shadow
CGSize offset = CGSizeMake (-25,  15);
CGContextSetShadow(context, offset, 20.0);

// Draw the original image to the context
UIImage * imageOut = [self getImageFromCurrentImageContext];

[self endContext];

return imageOut;
</code></pre>

<p>}
@end
```
最后在ViewController中加载图像：</p>

<p>```
&ndash; (void)viewDidLoad
{</p>

<pre><code>[super viewDidLoad];
// Do any additional setup after loading the view, typically from a nib.
UIImage *image = imageView.image;


// create a transformation
CGAffineTransform rotateTransform = CGAffineTransformMakeRotation(-M_PI / 4.0);
CGAffineTransform translateTransform = CGAffineTransformMakeTranslation(-image.size.width / 2.0,
                                                                        image.size.height / 8.0);
CGAffineTransform finalTransform = CGAffineTransformConcat(rotateTransform, translateTransform);
UIImage* finalImage = [[image imageWithTransform:finalTransform] imageWithDropShadow];
[imageView setImage:finalImage];
</code></pre>

<p>}
```</p>

<p>因为类别只能拓展方法，不能在原有类的基础上添加属性，但是我们依然可以通过下面的方式向类中动态添加属性，来弥补类别的不足：</p>

<p>给UIImage添加一个新的title属性<br/>
具体代码如下：<br/>
<code>UIImage+Title.h</code>:</p>

<p><code>
@interface UIImage(Title)
@property(nonatomic, copy) NSString *title;
@end
</code>
<code>UIImage+Title.m</code>:</p>

<p>```</p>

<h1>import &ldquo;UIImage+Title.h&rdquo;</h1>

<p>static char titleKey;</p>

<p>@implementation UIImage(Title)
&ndash; (NSString *)title
{</p>

<pre><code>return objc_getAssociatedObject(self, &amp;titleKey);
</code></pre>

<p>}</p>

<ul>
<li>(void)setTitle:(NSString *)title
{
  objc_setAssociatedObject(self, &amp;titleKey, title, OBJC_ASSOCIATION_COPY);
}
@end
```
可以看到关键是用到了runtime的两个函数：</li>
<li><code>id objc_getAssociatedObject(id object, void *key)</code></li>
<li><code>void objc_setAssociatedObject(id object, void *key, id value, objc_AssociationPolicy policy)</code></li>
</ul>


<p>该函数中第一位参数表示目标对象，第三个参数表示要添加的属性，第四个参数设置objc_AssociationPolicy，它有以下几个选项：<code>OBJC_ASSOCIATION_ASSIGN</code>，<code>OBJC_ASSOCIATION_RETAIN</code>，<code>OBJC_ASSOCIATION_COPY</code>，分别对应我们在声明属性时的<code>assign</code>,<code>retain</code>,<code>copy</code>。<br/>
关于第二个参数，key。因为一个对象可以关联多个新的对像，我们需要一个标志来区分他们。所以这个key就起这样的作用。这里的需要的key的地址，不关心它指向谁。</p>

<p>当我们第二次以新的value调用objc_setAssociatedObject时，如果policy是OBJC_ASSOCIATION_ASSIGN，新的value被关联，对原来旧的value没有任何影响。如果policy是OBJC_ASSOCIATION_RETAIN和OBJC_ASSOCIATION_COPY，新的value被关联，旧的value被release。如果想release原来的value又不关联新的value，，可以用objc_setAssociatedObject直接传一个nil做为value的值。</p>

<p>注意不要使用<code>objc_removeAssociatedObjects</code>，因为它用去掉所有的关联的对象。参考资料：<br/>
1. 《iOS设计模式解析》<br/>
2. 《HeadFirst设计模式》<br/>
3. <a href="http://fanliugen.com/?p=460">http://fanliugen.com/?p=460</a></p>
]]></content>
  </entry>
  
</feed>
