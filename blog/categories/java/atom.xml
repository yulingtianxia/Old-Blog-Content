<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Java | 玉令天下的Blog]]></title>
  <link href="http://yulingtianxia.com/blog/categories/java/atom.xml" rel="self"/>
  <link href="http://yulingtianxia.com/"/>
  <updated>2014-05-10T16:46:42+08:00</updated>
  <id>http://yulingtianxia.com/</id>
  <author>
    <name><![CDATA[玉令天下]]></name>
    <email><![CDATA[yulingtianxia@gmail.com]]></email>
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[装饰者模式]]></title>
    <link href="http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi/"/>
    <updated>2014-05-10T09:47:05+08:00</updated>
    <id>http://yulingtianxia.com/blog/2014/05/10/zhuang-shi-zhe-mo-shi</id>
    <content type="html"><![CDATA[<p>装饰者模式动态地将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</p>

<p><img src="/images/blog/QQ20140510-1@2x.png" alt="" /></p>

<!--more-->


<ul>
<li>装饰者和被装饰对象有相同的超类型。- 你可以用一个或多个装饰者包装一个对象。- 既然装饰者和被装饰对象有相同的超类型，所以在任何需要原始对象（被包装的）的场合 ,可以用装饰过的对象代替它。- <strong>装饰者可以在所委托被装饰者的行为之前与/或之后，加上自己的行为，以达到特定的目的。</strong>&ndash; 对象可以在任何时候被装饰，所以可以在运行时动态地、不限量地用你喜欢的装饰者来装饰对象。<br/>
<strong>类应该对扩展开放，对修改关闭。</strong></li>
</ul>


<h2>用配置咖啡饮料做例子</h2>

<p>比如，现在有一个饮料类（Beverage），向饮料中添加不同的配料（蒸奶（Steamed Milk）、豆浆（Soy）、摩卡（Mocha，也就是巧克力风味）或覆盖奶泡），就会配制出很多种不同的种类的饮料，其价格也随着添加的配料而变化，饮料店需要计算价格，如果用具体子类继承饮料类并考虑到所有组合的话，将是一个“类爆炸”：<br/>
<img src="/images/blog/QQ20140510-2@2x.png" alt="" /><br/>
更恶心的是，如果某种配料的价格有变化，就必须含有此配料相应的更改一些饮料子类的实现，记住：<strong>类应该对扩展开放，对修改关闭。</strong> <br/>
应用装饰着模式，就像给对象穿衣服一样一层一层将拓展动态的添加上去，灵活多变有弹性<br/>
<img src="/images/blog/QQ20140510-3@2x.png" alt="" /></p>

<p>下面用Java实现这个例子</p>

<p>Beverage是一个抽象类，有两个方法：getDescrip-tion()及cost()。<br/>
<code>java
public abstract class Beverage {String description = "Unknown Beverage";public String getDescription() {return description;}public abstract double cost();}</code>
Beverage很简单。让我们也来实现Condiment（配料）抽象类，也就是装饰者类吧：<br/>
<code>
public abstract class CondimentDecorator extends Beverage {public abstract String getDescription();}</code>
必须让Condiment Decorator能够取代Beverage，所以将CondimentDecorator扩展自 Beverage 类。<br/>
现在，已经有了基类，让我们开始开始实现一些饮料吧！先从浓缩咖啡（Espresso）开始。别忘了，我们需要为具体的饮料设置描述，而且还必须实现cost()方法。<br/>
<code>
public class Espresso extends Beverage {public Espresso() {description = "Espresso";}public double cost() {return 1.99;}}</code>
其他几种具体的饮料就不写了<br/>
如果你回头去看看装饰者模式的类图，将发现我们已经完成了抽象组件（Beverage），有了具体组件（HouseBlend），也有了抽象装饰者（CondimentDecorator）。现在，我们就来实现具体装饰者。先从摩卡下手：<br/>
<code>
public class Mocha extends CondimentDecorator {Beverage beverage;public Mocha(Beverage beverage) {this.beverage = beverage;}public String getDescription() {return beverage.getDescription() + ", Mocha";}public double cost() {return .20 + beverage.cost();}}</code>
你会发现在装饰者类中，完成了描述和价格的效果添加，也就是完成了拓展<br/>
其他几种配料代码就不写了<br/>
下面进行测试：<br/>
<code>
public class StarbuzzCoffee {public static void main(String args[]) {Beverage beverage = new Espresso();System.out.println(beverage.getDescription()+ " $" + beverage.cost());Beverage beverage2 = new DarkRoast();beverage2 = new Mocha(beverage2);beverage2 = new Mocha(beverage2);beverage2 = new Whip(beverage2);System.out.println(beverage2.getDescription()+ " $" + beverage2.cost());Beverage beverage3 = new HouseBlend();beverage3 = new Soy(beverage3);beverage3 = new Mocha(beverage3);beverage3 = new Whip(beverage3);System.out.println(beverage3.getDescription()+ " $" + beverage3.cost());}}</code>
输出结果：</p>

<p><code>
% java StarbuzzCoffeeEspresso $1.99Dark Roast Coffee, Mocha, Mocha, Whip $1.49House Blend Coffee, Soy, Mocha, Whip $1.34%
</code>
果然是一层套一层吧：<br/>
<img src="/images/blog/QQ20140510-4@2x.png" alt="" /></p>

<h2>Java中的装饰者</h2>

<p>java.io包内的类太多了，简直是……“排山倒海”。你第一次（还有第二次和第三次）看到这些API发出“哇”的惊叹时，放心，你不是唯一受到惊吓的人。现在，你已经知道装饰者模式，这些I/O的相关类对你来说应该更有意义了，因为其中许多类都是装饰者。下面是一个典型的对象集合，用装饰者来将功能结合起来，以读取文件数据：<br/>
<img src="/images/blog/QQ20140510-5@2x.png" alt="" /><br/>
BufferedInputStream及LineNumberInputStream都扩展自FilterInputStream，而FilterInputStream是一个抽象的装饰类。<br/>
<img src="/images/blog/QQ20140510-6@2x.png" alt="" /><br/>
你会发现“输出”流的设计方式也是一样的。你可能还会发现Reader/Writer流（作为基于字符数据的输入输出）和输入流/输出流的类相当类似（虽然有一些小差异和不一致之处，但是相当雷同，所以你应该可以了解这些类）。<br/>
但是JavaAI/O也引出装饰者模式的一个“缺点”：利用装饰者模式，常常造成设计中有大量的小类，数量实在太多，可能会造成使用此API程序员的困扰。但是，现在你已经了解了装饰者的工作原理，以后当使用别人的大量装饰的API时，就可以很容易地辨别出他们的装饰者类是如何组织的，以方便用包装方式取得想要的行为。</p>

<h2>Objective-C类别与装饰模式</h2>

<p>Objective-C中也可以实现基于继承和接口的装饰者模式，但这里介绍的是另一种实现方法：类别<br/>
类别是一个Objective-C的语言功能，通过它可以向类添加行为（方法的接口与实现），而不必进行子类化。通过类别添加的方法对类原有的方法没有不良影响。类别中的方法成为了类的一部分，并可由其子类继承。<br/>
我们可以用类别来实现装饰模式，然而这不是一种严格的实现，它实现了模式的意图，但却是一种变体。由装饰器类别添加的行为是编译时绑定的，虽然Objective-C原本支持动态绑定（应该用方法的哪个实现）。而且装饰器类别实际上没有封装被扩展的类的实例。<br/>
尽管使用类别来实现这个模式跟原始风格有些偏离，但是实现少量的装饰器的时候，它比真正子类的方式更为轻量、更为容易。
这次我们来装饰一张照片，装饰的方法有很多，比如旋转位移变换，阴影。。。<br/>
<img src="/images/blog/QQ20140510-7@2x.png" alt="" /></p>

<p>代码可以在<a href="https://github.com/yulingtianxia/Decorator">这里</a>下载</p>
]]></content>
  </entry>
  
</feed>
